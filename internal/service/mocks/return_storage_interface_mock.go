// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i gitlab.ozon.dev/akugnerevich/homework.git/internal/storage.ReturnStorageInterface -o return_storage_interface_mock_test.go -n ReturnStorageInterfaceMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
)

// ReturnStorageInterfaceMock implements mm_storage.ReturnStorageInterface
type ReturnStorageInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddReturnToStorage          func(r *models.Return) (err error)
	funcAddReturnToStorageOrigin    string
	inspectFuncAddReturnToStorage   func(r *models.Return)
	afterAddReturnToStorageCounter  uint64
	beforeAddReturnToStorageCounter uint64
	AddReturnToStorageMock          mReturnStorageInterfaceMockAddReturnToStorage

	funcDeleteReturnFromStorage          func(id uint)
	funcDeleteReturnFromStorageOrigin    string
	inspectFuncDeleteReturnFromStorage   func(id uint)
	afterDeleteReturnFromStorageCounter  uint64
	beforeDeleteReturnFromStorageCounter uint64
	DeleteReturnFromStorageMock          mReturnStorageInterfaceMockDeleteReturnFromStorage

	funcGetReturn          func(id uint) (rp1 *models.Return, b1 bool)
	funcGetReturnOrigin    string
	inspectFuncGetReturn   func(id uint)
	afterGetReturnCounter  uint64
	beforeGetReturnCounter uint64
	GetReturnMock          mReturnStorageInterfaceMockGetReturn

	funcGetReturnIDs          func() (ua1 []uint)
	funcGetReturnIDsOrigin    string
	inspectFuncGetReturnIDs   func()
	afterGetReturnIDsCounter  uint64
	beforeGetReturnIDsCounter uint64
	GetReturnIDsMock          mReturnStorageInterfaceMockGetReturnIDs

	funcIsConsist          func(id uint) (b1 bool)
	funcIsConsistOrigin    string
	inspectFuncIsConsist   func(id uint)
	afterIsConsistCounter  uint64
	beforeIsConsistCounter uint64
	IsConsistMock          mReturnStorageInterfaceMockIsConsist

	funcReadFromJSON          func() (err error)
	funcReadFromJSONOrigin    string
	inspectFuncReadFromJSON   func()
	afterReadFromJSONCounter  uint64
	beforeReadFromJSONCounter uint64
	ReadFromJSONMock          mReturnStorageInterfaceMockReadFromJSON

	funcWriteToJSON          func() (err error)
	funcWriteToJSONOrigin    string
	inspectFuncWriteToJSON   func()
	afterWriteToJSONCounter  uint64
	beforeWriteToJSONCounter uint64
	WriteToJSONMock          mReturnStorageInterfaceMockWriteToJSON
}

// NewReturnStorageInterfaceMock returnStorage a mock for mm_storage.ReturnStorageInterface
func NewReturnStorageInterfaceMock(t minimock.Tester) *ReturnStorageInterfaceMock {
	m := &ReturnStorageInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddReturnToStorageMock = mReturnStorageInterfaceMockAddReturnToStorage{mock: m}
	m.AddReturnToStorageMock.callArgs = []*ReturnStorageInterfaceMockAddReturnToStorageParams{}

	m.DeleteReturnFromStorageMock = mReturnStorageInterfaceMockDeleteReturnFromStorage{mock: m}
	m.DeleteReturnFromStorageMock.callArgs = []*ReturnStorageInterfaceMockDeleteReturnFromStorageParams{}

	m.GetReturnMock = mReturnStorageInterfaceMockGetReturn{mock: m}
	m.GetReturnMock.callArgs = []*ReturnStorageInterfaceMockGetReturnParams{}

	m.GetReturnIDsMock = mReturnStorageInterfaceMockGetReturnIDs{mock: m}

	m.IsConsistMock = mReturnStorageInterfaceMockIsConsist{mock: m}
	m.IsConsistMock.callArgs = []*ReturnStorageInterfaceMockIsConsistParams{}

	m.ReadFromJSONMock = mReturnStorageInterfaceMockReadFromJSON{mock: m}

	m.WriteToJSONMock = mReturnStorageInterfaceMockWriteToJSON{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReturnStorageInterfaceMockAddReturnToStorage struct {
	optional           bool
	mock               *ReturnStorageInterfaceMock
	defaultExpectation *ReturnStorageInterfaceMockAddReturnToStorageExpectation
	expectations       []*ReturnStorageInterfaceMockAddReturnToStorageExpectation

	callArgs []*ReturnStorageInterfaceMockAddReturnToStorageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockAddReturnToStorageExpectation specifies expectation struct of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageExpectation struct {
	mock               *ReturnStorageInterfaceMock
	params             *ReturnStorageInterfaceMockAddReturnToStorageParams
	paramPtrs          *ReturnStorageInterfaceMockAddReturnToStorageParamPtrs
	expectationOrigins ReturnStorageInterfaceMockAddReturnToStorageExpectationOrigins
	results            *ReturnStorageInterfaceMockAddReturnToStorageResults
	returnOrigin       string
	Counter            uint64
}

// ReturnStorageInterfaceMockAddReturnToStorageParams contains parameters of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageParams struct {
	r *models.Return
}

// ReturnStorageInterfaceMockAddReturnToStorageParamPtrs contains pointers to parameters of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageParamPtrs struct {
	r **models.Return
}

// ReturnStorageInterfaceMockAddReturnToStorageResults contains results of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageResults struct {
	err error
}

// ReturnStorageInterfaceMockAddReturnToStorageOrigins contains origins of expectations of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageExpectationOrigins struct {
	origin  string
	originR string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Optional() *mReturnStorageInterfaceMockAddReturnToStorage {
	mmAddReturnToStorage.optional = true
	return mmAddReturnToStorage
}

// Expect sets up expected params for ReturnStorageInterface.AddReturnToStorage
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Expect(r *models.Return) *mReturnStorageInterfaceMockAddReturnToStorage {
	if mmAddReturnToStorage.mock.funcAddReturnToStorage != nil {
		mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Set")
	}

	if mmAddReturnToStorage.defaultExpectation == nil {
		mmAddReturnToStorage.defaultExpectation = &ReturnStorageInterfaceMockAddReturnToStorageExpectation{}
	}

	if mmAddReturnToStorage.defaultExpectation.paramPtrs != nil {
		mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by ExpectParams functions")
	}

	mmAddReturnToStorage.defaultExpectation.params = &ReturnStorageInterfaceMockAddReturnToStorageParams{r}
	mmAddReturnToStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddReturnToStorage.expectations {
		if minimock.Equal(e.params, mmAddReturnToStorage.defaultExpectation.params) {
			mmAddReturnToStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReturnToStorage.defaultExpectation.params)
		}
	}

	return mmAddReturnToStorage
}

// ExpectRParam1 sets up expected param r for ReturnStorageInterface.AddReturnToStorage
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) ExpectRParam1(r *models.Return) *mReturnStorageInterfaceMockAddReturnToStorage {
	if mmAddReturnToStorage.mock.funcAddReturnToStorage != nil {
		mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Set")
	}

	if mmAddReturnToStorage.defaultExpectation == nil {
		mmAddReturnToStorage.defaultExpectation = &ReturnStorageInterfaceMockAddReturnToStorageExpectation{}
	}

	if mmAddReturnToStorage.defaultExpectation.params != nil {
		mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Expect")
	}

	if mmAddReturnToStorage.defaultExpectation.paramPtrs == nil {
		mmAddReturnToStorage.defaultExpectation.paramPtrs = &ReturnStorageInterfaceMockAddReturnToStorageParamPtrs{}
	}
	mmAddReturnToStorage.defaultExpectation.paramPtrs.r = &r
	mmAddReturnToStorage.defaultExpectation.expectationOrigins.originR = minimock.CallerInfo(1)

	return mmAddReturnToStorage
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.AddReturnToStorage
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Inspect(f func(r *models.Return)) *mReturnStorageInterfaceMockAddReturnToStorage {
	if mmAddReturnToStorage.mock.inspectFuncAddReturnToStorage != nil {
		mmAddReturnToStorage.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.AddReturnToStorage")
	}

	mmAddReturnToStorage.mock.inspectFuncAddReturnToStorage = f

	return mmAddReturnToStorage
}

// Return sets up results that will be returned by ReturnStorageInterface.AddReturnToStorage
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Return(err error) *ReturnStorageInterfaceMock {
	if mmAddReturnToStorage.mock.funcAddReturnToStorage != nil {
		mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Set")
	}

	if mmAddReturnToStorage.defaultExpectation == nil {
		mmAddReturnToStorage.defaultExpectation = &ReturnStorageInterfaceMockAddReturnToStorageExpectation{mock: mmAddReturnToStorage.mock}
	}
	mmAddReturnToStorage.defaultExpectation.results = &ReturnStorageInterfaceMockAddReturnToStorageResults{err}
	mmAddReturnToStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddReturnToStorage.mock
}

// Set uses given function f to mock the ReturnStorageInterface.AddReturnToStorage method
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Set(f func(r *models.Return) (err error)) *ReturnStorageInterfaceMock {
	if mmAddReturnToStorage.defaultExpectation != nil {
		mmAddReturnToStorage.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.AddReturnToStorage method")
	}

	if len(mmAddReturnToStorage.expectations) > 0 {
		mmAddReturnToStorage.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.AddReturnToStorage method")
	}

	mmAddReturnToStorage.mock.funcAddReturnToStorage = f
	mmAddReturnToStorage.mock.funcAddReturnToStorageOrigin = minimock.CallerInfo(1)
	return mmAddReturnToStorage.mock
}

// When sets expectation for the ReturnStorageInterface.AddReturnToStorage which will trigger the result defined by the following
// Then helper
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) When(r *models.Return) *ReturnStorageInterfaceMockAddReturnToStorageExpectation {
	if mmAddReturnToStorage.mock.funcAddReturnToStorage != nil {
		mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Set")
	}

	expectation := &ReturnStorageInterfaceMockAddReturnToStorageExpectation{
		mock:               mmAddReturnToStorage.mock,
		params:             &ReturnStorageInterfaceMockAddReturnToStorageParams{r},
		expectationOrigins: ReturnStorageInterfaceMockAddReturnToStorageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddReturnToStorage.expectations = append(mmAddReturnToStorage.expectations, expectation)
	return expectation
}

// Then sets up ReturnStorageInterface.AddReturnToStorage return parameters for the expectation previously defined by the When method
func (e *ReturnStorageInterfaceMockAddReturnToStorageExpectation) Then(err error) *ReturnStorageInterfaceMock {
	e.results = &ReturnStorageInterfaceMockAddReturnToStorageResults{err}
	return e.mock
}

// Times sets number of times ReturnStorageInterface.AddReturnToStorage should be invoked
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Times(n uint64) *mReturnStorageInterfaceMockAddReturnToStorage {
	if n == 0 {
		mmAddReturnToStorage.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.AddReturnToStorage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddReturnToStorage.expectedInvocations, n)
	mmAddReturnToStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddReturnToStorage
}

func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) invocationsDone() bool {
	if len(mmAddReturnToStorage.expectations) == 0 && mmAddReturnToStorage.defaultExpectation == nil && mmAddReturnToStorage.mock.funcAddReturnToStorage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddReturnToStorage.mock.afterAddReturnToStorageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddReturnToStorage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddReturnToStorage implements mm_storage.ReturnStorageInterface
func (mmAddReturnToStorage *ReturnStorageInterfaceMock) AddReturnToStorage(r *models.Return) (err error) {
	mm_atomic.AddUint64(&mmAddReturnToStorage.beforeAddReturnToStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmAddReturnToStorage.afterAddReturnToStorageCounter, 1)

	mmAddReturnToStorage.t.Helper()

	if mmAddReturnToStorage.inspectFuncAddReturnToStorage != nil {
		mmAddReturnToStorage.inspectFuncAddReturnToStorage(r)
	}

	mm_params := ReturnStorageInterfaceMockAddReturnToStorageParams{r}

	// Record call args
	mmAddReturnToStorage.AddReturnToStorageMock.mutex.Lock()
	mmAddReturnToStorage.AddReturnToStorageMock.callArgs = append(mmAddReturnToStorage.AddReturnToStorageMock.callArgs, &mm_params)
	mmAddReturnToStorage.AddReturnToStorageMock.mutex.Unlock()

	for _, e := range mmAddReturnToStorage.AddReturnToStorageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.Counter, 1)
		mm_want := mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.params
		mm_want_ptrs := mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.paramPtrs

		mm_got := ReturnStorageInterfaceMockAddReturnToStorageParams{r}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmAddReturnToStorage.t.Errorf("ReturnStorageInterfaceMock.AddReturnToStorage got unexpected parameter r, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.expectationOrigins.originR, *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddReturnToStorage.t.Errorf("ReturnStorageInterfaceMock.AddReturnToStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.results
		if mm_results == nil {
			mmAddReturnToStorage.t.Fatal("No results are set for the ReturnStorageInterfaceMock.AddReturnToStorage")
		}
		return (*mm_results).err
	}
	if mmAddReturnToStorage.funcAddReturnToStorage != nil {
		return mmAddReturnToStorage.funcAddReturnToStorage(r)
	}
	mmAddReturnToStorage.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.AddReturnToStorage. %v", r)
	return
}

// AddReturnToStorageAfterCounter returnStorage a count of finished ReturnStorageInterfaceMock.AddReturnToStorage invocations
func (mmAddReturnToStorage *ReturnStorageInterfaceMock) AddReturnToStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReturnToStorage.afterAddReturnToStorageCounter)
}

// AddReturnToStorageBeforeCounter returnStorage a count of ReturnStorageInterfaceMock.AddReturnToStorage invocations
func (mmAddReturnToStorage *ReturnStorageInterfaceMock) AddReturnToStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReturnToStorage.beforeAddReturnToStorageCounter)
}

// Calls returnStorage a list of arguments used in each call to ReturnStorageInterfaceMock.AddReturnToStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Calls() []*ReturnStorageInterfaceMockAddReturnToStorageParams {
	mmAddReturnToStorage.mutex.RLock()

	argCopy := make([]*ReturnStorageInterfaceMockAddReturnToStorageParams, len(mmAddReturnToStorage.callArgs))
	copy(argCopy, mmAddReturnToStorage.callArgs)

	mmAddReturnToStorage.mutex.RUnlock()

	return argCopy
}

// MinimockAddReturnToStorageDone returnStorage true if the count of the AddReturnToStorage invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockAddReturnToStorageDone() bool {
	if m.AddReturnToStorageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddReturnToStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddReturnToStorageMock.invocationsDone()
}

// MinimockAddReturnToStorageInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockAddReturnToStorageInspect() {
	for _, e := range m.AddReturnToStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddReturnToStorageCounter := mm_atomic.LoadUint64(&m.afterAddReturnToStorageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddReturnToStorageMock.defaultExpectation != nil && afterAddReturnToStorageCounter < 1 {
		if m.AddReturnToStorageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s", m.AddReturnToStorageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s with params: %#v", m.AddReturnToStorageMock.defaultExpectation.expectationOrigins.origin, *m.AddReturnToStorageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddReturnToStorage != nil && afterAddReturnToStorageCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s", m.funcAddReturnToStorageOrigin)
	}

	if !m.AddReturnToStorageMock.invocationsDone() && afterAddReturnToStorageCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddReturnToStorageMock.expectedInvocations), m.AddReturnToStorageMock.expectedInvocationsOrigin, afterAddReturnToStorageCounter)
	}
}

type mReturnStorageInterfaceMockDeleteReturnFromStorage struct {
	optional           bool
	mock               *ReturnStorageInterfaceMock
	defaultExpectation *ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation
	expectations       []*ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation

	callArgs []*ReturnStorageInterfaceMockDeleteReturnFromStorageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation specifies expectation struct of the ReturnStorageInterface.DeleteReturnFromStorage
type ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation struct {
	mock               *ReturnStorageInterfaceMock
	params             *ReturnStorageInterfaceMockDeleteReturnFromStorageParams
	paramPtrs          *ReturnStorageInterfaceMockDeleteReturnFromStorageParamPtrs
	expectationOrigins ReturnStorageInterfaceMockDeleteReturnFromStorageExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// ReturnStorageInterfaceMockDeleteReturnFromStorageParams contains parameters of the ReturnStorageInterface.DeleteReturnFromStorage
type ReturnStorageInterfaceMockDeleteReturnFromStorageParams struct {
	id uint
}

// ReturnStorageInterfaceMockDeleteReturnFromStorageParamPtrs contains pointers to parameters of the ReturnStorageInterface.DeleteReturnFromStorage
type ReturnStorageInterfaceMockDeleteReturnFromStorageParamPtrs struct {
	id *uint
}

// ReturnStorageInterfaceMockDeleteReturnFromStorageOrigins contains origins of expectations of the ReturnStorageInterface.DeleteReturnFromStorage
type ReturnStorageInterfaceMockDeleteReturnFromStorageExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Optional() *mReturnStorageInterfaceMockDeleteReturnFromStorage {
	mmDeleteReturnFromStorage.optional = true
	return mmDeleteReturnFromStorage
}

// Expect sets up expected params for ReturnStorageInterface.DeleteReturnFromStorage
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Expect(id uint) *mReturnStorageInterfaceMockDeleteReturnFromStorage {
	if mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage != nil {
		mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by Set")
	}

	if mmDeleteReturnFromStorage.defaultExpectation == nil {
		mmDeleteReturnFromStorage.defaultExpectation = &ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation{}
	}

	if mmDeleteReturnFromStorage.defaultExpectation.paramPtrs != nil {
		mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by ExpectParams functions")
	}

	mmDeleteReturnFromStorage.defaultExpectation.params = &ReturnStorageInterfaceMockDeleteReturnFromStorageParams{id}
	mmDeleteReturnFromStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteReturnFromStorage.expectations {
		if minimock.Equal(e.params, mmDeleteReturnFromStorage.defaultExpectation.params) {
			mmDeleteReturnFromStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteReturnFromStorage.defaultExpectation.params)
		}
	}

	return mmDeleteReturnFromStorage
}

// ExpectIdParam1 sets up expected param id for ReturnStorageInterface.DeleteReturnFromStorage
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) ExpectIdParam1(id uint) *mReturnStorageInterfaceMockDeleteReturnFromStorage {
	if mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage != nil {
		mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by Set")
	}

	if mmDeleteReturnFromStorage.defaultExpectation == nil {
		mmDeleteReturnFromStorage.defaultExpectation = &ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation{}
	}

	if mmDeleteReturnFromStorage.defaultExpectation.params != nil {
		mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by Expect")
	}

	if mmDeleteReturnFromStorage.defaultExpectation.paramPtrs == nil {
		mmDeleteReturnFromStorage.defaultExpectation.paramPtrs = &ReturnStorageInterfaceMockDeleteReturnFromStorageParamPtrs{}
	}
	mmDeleteReturnFromStorage.defaultExpectation.paramPtrs.id = &id
	mmDeleteReturnFromStorage.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteReturnFromStorage
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.DeleteReturnFromStorage
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Inspect(f func(id uint)) *mReturnStorageInterfaceMockDeleteReturnFromStorage {
	if mmDeleteReturnFromStorage.mock.inspectFuncDeleteReturnFromStorage != nil {
		mmDeleteReturnFromStorage.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.DeleteReturnFromStorage")
	}

	mmDeleteReturnFromStorage.mock.inspectFuncDeleteReturnFromStorage = f

	return mmDeleteReturnFromStorage
}

// Return sets up results that will be returned by ReturnStorageInterface.DeleteReturnFromStorage
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Return() *ReturnStorageInterfaceMock {
	if mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage != nil {
		mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by Set")
	}

	if mmDeleteReturnFromStorage.defaultExpectation == nil {
		mmDeleteReturnFromStorage.defaultExpectation = &ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation{mock: mmDeleteReturnFromStorage.mock}
	}

	mmDeleteReturnFromStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteReturnFromStorage.mock
}

// Set uses given function f to mock the ReturnStorageInterface.DeleteReturnFromStorage method
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Set(f func(id uint)) *ReturnStorageInterfaceMock {
	if mmDeleteReturnFromStorage.defaultExpectation != nil {
		mmDeleteReturnFromStorage.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.DeleteReturnFromStorage method")
	}

	if len(mmDeleteReturnFromStorage.expectations) > 0 {
		mmDeleteReturnFromStorage.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.DeleteReturnFromStorage method")
	}

	mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage = f
	mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorageOrigin = minimock.CallerInfo(1)
	return mmDeleteReturnFromStorage.mock
}

// Times sets number of times ReturnStorageInterface.DeleteReturnFromStorage should be invoked
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Times(n uint64) *mReturnStorageInterfaceMockDeleteReturnFromStorage {
	if n == 0 {
		mmDeleteReturnFromStorage.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.DeleteReturnFromStorage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteReturnFromStorage.expectedInvocations, n)
	mmDeleteReturnFromStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteReturnFromStorage
}

func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) invocationsDone() bool {
	if len(mmDeleteReturnFromStorage.expectations) == 0 && mmDeleteReturnFromStorage.defaultExpectation == nil && mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteReturnFromStorage.mock.afterDeleteReturnFromStorageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteReturnFromStorage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteReturnFromStorage implements mm_storage.ReturnStorageInterface
func (mmDeleteReturnFromStorage *ReturnStorageInterfaceMock) DeleteReturnFromStorage(id uint) {
	mm_atomic.AddUint64(&mmDeleteReturnFromStorage.beforeDeleteReturnFromStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteReturnFromStorage.afterDeleteReturnFromStorageCounter, 1)

	mmDeleteReturnFromStorage.t.Helper()

	if mmDeleteReturnFromStorage.inspectFuncDeleteReturnFromStorage != nil {
		mmDeleteReturnFromStorage.inspectFuncDeleteReturnFromStorage(id)
	}

	mm_params := ReturnStorageInterfaceMockDeleteReturnFromStorageParams{id}

	// Record call args
	mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.mutex.Lock()
	mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.callArgs = append(mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.callArgs, &mm_params)
	mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.mutex.Unlock()

	for _, e := range mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.paramPtrs

		mm_got := ReturnStorageInterfaceMockDeleteReturnFromStorageParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteReturnFromStorage.t.Errorf("ReturnStorageInterfaceMock.DeleteReturnFromStorage got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteReturnFromStorage.t.Errorf("ReturnStorageInterfaceMock.DeleteReturnFromStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteReturnFromStorage.funcDeleteReturnFromStorage != nil {
		mmDeleteReturnFromStorage.funcDeleteReturnFromStorage(id)
		return
	}
	mmDeleteReturnFromStorage.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage. %v", id)

}

// DeleteReturnFromStorageAfterCounter returnStorage a count of finished ReturnStorageInterfaceMock.DeleteReturnFromStorage invocations
func (mmDeleteReturnFromStorage *ReturnStorageInterfaceMock) DeleteReturnFromStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReturnFromStorage.afterDeleteReturnFromStorageCounter)
}

// DeleteReturnFromStorageBeforeCounter returnStorage a count of ReturnStorageInterfaceMock.DeleteReturnFromStorage invocations
func (mmDeleteReturnFromStorage *ReturnStorageInterfaceMock) DeleteReturnFromStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReturnFromStorage.beforeDeleteReturnFromStorageCounter)
}

// Calls returnStorage a list of arguments used in each call to ReturnStorageInterfaceMock.DeleteReturnFromStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Calls() []*ReturnStorageInterfaceMockDeleteReturnFromStorageParams {
	mmDeleteReturnFromStorage.mutex.RLock()

	argCopy := make([]*ReturnStorageInterfaceMockDeleteReturnFromStorageParams, len(mmDeleteReturnFromStorage.callArgs))
	copy(argCopy, mmDeleteReturnFromStorage.callArgs)

	mmDeleteReturnFromStorage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteReturnFromStorageDone returnStorage true if the count of the DeleteReturnFromStorage invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockDeleteReturnFromStorageDone() bool {
	if m.DeleteReturnFromStorageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteReturnFromStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteReturnFromStorageMock.invocationsDone()
}

// MinimockDeleteReturnFromStorageInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockDeleteReturnFromStorageInspect() {
	for _, e := range m.DeleteReturnFromStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteReturnFromStorageCounter := mm_atomic.LoadUint64(&m.afterDeleteReturnFromStorageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteReturnFromStorageMock.defaultExpectation != nil && afterDeleteReturnFromStorageCounter < 1 {
		if m.DeleteReturnFromStorageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s", m.DeleteReturnFromStorageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s with params: %#v", m.DeleteReturnFromStorageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteReturnFromStorageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteReturnFromStorage != nil && afterDeleteReturnFromStorageCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s", m.funcDeleteReturnFromStorageOrigin)
	}

	if !m.DeleteReturnFromStorageMock.invocationsDone() && afterDeleteReturnFromStorageCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteReturnFromStorageMock.expectedInvocations), m.DeleteReturnFromStorageMock.expectedInvocationsOrigin, afterDeleteReturnFromStorageCounter)
	}
}

type mReturnStorageInterfaceMockGetReturn struct {
	optional           bool
	mock               *ReturnStorageInterfaceMock
	defaultExpectation *ReturnStorageInterfaceMockGetReturnExpectation
	expectations       []*ReturnStorageInterfaceMockGetReturnExpectation

	callArgs []*ReturnStorageInterfaceMockGetReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockGetReturnExpectation specifies expectation struct of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnExpectation struct {
	mock               *ReturnStorageInterfaceMock
	params             *ReturnStorageInterfaceMockGetReturnParams
	paramPtrs          *ReturnStorageInterfaceMockGetReturnParamPtrs
	expectationOrigins ReturnStorageInterfaceMockGetReturnExpectationOrigins
	results            *ReturnStorageInterfaceMockGetReturnResults
	returnOrigin       string
	Counter            uint64
}

// ReturnStorageInterfaceMockGetReturnParams contains parameters of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnParams struct {
	id uint
}

// ReturnStorageInterfaceMockGetReturnParamPtrs contains pointers to parameters of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnParamPtrs struct {
	id *uint
}

// ReturnStorageInterfaceMockGetReturnResults contains results of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnResults struct {
	rp1 *models.Return
	b1  bool
}

// ReturnStorageInterfaceMockGetReturnOrigins contains origins of expectations of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Optional() *mReturnStorageInterfaceMockGetReturn {
	mmGetReturn.optional = true
	return mmGetReturn
}

// Expect sets up expected params for ReturnStorageInterface.GetReturn
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Expect(id uint) *mReturnStorageInterfaceMockGetReturn {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Set")
	}

	if mmGetReturn.defaultExpectation == nil {
		mmGetReturn.defaultExpectation = &ReturnStorageInterfaceMockGetReturnExpectation{}
	}

	if mmGetReturn.defaultExpectation.paramPtrs != nil {
		mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by ExpectParams functions")
	}

	mmGetReturn.defaultExpectation.params = &ReturnStorageInterfaceMockGetReturnParams{id}
	mmGetReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReturn.expectations {
		if minimock.Equal(e.params, mmGetReturn.defaultExpectation.params) {
			mmGetReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturn.defaultExpectation.params)
		}
	}

	return mmGetReturn
}

// ExpectIdParam1 sets up expected param id for ReturnStorageInterface.GetReturn
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) ExpectIdParam1(id uint) *mReturnStorageInterfaceMockGetReturn {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Set")
	}

	if mmGetReturn.defaultExpectation == nil {
		mmGetReturn.defaultExpectation = &ReturnStorageInterfaceMockGetReturnExpectation{}
	}

	if mmGetReturn.defaultExpectation.params != nil {
		mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Expect")
	}

	if mmGetReturn.defaultExpectation.paramPtrs == nil {
		mmGetReturn.defaultExpectation.paramPtrs = &ReturnStorageInterfaceMockGetReturnParamPtrs{}
	}
	mmGetReturn.defaultExpectation.paramPtrs.id = &id
	mmGetReturn.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetReturn
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.GetReturn
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Inspect(f func(id uint)) *mReturnStorageInterfaceMockGetReturn {
	if mmGetReturn.mock.inspectFuncGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.GetReturn")
	}

	mmGetReturn.mock.inspectFuncGetReturn = f

	return mmGetReturn
}

// Return sets up results that will be returned by ReturnStorageInterface.GetReturn
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Return(rp1 *models.Return, b1 bool) *ReturnStorageInterfaceMock {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Set")
	}

	if mmGetReturn.defaultExpectation == nil {
		mmGetReturn.defaultExpectation = &ReturnStorageInterfaceMockGetReturnExpectation{mock: mmGetReturn.mock}
	}
	mmGetReturn.defaultExpectation.results = &ReturnStorageInterfaceMockGetReturnResults{rp1, b1}
	mmGetReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturn.mock
}

// Set uses given function f to mock the ReturnStorageInterface.GetReturn method
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Set(f func(id uint) (rp1 *models.Return, b1 bool)) *ReturnStorageInterfaceMock {
	if mmGetReturn.defaultExpectation != nil {
		mmGetReturn.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.GetReturn method")
	}

	if len(mmGetReturn.expectations) > 0 {
		mmGetReturn.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.GetReturn method")
	}

	mmGetReturn.mock.funcGetReturn = f
	mmGetReturn.mock.funcGetReturnOrigin = minimock.CallerInfo(1)
	return mmGetReturn.mock
}

// When sets expectation for the ReturnStorageInterface.GetReturn which will trigger the result defined by the following
// Then helper
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) When(id uint) *ReturnStorageInterfaceMockGetReturnExpectation {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Set")
	}

	expectation := &ReturnStorageInterfaceMockGetReturnExpectation{
		mock:               mmGetReturn.mock,
		params:             &ReturnStorageInterfaceMockGetReturnParams{id},
		expectationOrigins: ReturnStorageInterfaceMockGetReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReturn.expectations = append(mmGetReturn.expectations, expectation)
	return expectation
}

// Then sets up ReturnStorageInterface.GetReturn return parameters for the expectation previously defined by the When method
func (e *ReturnStorageInterfaceMockGetReturnExpectation) Then(rp1 *models.Return, b1 bool) *ReturnStorageInterfaceMock {
	e.results = &ReturnStorageInterfaceMockGetReturnResults{rp1, b1}
	return e.mock
}

// Times sets number of times ReturnStorageInterface.GetReturn should be invoked
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Times(n uint64) *mReturnStorageInterfaceMockGetReturn {
	if n == 0 {
		mmGetReturn.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.GetReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturn.expectedInvocations, n)
	mmGetReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturn
}

func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) invocationsDone() bool {
	if len(mmGetReturn.expectations) == 0 && mmGetReturn.defaultExpectation == nil && mmGetReturn.mock.funcGetReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturn.mock.afterGetReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturn implements mm_storage.ReturnStorageInterface
func (mmGetReturn *ReturnStorageInterfaceMock) GetReturn(id uint) (rp1 *models.Return, b1 bool) {
	mm_atomic.AddUint64(&mmGetReturn.beforeGetReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturn.afterGetReturnCounter, 1)

	mmGetReturn.t.Helper()

	if mmGetReturn.inspectFuncGetReturn != nil {
		mmGetReturn.inspectFuncGetReturn(id)
	}

	mm_params := ReturnStorageInterfaceMockGetReturnParams{id}

	// Record call args
	mmGetReturn.GetReturnMock.mutex.Lock()
	mmGetReturn.GetReturnMock.callArgs = append(mmGetReturn.GetReturnMock.callArgs, &mm_params)
	mmGetReturn.GetReturnMock.mutex.Unlock()

	for _, e := range mmGetReturn.GetReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.b1
		}
	}

	if mmGetReturn.GetReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturn.GetReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReturn.GetReturnMock.defaultExpectation.params
		mm_want_ptrs := mmGetReturn.GetReturnMock.defaultExpectation.paramPtrs

		mm_got := ReturnStorageInterfaceMockGetReturnParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetReturn.t.Errorf("ReturnStorageInterfaceMock.GetReturn got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturn.GetReturnMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReturn.t.Errorf("ReturnStorageInterfaceMock.GetReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReturn.GetReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReturn.GetReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturn.t.Fatal("No results are set for the ReturnStorageInterfaceMock.GetReturn")
		}
		return (*mm_results).rp1, (*mm_results).b1
	}
	if mmGetReturn.funcGetReturn != nil {
		return mmGetReturn.funcGetReturn(id)
	}
	mmGetReturn.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.GetReturn. %v", id)
	return
}

// GetReturnAfterCounter returnStorage a count of finished ReturnStorageInterfaceMock.GetReturn invocations
func (mmGetReturn *ReturnStorageInterfaceMock) GetReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturn.afterGetReturnCounter)
}

// GetReturnBeforeCounter returnStorage a count of ReturnStorageInterfaceMock.GetReturn invocations
func (mmGetReturn *ReturnStorageInterfaceMock) GetReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturn.beforeGetReturnCounter)
}

// Calls returnStorage a list of arguments used in each call to ReturnStorageInterfaceMock.GetReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Calls() []*ReturnStorageInterfaceMockGetReturnParams {
	mmGetReturn.mutex.RLock()

	argCopy := make([]*ReturnStorageInterfaceMockGetReturnParams, len(mmGetReturn.callArgs))
	copy(argCopy, mmGetReturn.callArgs)

	mmGetReturn.mutex.RUnlock()

	return argCopy
}

// MinimockGetReturnDone returnStorage true if the count of the GetReturn invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockGetReturnDone() bool {
	if m.GetReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnMock.invocationsDone()
}

// MinimockGetReturnInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockGetReturnInspect() {
	for _, e := range m.GetReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReturnCounter := mm_atomic.LoadUint64(&m.afterGetReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnMock.defaultExpectation != nil && afterGetReturnCounter < 1 {
		if m.GetReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturn at\n%s", m.GetReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturn at\n%s with params: %#v", m.GetReturnMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturn != nil && afterGetReturnCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturn at\n%s", m.funcGetReturnOrigin)
	}

	if !m.GetReturnMock.invocationsDone() && afterGetReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.GetReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnMock.expectedInvocations), m.GetReturnMock.expectedInvocationsOrigin, afterGetReturnCounter)
	}
}

type mReturnStorageInterfaceMockGetReturnIDs struct {
	optional           bool
	mock               *ReturnStorageInterfaceMock
	defaultExpectation *ReturnStorageInterfaceMockGetReturnIDsExpectation
	expectations       []*ReturnStorageInterfaceMockGetReturnIDsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockGetReturnIDsExpectation specifies expectation struct of the ReturnStorageInterface.GetReturnIDs
type ReturnStorageInterfaceMockGetReturnIDsExpectation struct {
	mock *ReturnStorageInterfaceMock

	results      *ReturnStorageInterfaceMockGetReturnIDsResults
	returnOrigin string
	Counter      uint64
}

// ReturnStorageInterfaceMockGetReturnIDsResults contains results of the ReturnStorageInterface.GetReturnIDs
type ReturnStorageInterfaceMockGetReturnIDsResults struct {
	ua1 []uint
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Optional() *mReturnStorageInterfaceMockGetReturnIDs {
	mmGetReturnIDs.optional = true
	return mmGetReturnIDs
}

// Expect sets up expected params for ReturnStorageInterface.GetReturnIDs
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Expect() *mReturnStorageInterfaceMockGetReturnIDs {
	if mmGetReturnIDs.mock.funcGetReturnIDs != nil {
		mmGetReturnIDs.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturnIDs mock is already set by Set")
	}

	if mmGetReturnIDs.defaultExpectation == nil {
		mmGetReturnIDs.defaultExpectation = &ReturnStorageInterfaceMockGetReturnIDsExpectation{}
	}

	return mmGetReturnIDs
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.GetReturnIDs
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Inspect(f func()) *mReturnStorageInterfaceMockGetReturnIDs {
	if mmGetReturnIDs.mock.inspectFuncGetReturnIDs != nil {
		mmGetReturnIDs.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.GetReturnIDs")
	}

	mmGetReturnIDs.mock.inspectFuncGetReturnIDs = f

	return mmGetReturnIDs
}

// Return sets up results that will be returned by ReturnStorageInterface.GetReturnIDs
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Return(ua1 []uint) *ReturnStorageInterfaceMock {
	if mmGetReturnIDs.mock.funcGetReturnIDs != nil {
		mmGetReturnIDs.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturnIDs mock is already set by Set")
	}

	if mmGetReturnIDs.defaultExpectation == nil {
		mmGetReturnIDs.defaultExpectation = &ReturnStorageInterfaceMockGetReturnIDsExpectation{mock: mmGetReturnIDs.mock}
	}
	mmGetReturnIDs.defaultExpectation.results = &ReturnStorageInterfaceMockGetReturnIDsResults{ua1}
	mmGetReturnIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturnIDs.mock
}

// Set uses given function f to mock the ReturnStorageInterface.GetReturnIDs method
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Set(f func() (ua1 []uint)) *ReturnStorageInterfaceMock {
	if mmGetReturnIDs.defaultExpectation != nil {
		mmGetReturnIDs.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.GetReturnIDs method")
	}

	if len(mmGetReturnIDs.expectations) > 0 {
		mmGetReturnIDs.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.GetReturnIDs method")
	}

	mmGetReturnIDs.mock.funcGetReturnIDs = f
	mmGetReturnIDs.mock.funcGetReturnIDsOrigin = minimock.CallerInfo(1)
	return mmGetReturnIDs.mock
}

// Times sets number of times ReturnStorageInterface.GetReturnIDs should be invoked
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Times(n uint64) *mReturnStorageInterfaceMockGetReturnIDs {
	if n == 0 {
		mmGetReturnIDs.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.GetReturnIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturnIDs.expectedInvocations, n)
	mmGetReturnIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturnIDs
}

func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) invocationsDone() bool {
	if len(mmGetReturnIDs.expectations) == 0 && mmGetReturnIDs.defaultExpectation == nil && mmGetReturnIDs.mock.funcGetReturnIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturnIDs.mock.afterGetReturnIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturnIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturnIDs implements mm_storage.ReturnStorageInterface
func (mmGetReturnIDs *ReturnStorageInterfaceMock) GetReturnIDs() (ua1 []uint) {
	mm_atomic.AddUint64(&mmGetReturnIDs.beforeGetReturnIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturnIDs.afterGetReturnIDsCounter, 1)

	mmGetReturnIDs.t.Helper()

	if mmGetReturnIDs.inspectFuncGetReturnIDs != nil {
		mmGetReturnIDs.inspectFuncGetReturnIDs()
	}

	if mmGetReturnIDs.GetReturnIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturnIDs.GetReturnIDsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetReturnIDs.GetReturnIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturnIDs.t.Fatal("No results are set for the ReturnStorageInterfaceMock.GetReturnIDs")
		}
		return (*mm_results).ua1
	}
	if mmGetReturnIDs.funcGetReturnIDs != nil {
		return mmGetReturnIDs.funcGetReturnIDs()
	}
	mmGetReturnIDs.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.GetReturnIDs.")
	return
}

// GetReturnIDsAfterCounter returnStorage a count of finished ReturnStorageInterfaceMock.GetReturnIDs invocations
func (mmGetReturnIDs *ReturnStorageInterfaceMock) GetReturnIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturnIDs.afterGetReturnIDsCounter)
}

// GetReturnIDsBeforeCounter returnStorage a count of ReturnStorageInterfaceMock.GetReturnIDs invocations
func (mmGetReturnIDs *ReturnStorageInterfaceMock) GetReturnIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturnIDs.beforeGetReturnIDsCounter)
}

// MinimockGetReturnIDsDone returnStorage true if the count of the GetReturnIDs invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockGetReturnIDsDone() bool {
	if m.GetReturnIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnIDsMock.invocationsDone()
}

// MinimockGetReturnIDsInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockGetReturnIDsInspect() {
	for _, e := range m.GetReturnIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ReturnStorageInterfaceMock.GetReturnIDs")
		}
	}

	afterGetReturnIDsCounter := mm_atomic.LoadUint64(&m.afterGetReturnIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnIDsMock.defaultExpectation != nil && afterGetReturnIDsCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturnIDs at\n%s", m.GetReturnIDsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturnIDs != nil && afterGetReturnIDsCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturnIDs at\n%s", m.funcGetReturnIDsOrigin)
	}

	if !m.GetReturnIDsMock.invocationsDone() && afterGetReturnIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.GetReturnIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnIDsMock.expectedInvocations), m.GetReturnIDsMock.expectedInvocationsOrigin, afterGetReturnIDsCounter)
	}
}

type mReturnStorageInterfaceMockIsConsist struct {
	optional           bool
	mock               *ReturnStorageInterfaceMock
	defaultExpectation *ReturnStorageInterfaceMockIsConsistExpectation
	expectations       []*ReturnStorageInterfaceMockIsConsistExpectation

	callArgs []*ReturnStorageInterfaceMockIsConsistParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockIsConsistExpectation specifies expectation struct of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistExpectation struct {
	mock               *ReturnStorageInterfaceMock
	params             *ReturnStorageInterfaceMockIsConsistParams
	paramPtrs          *ReturnStorageInterfaceMockIsConsistParamPtrs
	expectationOrigins ReturnStorageInterfaceMockIsConsistExpectationOrigins
	results            *ReturnStorageInterfaceMockIsConsistResults
	returnOrigin       string
	Counter            uint64
}

// ReturnStorageInterfaceMockIsConsistParams contains parameters of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistParams struct {
	id uint
}

// ReturnStorageInterfaceMockIsConsistParamPtrs contains pointers to parameters of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistParamPtrs struct {
	id *uint
}

// ReturnStorageInterfaceMockIsConsistResults contains results of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistResults struct {
	b1 bool
}

// ReturnStorageInterfaceMockIsConsistOrigins contains origins of expectations of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Optional() *mReturnStorageInterfaceMockIsConsist {
	mmIsConsist.optional = true
	return mmIsConsist
}

// Expect sets up expected params for ReturnStorageInterface.IsConsist
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Expect(id uint) *mReturnStorageInterfaceMockIsConsist {
	if mmIsConsist.mock.funcIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Set")
	}

	if mmIsConsist.defaultExpectation == nil {
		mmIsConsist.defaultExpectation = &ReturnStorageInterfaceMockIsConsistExpectation{}
	}

	if mmIsConsist.defaultExpectation.paramPtrs != nil {
		mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by ExpectParams functions")
	}

	mmIsConsist.defaultExpectation.params = &ReturnStorageInterfaceMockIsConsistParams{id}
	mmIsConsist.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsConsist.expectations {
		if minimock.Equal(e.params, mmIsConsist.defaultExpectation.params) {
			mmIsConsist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsConsist.defaultExpectation.params)
		}
	}

	return mmIsConsist
}

// ExpectIdParam1 sets up expected param id for ReturnStorageInterface.IsConsist
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) ExpectIdParam1(id uint) *mReturnStorageInterfaceMockIsConsist {
	if mmIsConsist.mock.funcIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Set")
	}

	if mmIsConsist.defaultExpectation == nil {
		mmIsConsist.defaultExpectation = &ReturnStorageInterfaceMockIsConsistExpectation{}
	}

	if mmIsConsist.defaultExpectation.params != nil {
		mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Expect")
	}

	if mmIsConsist.defaultExpectation.paramPtrs == nil {
		mmIsConsist.defaultExpectation.paramPtrs = &ReturnStorageInterfaceMockIsConsistParamPtrs{}
	}
	mmIsConsist.defaultExpectation.paramPtrs.id = &id
	mmIsConsist.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmIsConsist
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.IsConsist
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Inspect(f func(id uint)) *mReturnStorageInterfaceMockIsConsist {
	if mmIsConsist.mock.inspectFuncIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.IsConsist")
	}

	mmIsConsist.mock.inspectFuncIsConsist = f

	return mmIsConsist
}

// Return sets up results that will be returned by ReturnStorageInterface.IsConsist
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Return(b1 bool) *ReturnStorageInterfaceMock {
	if mmIsConsist.mock.funcIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Set")
	}

	if mmIsConsist.defaultExpectation == nil {
		mmIsConsist.defaultExpectation = &ReturnStorageInterfaceMockIsConsistExpectation{mock: mmIsConsist.mock}
	}
	mmIsConsist.defaultExpectation.results = &ReturnStorageInterfaceMockIsConsistResults{b1}
	mmIsConsist.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsConsist.mock
}

// Set uses given function f to mock the ReturnStorageInterface.IsConsist method
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Set(f func(id uint) (b1 bool)) *ReturnStorageInterfaceMock {
	if mmIsConsist.defaultExpectation != nil {
		mmIsConsist.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.IsConsist method")
	}

	if len(mmIsConsist.expectations) > 0 {
		mmIsConsist.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.IsConsist method")
	}

	mmIsConsist.mock.funcIsConsist = f
	mmIsConsist.mock.funcIsConsistOrigin = minimock.CallerInfo(1)
	return mmIsConsist.mock
}

// When sets expectation for the ReturnStorageInterface.IsConsist which will trigger the result defined by the following
// Then helper
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) When(id uint) *ReturnStorageInterfaceMockIsConsistExpectation {
	if mmIsConsist.mock.funcIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Set")
	}

	expectation := &ReturnStorageInterfaceMockIsConsistExpectation{
		mock:               mmIsConsist.mock,
		params:             &ReturnStorageInterfaceMockIsConsistParams{id},
		expectationOrigins: ReturnStorageInterfaceMockIsConsistExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsConsist.expectations = append(mmIsConsist.expectations, expectation)
	return expectation
}

// Then sets up ReturnStorageInterface.IsConsist return parameters for the expectation previously defined by the When method
func (e *ReturnStorageInterfaceMockIsConsistExpectation) Then(b1 bool) *ReturnStorageInterfaceMock {
	e.results = &ReturnStorageInterfaceMockIsConsistResults{b1}
	return e.mock
}

// Times sets number of times ReturnStorageInterface.IsConsist should be invoked
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Times(n uint64) *mReturnStorageInterfaceMockIsConsist {
	if n == 0 {
		mmIsConsist.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.IsConsist mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsConsist.expectedInvocations, n)
	mmIsConsist.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsConsist
}

func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) invocationsDone() bool {
	if len(mmIsConsist.expectations) == 0 && mmIsConsist.defaultExpectation == nil && mmIsConsist.mock.funcIsConsist == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsConsist.mock.afterIsConsistCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsConsist.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsConsist implements mm_storage.ReturnStorageInterface
func (mmIsConsist *ReturnStorageInterfaceMock) IsConsist(id uint) (b1 bool) {
	mm_atomic.AddUint64(&mmIsConsist.beforeIsConsistCounter, 1)
	defer mm_atomic.AddUint64(&mmIsConsist.afterIsConsistCounter, 1)

	mmIsConsist.t.Helper()

	if mmIsConsist.inspectFuncIsConsist != nil {
		mmIsConsist.inspectFuncIsConsist(id)
	}

	mm_params := ReturnStorageInterfaceMockIsConsistParams{id}

	// Record call args
	mmIsConsist.IsConsistMock.mutex.Lock()
	mmIsConsist.IsConsistMock.callArgs = append(mmIsConsist.IsConsistMock.callArgs, &mm_params)
	mmIsConsist.IsConsistMock.mutex.Unlock()

	for _, e := range mmIsConsist.IsConsistMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsConsist.IsConsistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsConsist.IsConsistMock.defaultExpectation.Counter, 1)
		mm_want := mmIsConsist.IsConsistMock.defaultExpectation.params
		mm_want_ptrs := mmIsConsist.IsConsistMock.defaultExpectation.paramPtrs

		mm_got := ReturnStorageInterfaceMockIsConsistParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmIsConsist.t.Errorf("ReturnStorageInterfaceMock.IsConsist got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsConsist.IsConsistMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsConsist.t.Errorf("ReturnStorageInterfaceMock.IsConsist got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsConsist.IsConsistMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsConsist.IsConsistMock.defaultExpectation.results
		if mm_results == nil {
			mmIsConsist.t.Fatal("No results are set for the ReturnStorageInterfaceMock.IsConsist")
		}
		return (*mm_results).b1
	}
	if mmIsConsist.funcIsConsist != nil {
		return mmIsConsist.funcIsConsist(id)
	}
	mmIsConsist.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.IsConsist. %v", id)
	return
}

// IsConsistAfterCounter returnStorage a count of finished ReturnStorageInterfaceMock.IsConsist invocations
func (mmIsConsist *ReturnStorageInterfaceMock) IsConsistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsConsist.afterIsConsistCounter)
}

// IsConsistBeforeCounter returnStorage a count of ReturnStorageInterfaceMock.IsConsist invocations
func (mmIsConsist *ReturnStorageInterfaceMock) IsConsistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsConsist.beforeIsConsistCounter)
}

// Calls returnStorage a list of arguments used in each call to ReturnStorageInterfaceMock.IsConsist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Calls() []*ReturnStorageInterfaceMockIsConsistParams {
	mmIsConsist.mutex.RLock()

	argCopy := make([]*ReturnStorageInterfaceMockIsConsistParams, len(mmIsConsist.callArgs))
	copy(argCopy, mmIsConsist.callArgs)

	mmIsConsist.mutex.RUnlock()

	return argCopy
}

// MinimockIsConsistDone returnStorage true if the count of the IsConsist invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockIsConsistDone() bool {
	if m.IsConsistMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsConsistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsConsistMock.invocationsDone()
}

// MinimockIsConsistInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockIsConsistInspect() {
	for _, e := range m.IsConsistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.IsConsist at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsConsistCounter := mm_atomic.LoadUint64(&m.afterIsConsistCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsConsistMock.defaultExpectation != nil && afterIsConsistCounter < 1 {
		if m.IsConsistMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.IsConsist at\n%s", m.IsConsistMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReturnStorageInterfaceMock.IsConsist at\n%s with params: %#v", m.IsConsistMock.defaultExpectation.expectationOrigins.origin, *m.IsConsistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsConsist != nil && afterIsConsistCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.IsConsist at\n%s", m.funcIsConsistOrigin)
	}

	if !m.IsConsistMock.invocationsDone() && afterIsConsistCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.IsConsist at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsConsistMock.expectedInvocations), m.IsConsistMock.expectedInvocationsOrigin, afterIsConsistCounter)
	}
}

type mReturnStorageInterfaceMockReadFromJSON struct {
	optional           bool
	mock               *ReturnStorageInterfaceMock
	defaultExpectation *ReturnStorageInterfaceMockReadFromJSONExpectation
	expectations       []*ReturnStorageInterfaceMockReadFromJSONExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockReadFromJSONExpectation specifies expectation struct of the ReturnStorageInterface.ReadFromJSON
type ReturnStorageInterfaceMockReadFromJSONExpectation struct {
	mock *ReturnStorageInterfaceMock

	results      *ReturnStorageInterfaceMockReadFromJSONResults
	returnOrigin string
	Counter      uint64
}

// ReturnStorageInterfaceMockReadFromJSONResults contains results of the ReturnStorageInterface.ReadFromJSON
type ReturnStorageInterfaceMockReadFromJSONResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Optional() *mReturnStorageInterfaceMockReadFromJSON {
	mmReadFromJSON.optional = true
	return mmReadFromJSON
}

// Expect sets up expected params for ReturnStorageInterface.ReadFromJSON
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Expect() *mReturnStorageInterfaceMockReadFromJSON {
	if mmReadFromJSON.mock.funcReadFromJSON != nil {
		mmReadFromJSON.mock.t.Fatalf("ReturnStorageInterfaceMock.ReadFromJSON mock is already set by Set")
	}

	if mmReadFromJSON.defaultExpectation == nil {
		mmReadFromJSON.defaultExpectation = &ReturnStorageInterfaceMockReadFromJSONExpectation{}
	}

	return mmReadFromJSON
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.ReadFromJSON
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Inspect(f func()) *mReturnStorageInterfaceMockReadFromJSON {
	if mmReadFromJSON.mock.inspectFuncReadFromJSON != nil {
		mmReadFromJSON.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.ReadFromJSON")
	}

	mmReadFromJSON.mock.inspectFuncReadFromJSON = f

	return mmReadFromJSON
}

// Return sets up results that will be returned by ReturnStorageInterface.ReadFromJSON
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Return(err error) *ReturnStorageInterfaceMock {
	if mmReadFromJSON.mock.funcReadFromJSON != nil {
		mmReadFromJSON.mock.t.Fatalf("ReturnStorageInterfaceMock.ReadFromJSON mock is already set by Set")
	}

	if mmReadFromJSON.defaultExpectation == nil {
		mmReadFromJSON.defaultExpectation = &ReturnStorageInterfaceMockReadFromJSONExpectation{mock: mmReadFromJSON.mock}
	}
	mmReadFromJSON.defaultExpectation.results = &ReturnStorageInterfaceMockReadFromJSONResults{err}
	mmReadFromJSON.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadFromJSON.mock
}

// Set uses given function f to mock the ReturnStorageInterface.ReadFromJSON method
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Set(f func() (err error)) *ReturnStorageInterfaceMock {
	if mmReadFromJSON.defaultExpectation != nil {
		mmReadFromJSON.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.ReadFromJSON method")
	}

	if len(mmReadFromJSON.expectations) > 0 {
		mmReadFromJSON.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.ReadFromJSON method")
	}

	mmReadFromJSON.mock.funcReadFromJSON = f
	mmReadFromJSON.mock.funcReadFromJSONOrigin = minimock.CallerInfo(1)
	return mmReadFromJSON.mock
}

// Times sets number of times ReturnStorageInterface.ReadFromJSON should be invoked
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Times(n uint64) *mReturnStorageInterfaceMockReadFromJSON {
	if n == 0 {
		mmReadFromJSON.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.ReadFromJSON mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadFromJSON.expectedInvocations, n)
	mmReadFromJSON.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadFromJSON
}

func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) invocationsDone() bool {
	if len(mmReadFromJSON.expectations) == 0 && mmReadFromJSON.defaultExpectation == nil && mmReadFromJSON.mock.funcReadFromJSON == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadFromJSON.mock.afterReadFromJSONCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadFromJSON.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadFromJSON implements mm_storage.ReturnStorageInterface
func (mmReadFromJSON *ReturnStorageInterfaceMock) ReadFromJSON() (err error) {
	mm_atomic.AddUint64(&mmReadFromJSON.beforeReadFromJSONCounter, 1)
	defer mm_atomic.AddUint64(&mmReadFromJSON.afterReadFromJSONCounter, 1)

	mmReadFromJSON.t.Helper()

	if mmReadFromJSON.inspectFuncReadFromJSON != nil {
		mmReadFromJSON.inspectFuncReadFromJSON()
	}

	if mmReadFromJSON.ReadFromJSONMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadFromJSON.ReadFromJSONMock.defaultExpectation.Counter, 1)

		mm_results := mmReadFromJSON.ReadFromJSONMock.defaultExpectation.results
		if mm_results == nil {
			mmReadFromJSON.t.Fatal("No results are set for the ReturnStorageInterfaceMock.ReadFromJSON")
		}
		return (*mm_results).err
	}
	if mmReadFromJSON.funcReadFromJSON != nil {
		return mmReadFromJSON.funcReadFromJSON()
	}
	mmReadFromJSON.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.ReadFromJSON.")
	return
}

// ReadFromJSONAfterCounter returnStorage a count of finished ReturnStorageInterfaceMock.ReadFromJSON invocations
func (mmReadFromJSON *ReturnStorageInterfaceMock) ReadFromJSONAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFromJSON.afterReadFromJSONCounter)
}

// ReadFromJSONBeforeCounter returnStorage a count of ReturnStorageInterfaceMock.ReadFromJSON invocations
func (mmReadFromJSON *ReturnStorageInterfaceMock) ReadFromJSONBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFromJSON.beforeReadFromJSONCounter)
}

// MinimockReadFromJSONDone returnStorage true if the count of the ReadFromJSON invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockReadFromJSONDone() bool {
	if m.ReadFromJSONMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadFromJSONMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadFromJSONMock.invocationsDone()
}

// MinimockReadFromJSONInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockReadFromJSONInspect() {
	for _, e := range m.ReadFromJSONMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ReturnStorageInterfaceMock.ReadFromJSON")
		}
	}

	afterReadFromJSONCounter := mm_atomic.LoadUint64(&m.afterReadFromJSONCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadFromJSONMock.defaultExpectation != nil && afterReadFromJSONCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.ReadFromJSON at\n%s", m.ReadFromJSONMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadFromJSON != nil && afterReadFromJSONCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.ReadFromJSON at\n%s", m.funcReadFromJSONOrigin)
	}

	if !m.ReadFromJSONMock.invocationsDone() && afterReadFromJSONCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.ReadFromJSON at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadFromJSONMock.expectedInvocations), m.ReadFromJSONMock.expectedInvocationsOrigin, afterReadFromJSONCounter)
	}
}

type mReturnStorageInterfaceMockWriteToJSON struct {
	optional           bool
	mock               *ReturnStorageInterfaceMock
	defaultExpectation *ReturnStorageInterfaceMockWriteToJSONExpectation
	expectations       []*ReturnStorageInterfaceMockWriteToJSONExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockWriteToJSONExpectation specifies expectation struct of the ReturnStorageInterface.WriteToJSON
type ReturnStorageInterfaceMockWriteToJSONExpectation struct {
	mock *ReturnStorageInterfaceMock

	results      *ReturnStorageInterfaceMockWriteToJSONResults
	returnOrigin string
	Counter      uint64
}

// ReturnStorageInterfaceMockWriteToJSONResults contains results of the ReturnStorageInterface.WriteToJSON
type ReturnStorageInterfaceMockWriteToJSONResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Optional() *mReturnStorageInterfaceMockWriteToJSON {
	mmWriteToJSON.optional = true
	return mmWriteToJSON
}

// Expect sets up expected params for ReturnStorageInterface.WriteToJSON
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Expect() *mReturnStorageInterfaceMockWriteToJSON {
	if mmWriteToJSON.mock.funcWriteToJSON != nil {
		mmWriteToJSON.mock.t.Fatalf("ReturnStorageInterfaceMock.WriteToJSON mock is already set by Set")
	}

	if mmWriteToJSON.defaultExpectation == nil {
		mmWriteToJSON.defaultExpectation = &ReturnStorageInterfaceMockWriteToJSONExpectation{}
	}

	return mmWriteToJSON
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.WriteToJSON
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Inspect(f func()) *mReturnStorageInterfaceMockWriteToJSON {
	if mmWriteToJSON.mock.inspectFuncWriteToJSON != nil {
		mmWriteToJSON.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.WriteToJSON")
	}

	mmWriteToJSON.mock.inspectFuncWriteToJSON = f

	return mmWriteToJSON
}

// Return sets up results that will be returned by ReturnStorageInterface.WriteToJSON
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Return(err error) *ReturnStorageInterfaceMock {
	if mmWriteToJSON.mock.funcWriteToJSON != nil {
		mmWriteToJSON.mock.t.Fatalf("ReturnStorageInterfaceMock.WriteToJSON mock is already set by Set")
	}

	if mmWriteToJSON.defaultExpectation == nil {
		mmWriteToJSON.defaultExpectation = &ReturnStorageInterfaceMockWriteToJSONExpectation{mock: mmWriteToJSON.mock}
	}
	mmWriteToJSON.defaultExpectation.results = &ReturnStorageInterfaceMockWriteToJSONResults{err}
	mmWriteToJSON.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWriteToJSON.mock
}

// Set uses given function f to mock the ReturnStorageInterface.WriteToJSON method
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Set(f func() (err error)) *ReturnStorageInterfaceMock {
	if mmWriteToJSON.defaultExpectation != nil {
		mmWriteToJSON.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.WriteToJSON method")
	}

	if len(mmWriteToJSON.expectations) > 0 {
		mmWriteToJSON.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.WriteToJSON method")
	}

	mmWriteToJSON.mock.funcWriteToJSON = f
	mmWriteToJSON.mock.funcWriteToJSONOrigin = minimock.CallerInfo(1)
	return mmWriteToJSON.mock
}

// Times sets number of times ReturnStorageInterface.WriteToJSON should be invoked
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Times(n uint64) *mReturnStorageInterfaceMockWriteToJSON {
	if n == 0 {
		mmWriteToJSON.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.WriteToJSON mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWriteToJSON.expectedInvocations, n)
	mmWriteToJSON.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWriteToJSON
}

func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) invocationsDone() bool {
	if len(mmWriteToJSON.expectations) == 0 && mmWriteToJSON.defaultExpectation == nil && mmWriteToJSON.mock.funcWriteToJSON == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWriteToJSON.mock.afterWriteToJSONCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWriteToJSON.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WriteToJSON implements mm_storage.ReturnStorageInterface
func (mmWriteToJSON *ReturnStorageInterfaceMock) WriteToJSON() (err error) {
	mm_atomic.AddUint64(&mmWriteToJSON.beforeWriteToJSONCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteToJSON.afterWriteToJSONCounter, 1)

	mmWriteToJSON.t.Helper()

	if mmWriteToJSON.inspectFuncWriteToJSON != nil {
		mmWriteToJSON.inspectFuncWriteToJSON()
	}

	if mmWriteToJSON.WriteToJSONMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteToJSON.WriteToJSONMock.defaultExpectation.Counter, 1)

		mm_results := mmWriteToJSON.WriteToJSONMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteToJSON.t.Fatal("No results are set for the ReturnStorageInterfaceMock.WriteToJSON")
		}
		return (*mm_results).err
	}
	if mmWriteToJSON.funcWriteToJSON != nil {
		return mmWriteToJSON.funcWriteToJSON()
	}
	mmWriteToJSON.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.WriteToJSON.")
	return
}

// WriteToJSONAfterCounter returnStorage a count of finished ReturnStorageInterfaceMock.WriteToJSON invocations
func (mmWriteToJSON *ReturnStorageInterfaceMock) WriteToJSONAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteToJSON.afterWriteToJSONCounter)
}

// WriteToJSONBeforeCounter returnStorage a count of ReturnStorageInterfaceMock.WriteToJSON invocations
func (mmWriteToJSON *ReturnStorageInterfaceMock) WriteToJSONBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteToJSON.beforeWriteToJSONCounter)
}

// MinimockWriteToJSONDone returnStorage true if the count of the WriteToJSON invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockWriteToJSONDone() bool {
	if m.WriteToJSONMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteToJSONMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteToJSONMock.invocationsDone()
}

// MinimockWriteToJSONInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockWriteToJSONInspect() {
	for _, e := range m.WriteToJSONMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ReturnStorageInterfaceMock.WriteToJSON")
		}
	}

	afterWriteToJSONCounter := mm_atomic.LoadUint64(&m.afterWriteToJSONCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToJSONMock.defaultExpectation != nil && afterWriteToJSONCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.WriteToJSON at\n%s", m.WriteToJSONMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteToJSON != nil && afterWriteToJSONCounter < 1 {
		m.t.Errorf("Expected call to ReturnStorageInterfaceMock.WriteToJSON at\n%s", m.funcWriteToJSONOrigin)
	}

	if !m.WriteToJSONMock.invocationsDone() && afterWriteToJSONCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.WriteToJSON at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WriteToJSONMock.expectedInvocations), m.WriteToJSONMock.expectedInvocationsOrigin, afterWriteToJSONCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReturnStorageInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddReturnToStorageInspect()

			m.MinimockDeleteReturnFromStorageInspect()

			m.MinimockGetReturnInspect()

			m.MinimockGetReturnIDsInspect()

			m.MinimockIsConsistInspect()

			m.MinimockReadFromJSONInspect()

			m.MinimockWriteToJSONInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReturnStorageInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReturnStorageInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddReturnToStorageDone() &&
		m.MinimockDeleteReturnFromStorageDone() &&
		m.MinimockGetReturnDone() &&
		m.MinimockGetReturnIDsDone() &&
		m.MinimockIsConsistDone() &&
		m.MinimockReadFromJSONDone() &&
		m.MinimockWriteToJSONDone()
}
