// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i gitlab.ozon.dev/akugnerevich/homework.git/internal/storage.OrderStorageInterface -o order_storage_interface_mock_test.go -n OrderStorageInterfaceMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
)

// OrderStorageInterfaceMock implements mm_storage.OrderStorageInterface
type OrderStorageInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrderToStorage          func(or *models.Order)
	funcAddOrderToStorageOrigin    string
	inspectFuncAddOrderToStorage   func(or *models.Order)
	afterAddOrderToStorageCounter  uint64
	beforeAddOrderToStorageCounter uint64
	AddOrderToStorageMock          mOrderStorageInterfaceMockAddOrderToStorage

	funcDeleteOrderFromStorage          func(id uint)
	funcDeleteOrderFromStorageOrigin    string
	inspectFuncDeleteOrderFromStorage   func(id uint)
	afterDeleteOrderFromStorageCounter  uint64
	beforeDeleteOrderFromStorageCounter uint64
	DeleteOrderFromStorageMock          mOrderStorageInterfaceMockDeleteOrderFromStorage

	funcGetOrder          func(id uint) (op1 *models.Order, b1 bool)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(id uint)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mOrderStorageInterfaceMockGetOrder

	funcGetOrderIDs          func() (ua1 []uint)
	funcGetOrderIDsOrigin    string
	inspectFuncGetOrderIDs   func()
	afterGetOrderIDsCounter  uint64
	beforeGetOrderIDsCounter uint64
	GetOrderIDsMock          mOrderStorageInterfaceMockGetOrderIDs

	funcIsConsist          func(id uint) (b1 bool)
	funcIsConsistOrigin    string
	inspectFuncIsConsist   func(id uint)
	afterIsConsistCounter  uint64
	beforeIsConsistCounter uint64
	IsConsistMock          mOrderStorageInterfaceMockIsConsist

	funcReadFromJSON          func() (err error)
	funcReadFromJSONOrigin    string
	inspectFuncReadFromJSON   func()
	afterReadFromJSONCounter  uint64
	beforeReadFromJSONCounter uint64
	ReadFromJSONMock          mOrderStorageInterfaceMockReadFromJSON

	funcWriteToJSON          func() (err error)
	funcWriteToJSONOrigin    string
	inspectFuncWriteToJSON   func()
	afterWriteToJSONCounter  uint64
	beforeWriteToJSONCounter uint64
	WriteToJSONMock          mOrderStorageInterfaceMockWriteToJSON
}

// NewOrderStorageInterfaceMock returns a mock for mm_storage.OrderStorageInterface
func NewOrderStorageInterfaceMock(t minimock.Tester) *OrderStorageInterfaceMock {
	m := &OrderStorageInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderToStorageMock = mOrderStorageInterfaceMockAddOrderToStorage{mock: m}
	m.AddOrderToStorageMock.callArgs = []*OrderStorageInterfaceMockAddOrderToStorageParams{}

	m.DeleteOrderFromStorageMock = mOrderStorageInterfaceMockDeleteOrderFromStorage{mock: m}
	m.DeleteOrderFromStorageMock.callArgs = []*OrderStorageInterfaceMockDeleteOrderFromStorageParams{}

	m.GetOrderMock = mOrderStorageInterfaceMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*OrderStorageInterfaceMockGetOrderParams{}

	m.GetOrderIDsMock = mOrderStorageInterfaceMockGetOrderIDs{mock: m}

	m.IsConsistMock = mOrderStorageInterfaceMockIsConsist{mock: m}
	m.IsConsistMock.callArgs = []*OrderStorageInterfaceMockIsConsistParams{}

	m.ReadFromJSONMock = mOrderStorageInterfaceMockReadFromJSON{mock: m}

	m.WriteToJSONMock = mOrderStorageInterfaceMockWriteToJSON{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderStorageInterfaceMockAddOrderToStorage struct {
	optional           bool
	mock               *OrderStorageInterfaceMock
	defaultExpectation *OrderStorageInterfaceMockAddOrderToStorageExpectation
	expectations       []*OrderStorageInterfaceMockAddOrderToStorageExpectation

	callArgs []*OrderStorageInterfaceMockAddOrderToStorageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockAddOrderToStorageExpectation specifies expectation struct of the OrderStorageInterface.AddOrderToStorage
type OrderStorageInterfaceMockAddOrderToStorageExpectation struct {
	mock               *OrderStorageInterfaceMock
	params             *OrderStorageInterfaceMockAddOrderToStorageParams
	paramPtrs          *OrderStorageInterfaceMockAddOrderToStorageParamPtrs
	expectationOrigins OrderStorageInterfaceMockAddOrderToStorageExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// OrderStorageInterfaceMockAddOrderToStorageParams contains parameters of the OrderStorageInterface.AddOrderToStorage
type OrderStorageInterfaceMockAddOrderToStorageParams struct {
	or *models.Order
}

// OrderStorageInterfaceMockAddOrderToStorageParamPtrs contains pointers to parameters of the OrderStorageInterface.AddOrderToStorage
type OrderStorageInterfaceMockAddOrderToStorageParamPtrs struct {
	or **models.Order
}

// OrderStorageInterfaceMockAddOrderToStorageOrigins contains origins of expectations of the OrderStorageInterface.AddOrderToStorage
type OrderStorageInterfaceMockAddOrderToStorageExpectationOrigins struct {
	origin   string
	originOr string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Optional() *mOrderStorageInterfaceMockAddOrderToStorage {
	mmAddOrderToStorage.optional = true
	return mmAddOrderToStorage
}

// Expect sets up expected params for OrderStorageInterface.AddOrderToStorage
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Expect(or *models.Order) *mOrderStorageInterfaceMockAddOrderToStorage {
	if mmAddOrderToStorage.mock.funcAddOrderToStorage != nil {
		mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by Set")
	}

	if mmAddOrderToStorage.defaultExpectation == nil {
		mmAddOrderToStorage.defaultExpectation = &OrderStorageInterfaceMockAddOrderToStorageExpectation{}
	}

	if mmAddOrderToStorage.defaultExpectation.paramPtrs != nil {
		mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by ExpectParams functions")
	}

	mmAddOrderToStorage.defaultExpectation.params = &OrderStorageInterfaceMockAddOrderToStorageParams{or}
	mmAddOrderToStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrderToStorage.expectations {
		if minimock.Equal(e.params, mmAddOrderToStorage.defaultExpectation.params) {
			mmAddOrderToStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrderToStorage.defaultExpectation.params)
		}
	}

	return mmAddOrderToStorage
}

// ExpectOrParam1 sets up expected param or for OrderStorageInterface.AddOrderToStorage
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) ExpectOrParam1(or *models.Order) *mOrderStorageInterfaceMockAddOrderToStorage {
	if mmAddOrderToStorage.mock.funcAddOrderToStorage != nil {
		mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by Set")
	}

	if mmAddOrderToStorage.defaultExpectation == nil {
		mmAddOrderToStorage.defaultExpectation = &OrderStorageInterfaceMockAddOrderToStorageExpectation{}
	}

	if mmAddOrderToStorage.defaultExpectation.params != nil {
		mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by Expect")
	}

	if mmAddOrderToStorage.defaultExpectation.paramPtrs == nil {
		mmAddOrderToStorage.defaultExpectation.paramPtrs = &OrderStorageInterfaceMockAddOrderToStorageParamPtrs{}
	}
	mmAddOrderToStorage.defaultExpectation.paramPtrs.or = &or
	mmAddOrderToStorage.defaultExpectation.expectationOrigins.originOr = minimock.CallerInfo(1)

	return mmAddOrderToStorage
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.AddOrderToStorage
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Inspect(f func(or *models.Order)) *mOrderStorageInterfaceMockAddOrderToStorage {
	if mmAddOrderToStorage.mock.inspectFuncAddOrderToStorage != nil {
		mmAddOrderToStorage.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.AddOrderToStorage")
	}

	mmAddOrderToStorage.mock.inspectFuncAddOrderToStorage = f

	return mmAddOrderToStorage
}

// Return sets up results that will be returned by OrderStorageInterface.AddOrderToStorage
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Return() *OrderStorageInterfaceMock {
	if mmAddOrderToStorage.mock.funcAddOrderToStorage != nil {
		mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by Set")
	}

	if mmAddOrderToStorage.defaultExpectation == nil {
		mmAddOrderToStorage.defaultExpectation = &OrderStorageInterfaceMockAddOrderToStorageExpectation{mock: mmAddOrderToStorage.mock}
	}

	mmAddOrderToStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrderToStorage.mock
}

// Set uses given function f to mock the OrderStorageInterface.AddOrderToStorage method
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Set(f func(or *models.Order)) *OrderStorageInterfaceMock {
	if mmAddOrderToStorage.defaultExpectation != nil {
		mmAddOrderToStorage.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.AddOrderToStorage method")
	}

	if len(mmAddOrderToStorage.expectations) > 0 {
		mmAddOrderToStorage.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.AddOrderToStorage method")
	}

	mmAddOrderToStorage.mock.funcAddOrderToStorage = f
	mmAddOrderToStorage.mock.funcAddOrderToStorageOrigin = minimock.CallerInfo(1)
	return mmAddOrderToStorage.mock
}

// Times sets number of times OrderStorageInterface.AddOrderToStorage should be invoked
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Times(n uint64) *mOrderStorageInterfaceMockAddOrderToStorage {
	if n == 0 {
		mmAddOrderToStorage.mock.t.Fatalf("Times of OrderStorageInterfaceMock.AddOrderToStorage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrderToStorage.expectedInvocations, n)
	mmAddOrderToStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrderToStorage
}

func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) invocationsDone() bool {
	if len(mmAddOrderToStorage.expectations) == 0 && mmAddOrderToStorage.defaultExpectation == nil && mmAddOrderToStorage.mock.funcAddOrderToStorage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrderToStorage.mock.afterAddOrderToStorageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrderToStorage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrderToStorage implements mm_storage.OrderStorageInterface
func (mmAddOrderToStorage *OrderStorageInterfaceMock) AddOrderToStorage(or *models.Order) {
	mm_atomic.AddUint64(&mmAddOrderToStorage.beforeAddOrderToStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrderToStorage.afterAddOrderToStorageCounter, 1)

	mmAddOrderToStorage.t.Helper()

	if mmAddOrderToStorage.inspectFuncAddOrderToStorage != nil {
		mmAddOrderToStorage.inspectFuncAddOrderToStorage(or)
	}

	mm_params := OrderStorageInterfaceMockAddOrderToStorageParams{or}

	// Record call args
	mmAddOrderToStorage.AddOrderToStorageMock.mutex.Lock()
	mmAddOrderToStorage.AddOrderToStorageMock.callArgs = append(mmAddOrderToStorage.AddOrderToStorageMock.callArgs, &mm_params)
	mmAddOrderToStorage.AddOrderToStorageMock.mutex.Unlock()

	for _, e := range mmAddOrderToStorage.AddOrderToStorageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.paramPtrs

		mm_got := OrderStorageInterfaceMockAddOrderToStorageParams{or}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.or != nil && !minimock.Equal(*mm_want_ptrs.or, mm_got.or) {
				mmAddOrderToStorage.t.Errorf("OrderStorageInterfaceMock.AddOrderToStorage got unexpected parameter or, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.expectationOrigins.originOr, *mm_want_ptrs.or, mm_got.or, minimock.Diff(*mm_want_ptrs.or, mm_got.or))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrderToStorage.t.Errorf("OrderStorageInterfaceMock.AddOrderToStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddOrderToStorage.funcAddOrderToStorage != nil {
		mmAddOrderToStorage.funcAddOrderToStorage(or)
		return
	}
	mmAddOrderToStorage.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.AddOrderToStorage. %v", or)

}

// AddOrderToStorageAfterCounter returns a count of finished OrderStorageInterfaceMock.AddOrderToStorage invocations
func (mmAddOrderToStorage *OrderStorageInterfaceMock) AddOrderToStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrderToStorage.afterAddOrderToStorageCounter)
}

// AddOrderToStorageBeforeCounter returns a count of OrderStorageInterfaceMock.AddOrderToStorage invocations
func (mmAddOrderToStorage *OrderStorageInterfaceMock) AddOrderToStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrderToStorage.beforeAddOrderToStorageCounter)
}

// Calls returns a list of arguments used in each call to OrderStorageInterfaceMock.AddOrderToStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Calls() []*OrderStorageInterfaceMockAddOrderToStorageParams {
	mmAddOrderToStorage.mutex.RLock()

	argCopy := make([]*OrderStorageInterfaceMockAddOrderToStorageParams, len(mmAddOrderToStorage.callArgs))
	copy(argCopy, mmAddOrderToStorage.callArgs)

	mmAddOrderToStorage.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderToStorageDone returns true if the count of the AddOrderToStorage invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockAddOrderToStorageDone() bool {
	if m.AddOrderToStorageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderToStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderToStorageMock.invocationsDone()
}

// MinimockAddOrderToStorageInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockAddOrderToStorageInspect() {
	for _, e := range m.AddOrderToStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.AddOrderToStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderToStorageCounter := mm_atomic.LoadUint64(&m.afterAddOrderToStorageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderToStorageMock.defaultExpectation != nil && afterAddOrderToStorageCounter < 1 {
		if m.AddOrderToStorageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.AddOrderToStorage at\n%s", m.AddOrderToStorageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.AddOrderToStorage at\n%s with params: %#v", m.AddOrderToStorageMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderToStorageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrderToStorage != nil && afterAddOrderToStorageCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.AddOrderToStorage at\n%s", m.funcAddOrderToStorageOrigin)
	}

	if !m.AddOrderToStorageMock.invocationsDone() && afterAddOrderToStorageCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.AddOrderToStorage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderToStorageMock.expectedInvocations), m.AddOrderToStorageMock.expectedInvocationsOrigin, afterAddOrderToStorageCounter)
	}
}

type mOrderStorageInterfaceMockDeleteOrderFromStorage struct {
	optional           bool
	mock               *OrderStorageInterfaceMock
	defaultExpectation *OrderStorageInterfaceMockDeleteOrderFromStorageExpectation
	expectations       []*OrderStorageInterfaceMockDeleteOrderFromStorageExpectation

	callArgs []*OrderStorageInterfaceMockDeleteOrderFromStorageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockDeleteOrderFromStorageExpectation specifies expectation struct of the OrderStorageInterface.DeleteOrderFromStorage
type OrderStorageInterfaceMockDeleteOrderFromStorageExpectation struct {
	mock               *OrderStorageInterfaceMock
	params             *OrderStorageInterfaceMockDeleteOrderFromStorageParams
	paramPtrs          *OrderStorageInterfaceMockDeleteOrderFromStorageParamPtrs
	expectationOrigins OrderStorageInterfaceMockDeleteOrderFromStorageExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// OrderStorageInterfaceMockDeleteOrderFromStorageParams contains parameters of the OrderStorageInterface.DeleteOrderFromStorage
type OrderStorageInterfaceMockDeleteOrderFromStorageParams struct {
	id uint
}

// OrderStorageInterfaceMockDeleteOrderFromStorageParamPtrs contains pointers to parameters of the OrderStorageInterface.DeleteOrderFromStorage
type OrderStorageInterfaceMockDeleteOrderFromStorageParamPtrs struct {
	id *uint
}

// OrderStorageInterfaceMockDeleteOrderFromStorageOrigins contains origins of expectations of the OrderStorageInterface.DeleteOrderFromStorage
type OrderStorageInterfaceMockDeleteOrderFromStorageExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Optional() *mOrderStorageInterfaceMockDeleteOrderFromStorage {
	mmDeleteOrderFromStorage.optional = true
	return mmDeleteOrderFromStorage
}

// Expect sets up expected params for OrderStorageInterface.DeleteOrderFromStorage
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Expect(id uint) *mOrderStorageInterfaceMockDeleteOrderFromStorage {
	if mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage != nil {
		mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by Set")
	}

	if mmDeleteOrderFromStorage.defaultExpectation == nil {
		mmDeleteOrderFromStorage.defaultExpectation = &OrderStorageInterfaceMockDeleteOrderFromStorageExpectation{}
	}

	if mmDeleteOrderFromStorage.defaultExpectation.paramPtrs != nil {
		mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by ExpectParams functions")
	}

	mmDeleteOrderFromStorage.defaultExpectation.params = &OrderStorageInterfaceMockDeleteOrderFromStorageParams{id}
	mmDeleteOrderFromStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrderFromStorage.expectations {
		if minimock.Equal(e.params, mmDeleteOrderFromStorage.defaultExpectation.params) {
			mmDeleteOrderFromStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrderFromStorage.defaultExpectation.params)
		}
	}

	return mmDeleteOrderFromStorage
}

// ExpectIdParam1 sets up expected param id for OrderStorageInterface.DeleteOrderFromStorage
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) ExpectIdParam1(id uint) *mOrderStorageInterfaceMockDeleteOrderFromStorage {
	if mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage != nil {
		mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by Set")
	}

	if mmDeleteOrderFromStorage.defaultExpectation == nil {
		mmDeleteOrderFromStorage.defaultExpectation = &OrderStorageInterfaceMockDeleteOrderFromStorageExpectation{}
	}

	if mmDeleteOrderFromStorage.defaultExpectation.params != nil {
		mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by Expect")
	}

	if mmDeleteOrderFromStorage.defaultExpectation.paramPtrs == nil {
		mmDeleteOrderFromStorage.defaultExpectation.paramPtrs = &OrderStorageInterfaceMockDeleteOrderFromStorageParamPtrs{}
	}
	mmDeleteOrderFromStorage.defaultExpectation.paramPtrs.id = &id
	mmDeleteOrderFromStorage.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteOrderFromStorage
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.DeleteOrderFromStorage
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Inspect(f func(id uint)) *mOrderStorageInterfaceMockDeleteOrderFromStorage {
	if mmDeleteOrderFromStorage.mock.inspectFuncDeleteOrderFromStorage != nil {
		mmDeleteOrderFromStorage.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.DeleteOrderFromStorage")
	}

	mmDeleteOrderFromStorage.mock.inspectFuncDeleteOrderFromStorage = f

	return mmDeleteOrderFromStorage
}

// Return sets up results that will be returned by OrderStorageInterface.DeleteOrderFromStorage
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Return() *OrderStorageInterfaceMock {
	if mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage != nil {
		mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by Set")
	}

	if mmDeleteOrderFromStorage.defaultExpectation == nil {
		mmDeleteOrderFromStorage.defaultExpectation = &OrderStorageInterfaceMockDeleteOrderFromStorageExpectation{mock: mmDeleteOrderFromStorage.mock}
	}

	mmDeleteOrderFromStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrderFromStorage.mock
}

// Set uses given function f to mock the OrderStorageInterface.DeleteOrderFromStorage method
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Set(f func(id uint)) *OrderStorageInterfaceMock {
	if mmDeleteOrderFromStorage.defaultExpectation != nil {
		mmDeleteOrderFromStorage.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.DeleteOrderFromStorage method")
	}

	if len(mmDeleteOrderFromStorage.expectations) > 0 {
		mmDeleteOrderFromStorage.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.DeleteOrderFromStorage method")
	}

	mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage = f
	mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorageOrigin = minimock.CallerInfo(1)
	return mmDeleteOrderFromStorage.mock
}

// Times sets number of times OrderStorageInterface.DeleteOrderFromStorage should be invoked
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Times(n uint64) *mOrderStorageInterfaceMockDeleteOrderFromStorage {
	if n == 0 {
		mmDeleteOrderFromStorage.mock.t.Fatalf("Times of OrderStorageInterfaceMock.DeleteOrderFromStorage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrderFromStorage.expectedInvocations, n)
	mmDeleteOrderFromStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrderFromStorage
}

func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) invocationsDone() bool {
	if len(mmDeleteOrderFromStorage.expectations) == 0 && mmDeleteOrderFromStorage.defaultExpectation == nil && mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrderFromStorage.mock.afterDeleteOrderFromStorageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrderFromStorage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrderFromStorage implements mm_storage.OrderStorageInterface
func (mmDeleteOrderFromStorage *OrderStorageInterfaceMock) DeleteOrderFromStorage(id uint) {
	mm_atomic.AddUint64(&mmDeleteOrderFromStorage.beforeDeleteOrderFromStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrderFromStorage.afterDeleteOrderFromStorageCounter, 1)

	mmDeleteOrderFromStorage.t.Helper()

	if mmDeleteOrderFromStorage.inspectFuncDeleteOrderFromStorage != nil {
		mmDeleteOrderFromStorage.inspectFuncDeleteOrderFromStorage(id)
	}

	mm_params := OrderStorageInterfaceMockDeleteOrderFromStorageParams{id}

	// Record call args
	mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.mutex.Lock()
	mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.callArgs = append(mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.callArgs, &mm_params)
	mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.mutex.Unlock()

	for _, e := range mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.paramPtrs

		mm_got := OrderStorageInterfaceMockDeleteOrderFromStorageParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteOrderFromStorage.t.Errorf("OrderStorageInterfaceMock.DeleteOrderFromStorage got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrderFromStorage.t.Errorf("OrderStorageInterfaceMock.DeleteOrderFromStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteOrderFromStorage.funcDeleteOrderFromStorage != nil {
		mmDeleteOrderFromStorage.funcDeleteOrderFromStorage(id)
		return
	}
	mmDeleteOrderFromStorage.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.DeleteOrderFromStorage. %v", id)

}

// DeleteOrderFromStorageAfterCounter returns a count of finished OrderStorageInterfaceMock.DeleteOrderFromStorage invocations
func (mmDeleteOrderFromStorage *OrderStorageInterfaceMock) DeleteOrderFromStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrderFromStorage.afterDeleteOrderFromStorageCounter)
}

// DeleteOrderFromStorageBeforeCounter returns a count of OrderStorageInterfaceMock.DeleteOrderFromStorage invocations
func (mmDeleteOrderFromStorage *OrderStorageInterfaceMock) DeleteOrderFromStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrderFromStorage.beforeDeleteOrderFromStorageCounter)
}

// Calls returns a list of arguments used in each call to OrderStorageInterfaceMock.DeleteOrderFromStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Calls() []*OrderStorageInterfaceMockDeleteOrderFromStorageParams {
	mmDeleteOrderFromStorage.mutex.RLock()

	argCopy := make([]*OrderStorageInterfaceMockDeleteOrderFromStorageParams, len(mmDeleteOrderFromStorage.callArgs))
	copy(argCopy, mmDeleteOrderFromStorage.callArgs)

	mmDeleteOrderFromStorage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderFromStorageDone returns true if the count of the DeleteOrderFromStorage invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockDeleteOrderFromStorageDone() bool {
	if m.DeleteOrderFromStorageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrderFromStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrderFromStorageMock.invocationsDone()
}

// MinimockDeleteOrderFromStorageInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockDeleteOrderFromStorageInspect() {
	for _, e := range m.DeleteOrderFromStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrderFromStorageCounter := mm_atomic.LoadUint64(&m.afterDeleteOrderFromStorageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderFromStorageMock.defaultExpectation != nil && afterDeleteOrderFromStorageCounter < 1 {
		if m.DeleteOrderFromStorageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s", m.DeleteOrderFromStorageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s with params: %#v", m.DeleteOrderFromStorageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrderFromStorageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrderFromStorage != nil && afterDeleteOrderFromStorageCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s", m.funcDeleteOrderFromStorageOrigin)
	}

	if !m.DeleteOrderFromStorageMock.invocationsDone() && afterDeleteOrderFromStorageCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrderFromStorageMock.expectedInvocations), m.DeleteOrderFromStorageMock.expectedInvocationsOrigin, afterDeleteOrderFromStorageCounter)
	}
}

type mOrderStorageInterfaceMockGetOrder struct {
	optional           bool
	mock               *OrderStorageInterfaceMock
	defaultExpectation *OrderStorageInterfaceMockGetOrderExpectation
	expectations       []*OrderStorageInterfaceMockGetOrderExpectation

	callArgs []*OrderStorageInterfaceMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockGetOrderExpectation specifies expectation struct of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderExpectation struct {
	mock               *OrderStorageInterfaceMock
	params             *OrderStorageInterfaceMockGetOrderParams
	paramPtrs          *OrderStorageInterfaceMockGetOrderParamPtrs
	expectationOrigins OrderStorageInterfaceMockGetOrderExpectationOrigins
	results            *OrderStorageInterfaceMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderStorageInterfaceMockGetOrderParams contains parameters of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderParams struct {
	id uint
}

// OrderStorageInterfaceMockGetOrderParamPtrs contains pointers to parameters of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderParamPtrs struct {
	id *uint
}

// OrderStorageInterfaceMockGetOrderResults contains results of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderResults struct {
	op1 *models.Order
	b1  bool
}

// OrderStorageInterfaceMockGetOrderOrigins contains origins of expectations of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Optional() *mOrderStorageInterfaceMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for OrderStorageInterface.GetOrder
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Expect(id uint) *mOrderStorageInterfaceMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderStorageInterfaceMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &OrderStorageInterfaceMockGetOrderParams{id}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectIdParam1 sets up expected param id for OrderStorageInterface.GetOrder
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) ExpectIdParam1(id uint) *mOrderStorageInterfaceMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderStorageInterfaceMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &OrderStorageInterfaceMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.id = &id
	mmGetOrder.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.GetOrder
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Inspect(f func(id uint)) *mOrderStorageInterfaceMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by OrderStorageInterface.GetOrder
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Return(op1 *models.Order, b1 bool) *OrderStorageInterfaceMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderStorageInterfaceMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &OrderStorageInterfaceMockGetOrderResults{op1, b1}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the OrderStorageInterface.GetOrder method
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Set(f func(id uint) (op1 *models.Order, b1 bool)) *OrderStorageInterfaceMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the OrderStorageInterface.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) When(id uint) *OrderStorageInterfaceMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Set")
	}

	expectation := &OrderStorageInterfaceMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &OrderStorageInterfaceMockGetOrderParams{id},
		expectationOrigins: OrderStorageInterfaceMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderStorageInterface.GetOrder return parameters for the expectation previously defined by the When method
func (e *OrderStorageInterfaceMockGetOrderExpectation) Then(op1 *models.Order, b1 bool) *OrderStorageInterfaceMock {
	e.results = &OrderStorageInterfaceMockGetOrderResults{op1, b1}
	return e.mock
}

// Times sets number of times OrderStorageInterface.GetOrder should be invoked
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Times(n uint64) *mOrderStorageInterfaceMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of OrderStorageInterfaceMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_storage.OrderStorageInterface
func (mmGetOrder *OrderStorageInterfaceMock) GetOrder(id uint) (op1 *models.Order, b1 bool) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(id)
	}

	mm_params := OrderStorageInterfaceMockGetOrderParams{id}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.b1
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderStorageInterfaceMockGetOrderParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetOrder.t.Errorf("OrderStorageInterfaceMock.GetOrder got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("OrderStorageInterfaceMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the OrderStorageInterfaceMock.GetOrder")
		}
		return (*mm_results).op1, (*mm_results).b1
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(id)
	}
	mmGetOrder.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.GetOrder. %v", id)
	return
}

// GetOrderAfterCounter returns a count of finished OrderStorageInterfaceMock.GetOrder invocations
func (mmGetOrder *OrderStorageInterfaceMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of OrderStorageInterfaceMock.GetOrder invocations
func (mmGetOrder *OrderStorageInterfaceMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderStorageInterfaceMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Calls() []*OrderStorageInterfaceMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*OrderStorageInterfaceMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mOrderStorageInterfaceMockGetOrderIDs struct {
	optional           bool
	mock               *OrderStorageInterfaceMock
	defaultExpectation *OrderStorageInterfaceMockGetOrderIDsExpectation
	expectations       []*OrderStorageInterfaceMockGetOrderIDsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockGetOrderIDsExpectation specifies expectation struct of the OrderStorageInterface.GetOrderIDs
type OrderStorageInterfaceMockGetOrderIDsExpectation struct {
	mock *OrderStorageInterfaceMock

	results      *OrderStorageInterfaceMockGetOrderIDsResults
	returnOrigin string
	Counter      uint64
}

// OrderStorageInterfaceMockGetOrderIDsResults contains results of the OrderStorageInterface.GetOrderIDs
type OrderStorageInterfaceMockGetOrderIDsResults struct {
	ua1 []uint
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Optional() *mOrderStorageInterfaceMockGetOrderIDs {
	mmGetOrderIDs.optional = true
	return mmGetOrderIDs
}

// Expect sets up expected params for OrderStorageInterface.GetOrderIDs
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Expect() *mOrderStorageInterfaceMockGetOrderIDs {
	if mmGetOrderIDs.mock.funcGetOrderIDs != nil {
		mmGetOrderIDs.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrderIDs mock is already set by Set")
	}

	if mmGetOrderIDs.defaultExpectation == nil {
		mmGetOrderIDs.defaultExpectation = &OrderStorageInterfaceMockGetOrderIDsExpectation{}
	}

	return mmGetOrderIDs
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.GetOrderIDs
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Inspect(f func()) *mOrderStorageInterfaceMockGetOrderIDs {
	if mmGetOrderIDs.mock.inspectFuncGetOrderIDs != nil {
		mmGetOrderIDs.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.GetOrderIDs")
	}

	mmGetOrderIDs.mock.inspectFuncGetOrderIDs = f

	return mmGetOrderIDs
}

// Return sets up results that will be returned by OrderStorageInterface.GetOrderIDs
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Return(ua1 []uint) *OrderStorageInterfaceMock {
	if mmGetOrderIDs.mock.funcGetOrderIDs != nil {
		mmGetOrderIDs.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrderIDs mock is already set by Set")
	}

	if mmGetOrderIDs.defaultExpectation == nil {
		mmGetOrderIDs.defaultExpectation = &OrderStorageInterfaceMockGetOrderIDsExpectation{mock: mmGetOrderIDs.mock}
	}
	mmGetOrderIDs.defaultExpectation.results = &OrderStorageInterfaceMockGetOrderIDsResults{ua1}
	mmGetOrderIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrderIDs.mock
}

// Set uses given function f to mock the OrderStorageInterface.GetOrderIDs method
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Set(f func() (ua1 []uint)) *OrderStorageInterfaceMock {
	if mmGetOrderIDs.defaultExpectation != nil {
		mmGetOrderIDs.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.GetOrderIDs method")
	}

	if len(mmGetOrderIDs.expectations) > 0 {
		mmGetOrderIDs.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.GetOrderIDs method")
	}

	mmGetOrderIDs.mock.funcGetOrderIDs = f
	mmGetOrderIDs.mock.funcGetOrderIDsOrigin = minimock.CallerInfo(1)
	return mmGetOrderIDs.mock
}

// Times sets number of times OrderStorageInterface.GetOrderIDs should be invoked
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Times(n uint64) *mOrderStorageInterfaceMockGetOrderIDs {
	if n == 0 {
		mmGetOrderIDs.mock.t.Fatalf("Times of OrderStorageInterfaceMock.GetOrderIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderIDs.expectedInvocations, n)
	mmGetOrderIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrderIDs
}

func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) invocationsDone() bool {
	if len(mmGetOrderIDs.expectations) == 0 && mmGetOrderIDs.defaultExpectation == nil && mmGetOrderIDs.mock.funcGetOrderIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderIDs.mock.afterGetOrderIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderIDs implements mm_storage.OrderStorageInterface
func (mmGetOrderIDs *OrderStorageInterfaceMock) GetOrderIDs() (ua1 []uint) {
	mm_atomic.AddUint64(&mmGetOrderIDs.beforeGetOrderIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderIDs.afterGetOrderIDsCounter, 1)

	mmGetOrderIDs.t.Helper()

	if mmGetOrderIDs.inspectFuncGetOrderIDs != nil {
		mmGetOrderIDs.inspectFuncGetOrderIDs()
	}

	if mmGetOrderIDs.GetOrderIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderIDs.GetOrderIDsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetOrderIDs.GetOrderIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderIDs.t.Fatal("No results are set for the OrderStorageInterfaceMock.GetOrderIDs")
		}
		return (*mm_results).ua1
	}
	if mmGetOrderIDs.funcGetOrderIDs != nil {
		return mmGetOrderIDs.funcGetOrderIDs()
	}
	mmGetOrderIDs.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.GetOrderIDs.")
	return
}

// GetOrderIDsAfterCounter returns a count of finished OrderStorageInterfaceMock.GetOrderIDs invocations
func (mmGetOrderIDs *OrderStorageInterfaceMock) GetOrderIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderIDs.afterGetOrderIDsCounter)
}

// GetOrderIDsBeforeCounter returns a count of OrderStorageInterfaceMock.GetOrderIDs invocations
func (mmGetOrderIDs *OrderStorageInterfaceMock) GetOrderIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderIDs.beforeGetOrderIDsCounter)
}

// MinimockGetOrderIDsDone returns true if the count of the GetOrderIDs invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockGetOrderIDsDone() bool {
	if m.GetOrderIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderIDsMock.invocationsDone()
}

// MinimockGetOrderIDsInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockGetOrderIDsInspect() {
	for _, e := range m.GetOrderIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to OrderStorageInterfaceMock.GetOrderIDs")
		}
	}

	afterGetOrderIDsCounter := mm_atomic.LoadUint64(&m.afterGetOrderIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderIDsMock.defaultExpectation != nil && afterGetOrderIDsCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrderIDs at\n%s", m.GetOrderIDsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderIDs != nil && afterGetOrderIDsCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrderIDs at\n%s", m.funcGetOrderIDsOrigin)
	}

	if !m.GetOrderIDsMock.invocationsDone() && afterGetOrderIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.GetOrderIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderIDsMock.expectedInvocations), m.GetOrderIDsMock.expectedInvocationsOrigin, afterGetOrderIDsCounter)
	}
}

type mOrderStorageInterfaceMockIsConsist struct {
	optional           bool
	mock               *OrderStorageInterfaceMock
	defaultExpectation *OrderStorageInterfaceMockIsConsistExpectation
	expectations       []*OrderStorageInterfaceMockIsConsistExpectation

	callArgs []*OrderStorageInterfaceMockIsConsistParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockIsConsistExpectation specifies expectation struct of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistExpectation struct {
	mock               *OrderStorageInterfaceMock
	params             *OrderStorageInterfaceMockIsConsistParams
	paramPtrs          *OrderStorageInterfaceMockIsConsistParamPtrs
	expectationOrigins OrderStorageInterfaceMockIsConsistExpectationOrigins
	results            *OrderStorageInterfaceMockIsConsistResults
	returnOrigin       string
	Counter            uint64
}

// OrderStorageInterfaceMockIsConsistParams contains parameters of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistParams struct {
	id uint
}

// OrderStorageInterfaceMockIsConsistParamPtrs contains pointers to parameters of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistParamPtrs struct {
	id *uint
}

// OrderStorageInterfaceMockIsConsistResults contains results of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistResults struct {
	b1 bool
}

// OrderStorageInterfaceMockIsConsistOrigins contains origins of expectations of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Optional() *mOrderStorageInterfaceMockIsConsist {
	mmIsConsist.optional = true
	return mmIsConsist
}

// Expect sets up expected params for OrderStorageInterface.IsConsist
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Expect(id uint) *mOrderStorageInterfaceMockIsConsist {
	if mmIsConsist.mock.funcIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Set")
	}

	if mmIsConsist.defaultExpectation == nil {
		mmIsConsist.defaultExpectation = &OrderStorageInterfaceMockIsConsistExpectation{}
	}

	if mmIsConsist.defaultExpectation.paramPtrs != nil {
		mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by ExpectParams functions")
	}

	mmIsConsist.defaultExpectation.params = &OrderStorageInterfaceMockIsConsistParams{id}
	mmIsConsist.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsConsist.expectations {
		if minimock.Equal(e.params, mmIsConsist.defaultExpectation.params) {
			mmIsConsist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsConsist.defaultExpectation.params)
		}
	}

	return mmIsConsist
}

// ExpectIdParam1 sets up expected param id for OrderStorageInterface.IsConsist
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) ExpectIdParam1(id uint) *mOrderStorageInterfaceMockIsConsist {
	if mmIsConsist.mock.funcIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Set")
	}

	if mmIsConsist.defaultExpectation == nil {
		mmIsConsist.defaultExpectation = &OrderStorageInterfaceMockIsConsistExpectation{}
	}

	if mmIsConsist.defaultExpectation.params != nil {
		mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Expect")
	}

	if mmIsConsist.defaultExpectation.paramPtrs == nil {
		mmIsConsist.defaultExpectation.paramPtrs = &OrderStorageInterfaceMockIsConsistParamPtrs{}
	}
	mmIsConsist.defaultExpectation.paramPtrs.id = &id
	mmIsConsist.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmIsConsist
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.IsConsist
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Inspect(f func(id uint)) *mOrderStorageInterfaceMockIsConsist {
	if mmIsConsist.mock.inspectFuncIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.IsConsist")
	}

	mmIsConsist.mock.inspectFuncIsConsist = f

	return mmIsConsist
}

// Return sets up results that will be returned by OrderStorageInterface.IsConsist
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Return(b1 bool) *OrderStorageInterfaceMock {
	if mmIsConsist.mock.funcIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Set")
	}

	if mmIsConsist.defaultExpectation == nil {
		mmIsConsist.defaultExpectation = &OrderStorageInterfaceMockIsConsistExpectation{mock: mmIsConsist.mock}
	}
	mmIsConsist.defaultExpectation.results = &OrderStorageInterfaceMockIsConsistResults{b1}
	mmIsConsist.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsConsist.mock
}

// Set uses given function f to mock the OrderStorageInterface.IsConsist method
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Set(f func(id uint) (b1 bool)) *OrderStorageInterfaceMock {
	if mmIsConsist.defaultExpectation != nil {
		mmIsConsist.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.IsConsist method")
	}

	if len(mmIsConsist.expectations) > 0 {
		mmIsConsist.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.IsConsist method")
	}

	mmIsConsist.mock.funcIsConsist = f
	mmIsConsist.mock.funcIsConsistOrigin = minimock.CallerInfo(1)
	return mmIsConsist.mock
}

// When sets expectation for the OrderStorageInterface.IsConsist which will trigger the result defined by the following
// Then helper
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) When(id uint) *OrderStorageInterfaceMockIsConsistExpectation {
	if mmIsConsist.mock.funcIsConsist != nil {
		mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Set")
	}

	expectation := &OrderStorageInterfaceMockIsConsistExpectation{
		mock:               mmIsConsist.mock,
		params:             &OrderStorageInterfaceMockIsConsistParams{id},
		expectationOrigins: OrderStorageInterfaceMockIsConsistExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsConsist.expectations = append(mmIsConsist.expectations, expectation)
	return expectation
}

// Then sets up OrderStorageInterface.IsConsist return parameters for the expectation previously defined by the When method
func (e *OrderStorageInterfaceMockIsConsistExpectation) Then(b1 bool) *OrderStorageInterfaceMock {
	e.results = &OrderStorageInterfaceMockIsConsistResults{b1}
	return e.mock
}

// Times sets number of times OrderStorageInterface.IsConsist should be invoked
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Times(n uint64) *mOrderStorageInterfaceMockIsConsist {
	if n == 0 {
		mmIsConsist.mock.t.Fatalf("Times of OrderStorageInterfaceMock.IsConsist mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsConsist.expectedInvocations, n)
	mmIsConsist.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsConsist
}

func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) invocationsDone() bool {
	if len(mmIsConsist.expectations) == 0 && mmIsConsist.defaultExpectation == nil && mmIsConsist.mock.funcIsConsist == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsConsist.mock.afterIsConsistCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsConsist.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsConsist implements mm_storage.OrderStorageInterface
func (mmIsConsist *OrderStorageInterfaceMock) IsConsist(id uint) (b1 bool) {
	mm_atomic.AddUint64(&mmIsConsist.beforeIsConsistCounter, 1)
	defer mm_atomic.AddUint64(&mmIsConsist.afterIsConsistCounter, 1)

	mmIsConsist.t.Helper()

	if mmIsConsist.inspectFuncIsConsist != nil {
		mmIsConsist.inspectFuncIsConsist(id)
	}

	mm_params := OrderStorageInterfaceMockIsConsistParams{id}

	// Record call args
	mmIsConsist.IsConsistMock.mutex.Lock()
	mmIsConsist.IsConsistMock.callArgs = append(mmIsConsist.IsConsistMock.callArgs, &mm_params)
	mmIsConsist.IsConsistMock.mutex.Unlock()

	for _, e := range mmIsConsist.IsConsistMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsConsist.IsConsistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsConsist.IsConsistMock.defaultExpectation.Counter, 1)
		mm_want := mmIsConsist.IsConsistMock.defaultExpectation.params
		mm_want_ptrs := mmIsConsist.IsConsistMock.defaultExpectation.paramPtrs

		mm_got := OrderStorageInterfaceMockIsConsistParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmIsConsist.t.Errorf("OrderStorageInterfaceMock.IsConsist got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsConsist.IsConsistMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsConsist.t.Errorf("OrderStorageInterfaceMock.IsConsist got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsConsist.IsConsistMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsConsist.IsConsistMock.defaultExpectation.results
		if mm_results == nil {
			mmIsConsist.t.Fatal("No results are set for the OrderStorageInterfaceMock.IsConsist")
		}
		return (*mm_results).b1
	}
	if mmIsConsist.funcIsConsist != nil {
		return mmIsConsist.funcIsConsist(id)
	}
	mmIsConsist.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.IsConsist. %v", id)
	return
}

// IsConsistAfterCounter returns a count of finished OrderStorageInterfaceMock.IsConsist invocations
func (mmIsConsist *OrderStorageInterfaceMock) IsConsistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsConsist.afterIsConsistCounter)
}

// IsConsistBeforeCounter returns a count of OrderStorageInterfaceMock.IsConsist invocations
func (mmIsConsist *OrderStorageInterfaceMock) IsConsistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsConsist.beforeIsConsistCounter)
}

// Calls returns a list of arguments used in each call to OrderStorageInterfaceMock.IsConsist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Calls() []*OrderStorageInterfaceMockIsConsistParams {
	mmIsConsist.mutex.RLock()

	argCopy := make([]*OrderStorageInterfaceMockIsConsistParams, len(mmIsConsist.callArgs))
	copy(argCopy, mmIsConsist.callArgs)

	mmIsConsist.mutex.RUnlock()

	return argCopy
}

// MinimockIsConsistDone returns true if the count of the IsConsist invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockIsConsistDone() bool {
	if m.IsConsistMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsConsistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsConsistMock.invocationsDone()
}

// MinimockIsConsistInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockIsConsistInspect() {
	for _, e := range m.IsConsistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.IsConsist at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsConsistCounter := mm_atomic.LoadUint64(&m.afterIsConsistCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsConsistMock.defaultExpectation != nil && afterIsConsistCounter < 1 {
		if m.IsConsistMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.IsConsist at\n%s", m.IsConsistMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderStorageInterfaceMock.IsConsist at\n%s with params: %#v", m.IsConsistMock.defaultExpectation.expectationOrigins.origin, *m.IsConsistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsConsist != nil && afterIsConsistCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.IsConsist at\n%s", m.funcIsConsistOrigin)
	}

	if !m.IsConsistMock.invocationsDone() && afterIsConsistCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.IsConsist at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsConsistMock.expectedInvocations), m.IsConsistMock.expectedInvocationsOrigin, afterIsConsistCounter)
	}
}

type mOrderStorageInterfaceMockReadFromJSON struct {
	optional           bool
	mock               *OrderStorageInterfaceMock
	defaultExpectation *OrderStorageInterfaceMockReadFromJSONExpectation
	expectations       []*OrderStorageInterfaceMockReadFromJSONExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockReadFromJSONExpectation specifies expectation struct of the OrderStorageInterface.ReadFromJSON
type OrderStorageInterfaceMockReadFromJSONExpectation struct {
	mock *OrderStorageInterfaceMock

	results      *OrderStorageInterfaceMockReadFromJSONResults
	returnOrigin string
	Counter      uint64
}

// OrderStorageInterfaceMockReadFromJSONResults contains results of the OrderStorageInterface.ReadFromJSON
type OrderStorageInterfaceMockReadFromJSONResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Optional() *mOrderStorageInterfaceMockReadFromJSON {
	mmReadFromJSON.optional = true
	return mmReadFromJSON
}

// Expect sets up expected params for OrderStorageInterface.ReadFromJSON
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Expect() *mOrderStorageInterfaceMockReadFromJSON {
	if mmReadFromJSON.mock.funcReadFromJSON != nil {
		mmReadFromJSON.mock.t.Fatalf("OrderStorageInterfaceMock.ReadFromJSON mock is already set by Set")
	}

	if mmReadFromJSON.defaultExpectation == nil {
		mmReadFromJSON.defaultExpectation = &OrderStorageInterfaceMockReadFromJSONExpectation{}
	}

	return mmReadFromJSON
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.ReadFromJSON
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Inspect(f func()) *mOrderStorageInterfaceMockReadFromJSON {
	if mmReadFromJSON.mock.inspectFuncReadFromJSON != nil {
		mmReadFromJSON.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.ReadFromJSON")
	}

	mmReadFromJSON.mock.inspectFuncReadFromJSON = f

	return mmReadFromJSON
}

// Return sets up results that will be returned by OrderStorageInterface.ReadFromJSON
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Return(err error) *OrderStorageInterfaceMock {
	if mmReadFromJSON.mock.funcReadFromJSON != nil {
		mmReadFromJSON.mock.t.Fatalf("OrderStorageInterfaceMock.ReadFromJSON mock is already set by Set")
	}

	if mmReadFromJSON.defaultExpectation == nil {
		mmReadFromJSON.defaultExpectation = &OrderStorageInterfaceMockReadFromJSONExpectation{mock: mmReadFromJSON.mock}
	}
	mmReadFromJSON.defaultExpectation.results = &OrderStorageInterfaceMockReadFromJSONResults{err}
	mmReadFromJSON.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadFromJSON.mock
}

// Set uses given function f to mock the OrderStorageInterface.ReadFromJSON method
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Set(f func() (err error)) *OrderStorageInterfaceMock {
	if mmReadFromJSON.defaultExpectation != nil {
		mmReadFromJSON.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.ReadFromJSON method")
	}

	if len(mmReadFromJSON.expectations) > 0 {
		mmReadFromJSON.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.ReadFromJSON method")
	}

	mmReadFromJSON.mock.funcReadFromJSON = f
	mmReadFromJSON.mock.funcReadFromJSONOrigin = minimock.CallerInfo(1)
	return mmReadFromJSON.mock
}

// Times sets number of times OrderStorageInterface.ReadFromJSON should be invoked
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Times(n uint64) *mOrderStorageInterfaceMockReadFromJSON {
	if n == 0 {
		mmReadFromJSON.mock.t.Fatalf("Times of OrderStorageInterfaceMock.ReadFromJSON mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadFromJSON.expectedInvocations, n)
	mmReadFromJSON.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadFromJSON
}

func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) invocationsDone() bool {
	if len(mmReadFromJSON.expectations) == 0 && mmReadFromJSON.defaultExpectation == nil && mmReadFromJSON.mock.funcReadFromJSON == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadFromJSON.mock.afterReadFromJSONCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadFromJSON.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadFromJSON implements mm_storage.OrderStorageInterface
func (mmReadFromJSON *OrderStorageInterfaceMock) ReadFromJSON() (err error) {
	mm_atomic.AddUint64(&mmReadFromJSON.beforeReadFromJSONCounter, 1)
	defer mm_atomic.AddUint64(&mmReadFromJSON.afterReadFromJSONCounter, 1)

	mmReadFromJSON.t.Helper()

	if mmReadFromJSON.inspectFuncReadFromJSON != nil {
		mmReadFromJSON.inspectFuncReadFromJSON()
	}

	if mmReadFromJSON.ReadFromJSONMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadFromJSON.ReadFromJSONMock.defaultExpectation.Counter, 1)

		mm_results := mmReadFromJSON.ReadFromJSONMock.defaultExpectation.results
		if mm_results == nil {
			mmReadFromJSON.t.Fatal("No results are set for the OrderStorageInterfaceMock.ReadFromJSON")
		}
		return (*mm_results).err
	}
	if mmReadFromJSON.funcReadFromJSON != nil {
		return mmReadFromJSON.funcReadFromJSON()
	}
	mmReadFromJSON.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.ReadFromJSON.")
	return
}

// ReadFromJSONAfterCounter returns a count of finished OrderStorageInterfaceMock.ReadFromJSON invocations
func (mmReadFromJSON *OrderStorageInterfaceMock) ReadFromJSONAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFromJSON.afterReadFromJSONCounter)
}

// ReadFromJSONBeforeCounter returns a count of OrderStorageInterfaceMock.ReadFromJSON invocations
func (mmReadFromJSON *OrderStorageInterfaceMock) ReadFromJSONBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFromJSON.beforeReadFromJSONCounter)
}

// MinimockReadFromJSONDone returns true if the count of the ReadFromJSON invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockReadFromJSONDone() bool {
	if m.ReadFromJSONMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadFromJSONMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadFromJSONMock.invocationsDone()
}

// MinimockReadFromJSONInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockReadFromJSONInspect() {
	for _, e := range m.ReadFromJSONMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to OrderStorageInterfaceMock.ReadFromJSON")
		}
	}

	afterReadFromJSONCounter := mm_atomic.LoadUint64(&m.afterReadFromJSONCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadFromJSONMock.defaultExpectation != nil && afterReadFromJSONCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.ReadFromJSON at\n%s", m.ReadFromJSONMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadFromJSON != nil && afterReadFromJSONCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.ReadFromJSON at\n%s", m.funcReadFromJSONOrigin)
	}

	if !m.ReadFromJSONMock.invocationsDone() && afterReadFromJSONCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.ReadFromJSON at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadFromJSONMock.expectedInvocations), m.ReadFromJSONMock.expectedInvocationsOrigin, afterReadFromJSONCounter)
	}
}

type mOrderStorageInterfaceMockWriteToJSON struct {
	optional           bool
	mock               *OrderStorageInterfaceMock
	defaultExpectation *OrderStorageInterfaceMockWriteToJSONExpectation
	expectations       []*OrderStorageInterfaceMockWriteToJSONExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockWriteToJSONExpectation specifies expectation struct of the OrderStorageInterface.WriteToJSON
type OrderStorageInterfaceMockWriteToJSONExpectation struct {
	mock *OrderStorageInterfaceMock

	results      *OrderStorageInterfaceMockWriteToJSONResults
	returnOrigin string
	Counter      uint64
}

// OrderStorageInterfaceMockWriteToJSONResults contains results of the OrderStorageInterface.WriteToJSON
type OrderStorageInterfaceMockWriteToJSONResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Optional() *mOrderStorageInterfaceMockWriteToJSON {
	mmWriteToJSON.optional = true
	return mmWriteToJSON
}

// Expect sets up expected params for OrderStorageInterface.WriteToJSON
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Expect() *mOrderStorageInterfaceMockWriteToJSON {
	if mmWriteToJSON.mock.funcWriteToJSON != nil {
		mmWriteToJSON.mock.t.Fatalf("OrderStorageInterfaceMock.WriteToJSON mock is already set by Set")
	}

	if mmWriteToJSON.defaultExpectation == nil {
		mmWriteToJSON.defaultExpectation = &OrderStorageInterfaceMockWriteToJSONExpectation{}
	}

	return mmWriteToJSON
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.WriteToJSON
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Inspect(f func()) *mOrderStorageInterfaceMockWriteToJSON {
	if mmWriteToJSON.mock.inspectFuncWriteToJSON != nil {
		mmWriteToJSON.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.WriteToJSON")
	}

	mmWriteToJSON.mock.inspectFuncWriteToJSON = f

	return mmWriteToJSON
}

// Return sets up results that will be returned by OrderStorageInterface.WriteToJSON
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Return(err error) *OrderStorageInterfaceMock {
	if mmWriteToJSON.mock.funcWriteToJSON != nil {
		mmWriteToJSON.mock.t.Fatalf("OrderStorageInterfaceMock.WriteToJSON mock is already set by Set")
	}

	if mmWriteToJSON.defaultExpectation == nil {
		mmWriteToJSON.defaultExpectation = &OrderStorageInterfaceMockWriteToJSONExpectation{mock: mmWriteToJSON.mock}
	}
	mmWriteToJSON.defaultExpectation.results = &OrderStorageInterfaceMockWriteToJSONResults{err}
	mmWriteToJSON.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWriteToJSON.mock
}

// Set uses given function f to mock the OrderStorageInterface.WriteToJSON method
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Set(f func() (err error)) *OrderStorageInterfaceMock {
	if mmWriteToJSON.defaultExpectation != nil {
		mmWriteToJSON.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.WriteToJSON method")
	}

	if len(mmWriteToJSON.expectations) > 0 {
		mmWriteToJSON.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.WriteToJSON method")
	}

	mmWriteToJSON.mock.funcWriteToJSON = f
	mmWriteToJSON.mock.funcWriteToJSONOrigin = minimock.CallerInfo(1)
	return mmWriteToJSON.mock
}

// Times sets number of times OrderStorageInterface.WriteToJSON should be invoked
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Times(n uint64) *mOrderStorageInterfaceMockWriteToJSON {
	if n == 0 {
		mmWriteToJSON.mock.t.Fatalf("Times of OrderStorageInterfaceMock.WriteToJSON mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWriteToJSON.expectedInvocations, n)
	mmWriteToJSON.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWriteToJSON
}

func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) invocationsDone() bool {
	if len(mmWriteToJSON.expectations) == 0 && mmWriteToJSON.defaultExpectation == nil && mmWriteToJSON.mock.funcWriteToJSON == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWriteToJSON.mock.afterWriteToJSONCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWriteToJSON.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WriteToJSON implements mm_storage.OrderStorageInterface
func (mmWriteToJSON *OrderStorageInterfaceMock) WriteToJSON() (err error) {
	mm_atomic.AddUint64(&mmWriteToJSON.beforeWriteToJSONCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteToJSON.afterWriteToJSONCounter, 1)

	mmWriteToJSON.t.Helper()

	if mmWriteToJSON.inspectFuncWriteToJSON != nil {
		mmWriteToJSON.inspectFuncWriteToJSON()
	}

	if mmWriteToJSON.WriteToJSONMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteToJSON.WriteToJSONMock.defaultExpectation.Counter, 1)

		mm_results := mmWriteToJSON.WriteToJSONMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteToJSON.t.Fatal("No results are set for the OrderStorageInterfaceMock.WriteToJSON")
		}
		return (*mm_results).err
	}
	if mmWriteToJSON.funcWriteToJSON != nil {
		return mmWriteToJSON.funcWriteToJSON()
	}
	mmWriteToJSON.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.WriteToJSON.")
	return
}

// WriteToJSONAfterCounter returns a count of finished OrderStorageInterfaceMock.WriteToJSON invocations
func (mmWriteToJSON *OrderStorageInterfaceMock) WriteToJSONAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteToJSON.afterWriteToJSONCounter)
}

// WriteToJSONBeforeCounter returns a count of OrderStorageInterfaceMock.WriteToJSON invocations
func (mmWriteToJSON *OrderStorageInterfaceMock) WriteToJSONBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteToJSON.beforeWriteToJSONCounter)
}

// MinimockWriteToJSONDone returns true if the count of the WriteToJSON invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockWriteToJSONDone() bool {
	if m.WriteToJSONMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteToJSONMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteToJSONMock.invocationsDone()
}

// MinimockWriteToJSONInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockWriteToJSONInspect() {
	for _, e := range m.WriteToJSONMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to OrderStorageInterfaceMock.WriteToJSON")
		}
	}

	afterWriteToJSONCounter := mm_atomic.LoadUint64(&m.afterWriteToJSONCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToJSONMock.defaultExpectation != nil && afterWriteToJSONCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.WriteToJSON at\n%s", m.WriteToJSONMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteToJSON != nil && afterWriteToJSONCounter < 1 {
		m.t.Errorf("Expected call to OrderStorageInterfaceMock.WriteToJSON at\n%s", m.funcWriteToJSONOrigin)
	}

	if !m.WriteToJSONMock.invocationsDone() && afterWriteToJSONCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.WriteToJSON at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WriteToJSONMock.expectedInvocations), m.WriteToJSONMock.expectedInvocationsOrigin, afterWriteToJSONCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderStorageInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderToStorageInspect()

			m.MinimockDeleteOrderFromStorageInspect()

			m.MinimockGetOrderInspect()

			m.MinimockGetOrderIDsInspect()

			m.MinimockIsConsistInspect()

			m.MinimockReadFromJSONInspect()

			m.MinimockWriteToJSONInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderStorageInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderStorageInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderToStorageDone() &&
		m.MinimockDeleteOrderFromStorageDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetOrderIDsDone() &&
		m.MinimockIsConsistDone() &&
		m.MinimockReadFromJSONDone() &&
		m.MinimockWriteToJSONDone()
}
