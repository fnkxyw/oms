// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i gitlab.ozon.dev/akugnerevich/homework.git/internal/storage.Facade -o facade_mock_test.go -n FacadeMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
)

// FacadeMock implements mm_storage.Facade
type FacadeMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptOrder          func(ctx context.Context, or *models.Order) (err error)
	funcAcceptOrderOrigin    string
	inspectFuncAcceptOrder   func(ctx context.Context, or *models.Order)
	afterAcceptOrderCounter  uint64
	beforeAcceptOrderCounter uint64
	AcceptOrderMock          mFacadeMockAcceptOrder

	funcGetItem          func(ctx context.Context, id uint) (op1 *models.Order, b1 bool)
	funcGetItemOrigin    string
	inspectFuncGetItem   func(ctx context.Context, id uint)
	afterGetItemCounter  uint64
	beforeGetItemCounter uint64
	GetItemMock          mFacadeMockGetItem

	funcListOrders          func(ctx context.Context, id uint, inPuP bool) (oa1 []models.Order, err error)
	funcListOrdersOrigin    string
	inspectFuncListOrders   func(ctx context.Context, id uint, inPuP bool)
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mFacadeMockListOrders

	funcListReturns          func(ctx context.Context, limit int, page int) (oa1 []models.Order, err error)
	funcListReturnsOrigin    string
	inspectFuncListReturns   func(ctx context.Context, limit int, page int)
	afterListReturnsCounter  uint64
	beforeListReturnsCounter uint64
	ListReturnsMock          mFacadeMockListReturns

	funcPlaceOrder          func(ctx context.Context, ids []uint) (err error)
	funcPlaceOrderOrigin    string
	inspectFuncPlaceOrder   func(ctx context.Context, ids []uint)
	afterPlaceOrderCounter  uint64
	beforePlaceOrderCounter uint64
	PlaceOrderMock          mFacadeMockPlaceOrder

	funcRefundOrder          func(ctx context.Context, id uint, userId uint) (err error)
	funcRefundOrderOrigin    string
	inspectFuncRefundOrder   func(ctx context.Context, id uint, userId uint)
	afterRefundOrderCounter  uint64
	beforeRefundOrderCounter uint64
	RefundOrderMock          mFacadeMockRefundOrder

	funcReturnOrder          func(ctx context.Context, id uint) (err error)
	funcReturnOrderOrigin    string
	inspectFuncReturnOrder   func(ctx context.Context, id uint)
	afterReturnOrderCounter  uint64
	beforeReturnOrderCounter uint64
	ReturnOrderMock          mFacadeMockReturnOrder
}

// NewFacadeMock returns a mock for mm_storage.Facade
func NewFacadeMock(t minimock.Tester) *FacadeMock {
	m := &FacadeMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptOrderMock = mFacadeMockAcceptOrder{mock: m}
	m.AcceptOrderMock.callArgs = []*FacadeMockAcceptOrderParams{}

	m.GetItemMock = mFacadeMockGetItem{mock: m}
	m.GetItemMock.callArgs = []*FacadeMockGetItemParams{}

	m.ListOrdersMock = mFacadeMockListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*FacadeMockListOrdersParams{}

	m.ListReturnsMock = mFacadeMockListReturns{mock: m}
	m.ListReturnsMock.callArgs = []*FacadeMockListReturnsParams{}

	m.PlaceOrderMock = mFacadeMockPlaceOrder{mock: m}
	m.PlaceOrderMock.callArgs = []*FacadeMockPlaceOrderParams{}

	m.RefundOrderMock = mFacadeMockRefundOrder{mock: m}
	m.RefundOrderMock.callArgs = []*FacadeMockRefundOrderParams{}

	m.ReturnOrderMock = mFacadeMockReturnOrder{mock: m}
	m.ReturnOrderMock.callArgs = []*FacadeMockReturnOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFacadeMockAcceptOrder struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockAcceptOrderExpectation
	expectations       []*FacadeMockAcceptOrderExpectation

	callArgs []*FacadeMockAcceptOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockAcceptOrderExpectation specifies expectation struct of the Facade.AcceptOrder
type FacadeMockAcceptOrderExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockAcceptOrderParams
	paramPtrs          *FacadeMockAcceptOrderParamPtrs
	expectationOrigins FacadeMockAcceptOrderExpectationOrigins
	results            *FacadeMockAcceptOrderResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockAcceptOrderParams contains parameters of the Facade.AcceptOrder
type FacadeMockAcceptOrderParams struct {
	ctx context.Context
	or  *models.Order
}

// FacadeMockAcceptOrderParamPtrs contains pointers to parameters of the Facade.AcceptOrder
type FacadeMockAcceptOrderParamPtrs struct {
	ctx *context.Context
	or  **models.Order
}

// FacadeMockAcceptOrderResults contains results of the Facade.AcceptOrder
type FacadeMockAcceptOrderResults struct {
	err error
}

// FacadeMockAcceptOrderOrigins contains origins of expectations of the Facade.AcceptOrder
type FacadeMockAcceptOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originOr  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptOrder *mFacadeMockAcceptOrder) Optional() *mFacadeMockAcceptOrder {
	mmAcceptOrder.optional = true
	return mmAcceptOrder
}

// Expect sets up expected params for Facade.AcceptOrder
func (mmAcceptOrder *mFacadeMockAcceptOrder) Expect(ctx context.Context, or *models.Order) *mFacadeMockAcceptOrder {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("FacadeMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &FacadeMockAcceptOrderExpectation{}
	}

	if mmAcceptOrder.defaultExpectation.paramPtrs != nil {
		mmAcceptOrder.mock.t.Fatalf("FacadeMock.AcceptOrder mock is already set by ExpectParams functions")
	}

	mmAcceptOrder.defaultExpectation.params = &FacadeMockAcceptOrderParams{ctx, or}
	mmAcceptOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptOrder.expectations {
		if minimock.Equal(e.params, mmAcceptOrder.defaultExpectation.params) {
			mmAcceptOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptOrder.defaultExpectation.params)
		}
	}

	return mmAcceptOrder
}

// ExpectCtxParam1 sets up expected param ctx for Facade.AcceptOrder
func (mmAcceptOrder *mFacadeMockAcceptOrder) ExpectCtxParam1(ctx context.Context) *mFacadeMockAcceptOrder {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("FacadeMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &FacadeMockAcceptOrderExpectation{}
	}

	if mmAcceptOrder.defaultExpectation.params != nil {
		mmAcceptOrder.mock.t.Fatalf("FacadeMock.AcceptOrder mock is already set by Expect")
	}

	if mmAcceptOrder.defaultExpectation.paramPtrs == nil {
		mmAcceptOrder.defaultExpectation.paramPtrs = &FacadeMockAcceptOrderParamPtrs{}
	}
	mmAcceptOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmAcceptOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAcceptOrder
}

// ExpectOrParam2 sets up expected param or for Facade.AcceptOrder
func (mmAcceptOrder *mFacadeMockAcceptOrder) ExpectOrParam2(or *models.Order) *mFacadeMockAcceptOrder {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("FacadeMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &FacadeMockAcceptOrderExpectation{}
	}

	if mmAcceptOrder.defaultExpectation.params != nil {
		mmAcceptOrder.mock.t.Fatalf("FacadeMock.AcceptOrder mock is already set by Expect")
	}

	if mmAcceptOrder.defaultExpectation.paramPtrs == nil {
		mmAcceptOrder.defaultExpectation.paramPtrs = &FacadeMockAcceptOrderParamPtrs{}
	}
	mmAcceptOrder.defaultExpectation.paramPtrs.or = &or
	mmAcceptOrder.defaultExpectation.expectationOrigins.originOr = minimock.CallerInfo(1)

	return mmAcceptOrder
}

// Inspect accepts an inspector function that has same arguments as the Facade.AcceptOrder
func (mmAcceptOrder *mFacadeMockAcceptOrder) Inspect(f func(ctx context.Context, or *models.Order)) *mFacadeMockAcceptOrder {
	if mmAcceptOrder.mock.inspectFuncAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("Inspect function is already set for FacadeMock.AcceptOrder")
	}

	mmAcceptOrder.mock.inspectFuncAcceptOrder = f

	return mmAcceptOrder
}

// Return sets up results that will be returned by Facade.AcceptOrder
func (mmAcceptOrder *mFacadeMockAcceptOrder) Return(err error) *FacadeMock {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("FacadeMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &FacadeMockAcceptOrderExpectation{mock: mmAcceptOrder.mock}
	}
	mmAcceptOrder.defaultExpectation.results = &FacadeMockAcceptOrderResults{err}
	mmAcceptOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder.mock
}

// Set uses given function f to mock the Facade.AcceptOrder method
func (mmAcceptOrder *mFacadeMockAcceptOrder) Set(f func(ctx context.Context, or *models.Order) (err error)) *FacadeMock {
	if mmAcceptOrder.defaultExpectation != nil {
		mmAcceptOrder.mock.t.Fatalf("Default expectation is already set for the Facade.AcceptOrder method")
	}

	if len(mmAcceptOrder.expectations) > 0 {
		mmAcceptOrder.mock.t.Fatalf("Some expectations are already set for the Facade.AcceptOrder method")
	}

	mmAcceptOrder.mock.funcAcceptOrder = f
	mmAcceptOrder.mock.funcAcceptOrderOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder.mock
}

// When sets expectation for the Facade.AcceptOrder which will trigger the result defined by the following
// Then helper
func (mmAcceptOrder *mFacadeMockAcceptOrder) When(ctx context.Context, or *models.Order) *FacadeMockAcceptOrderExpectation {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("FacadeMock.AcceptOrder mock is already set by Set")
	}

	expectation := &FacadeMockAcceptOrderExpectation{
		mock:               mmAcceptOrder.mock,
		params:             &FacadeMockAcceptOrderParams{ctx, or},
		expectationOrigins: FacadeMockAcceptOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptOrder.expectations = append(mmAcceptOrder.expectations, expectation)
	return expectation
}

// Then sets up Facade.AcceptOrder return parameters for the expectation previously defined by the When method
func (e *FacadeMockAcceptOrderExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockAcceptOrderResults{err}
	return e.mock
}

// Times sets number of times Facade.AcceptOrder should be invoked
func (mmAcceptOrder *mFacadeMockAcceptOrder) Times(n uint64) *mFacadeMockAcceptOrder {
	if n == 0 {
		mmAcceptOrder.mock.t.Fatalf("Times of FacadeMock.AcceptOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptOrder.expectedInvocations, n)
	mmAcceptOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder
}

func (mmAcceptOrder *mFacadeMockAcceptOrder) invocationsDone() bool {
	if len(mmAcceptOrder.expectations) == 0 && mmAcceptOrder.defaultExpectation == nil && mmAcceptOrder.mock.funcAcceptOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptOrder.mock.afterAcceptOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptOrder implements mm_storage.Facade
func (mmAcceptOrder *FacadeMock) AcceptOrder(ctx context.Context, or *models.Order) (err error) {
	mm_atomic.AddUint64(&mmAcceptOrder.beforeAcceptOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptOrder.afterAcceptOrderCounter, 1)

	mmAcceptOrder.t.Helper()

	if mmAcceptOrder.inspectFuncAcceptOrder != nil {
		mmAcceptOrder.inspectFuncAcceptOrder(ctx, or)
	}

	mm_params := FacadeMockAcceptOrderParams{ctx, or}

	// Record call args
	mmAcceptOrder.AcceptOrderMock.mutex.Lock()
	mmAcceptOrder.AcceptOrderMock.callArgs = append(mmAcceptOrder.AcceptOrderMock.callArgs, &mm_params)
	mmAcceptOrder.AcceptOrderMock.mutex.Unlock()

	for _, e := range mmAcceptOrder.AcceptOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAcceptOrder.AcceptOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptOrder.AcceptOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptOrder.AcceptOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptOrder.AcceptOrderMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockAcceptOrderParams{ctx, or}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptOrder.t.Errorf("FacadeMock.AcceptOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrder.AcceptOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.or != nil && !minimock.Equal(*mm_want_ptrs.or, mm_got.or) {
				mmAcceptOrder.t.Errorf("FacadeMock.AcceptOrder got unexpected parameter or, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrder.AcceptOrderMock.defaultExpectation.expectationOrigins.originOr, *mm_want_ptrs.or, mm_got.or, minimock.Diff(*mm_want_ptrs.or, mm_got.or))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptOrder.t.Errorf("FacadeMock.AcceptOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptOrder.AcceptOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptOrder.AcceptOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptOrder.t.Fatal("No results are set for the FacadeMock.AcceptOrder")
		}
		return (*mm_results).err
	}
	if mmAcceptOrder.funcAcceptOrder != nil {
		return mmAcceptOrder.funcAcceptOrder(ctx, or)
	}
	mmAcceptOrder.t.Fatalf("Unexpected call to FacadeMock.AcceptOrder. %v %v", ctx, or)
	return
}

// AcceptOrderAfterCounter returns a count of finished FacadeMock.AcceptOrder invocations
func (mmAcceptOrder *FacadeMock) AcceptOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptOrder.afterAcceptOrderCounter)
}

// AcceptOrderBeforeCounter returns a count of FacadeMock.AcceptOrder invocations
func (mmAcceptOrder *FacadeMock) AcceptOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptOrder.beforeAcceptOrderCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.AcceptOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptOrder *mFacadeMockAcceptOrder) Calls() []*FacadeMockAcceptOrderParams {
	mmAcceptOrder.mutex.RLock()

	argCopy := make([]*FacadeMockAcceptOrderParams, len(mmAcceptOrder.callArgs))
	copy(argCopy, mmAcceptOrder.callArgs)

	mmAcceptOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptOrderDone returns true if the count of the AcceptOrder invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockAcceptOrderDone() bool {
	if m.AcceptOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptOrderMock.invocationsDone()
}

// MinimockAcceptOrderInspect logs each unmet expectation
func (m *FacadeMock) MinimockAcceptOrderInspect() {
	for _, e := range m.AcceptOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.AcceptOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptOrderCounter := mm_atomic.LoadUint64(&m.afterAcceptOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptOrderMock.defaultExpectation != nil && afterAcceptOrderCounter < 1 {
		if m.AcceptOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.AcceptOrder at\n%s", m.AcceptOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.AcceptOrder at\n%s with params: %#v", m.AcceptOrderMock.defaultExpectation.expectationOrigins.origin, *m.AcceptOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptOrder != nil && afterAcceptOrderCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.AcceptOrder at\n%s", m.funcAcceptOrderOrigin)
	}

	if !m.AcceptOrderMock.invocationsDone() && afterAcceptOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.AcceptOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptOrderMock.expectedInvocations), m.AcceptOrderMock.expectedInvocationsOrigin, afterAcceptOrderCounter)
	}
}

type mFacadeMockGetItem struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetItemExpectation
	expectations       []*FacadeMockGetItemExpectation

	callArgs []*FacadeMockGetItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetItemExpectation specifies expectation struct of the Facade.GetItem
type FacadeMockGetItemExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetItemParams
	paramPtrs          *FacadeMockGetItemParamPtrs
	expectationOrigins FacadeMockGetItemExpectationOrigins
	results            *FacadeMockGetItemResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetItemParams contains parameters of the Facade.GetItem
type FacadeMockGetItemParams struct {
	ctx context.Context
	id  uint
}

// FacadeMockGetItemParamPtrs contains pointers to parameters of the Facade.GetItem
type FacadeMockGetItemParamPtrs struct {
	ctx *context.Context
	id  *uint
}

// FacadeMockGetItemResults contains results of the Facade.GetItem
type FacadeMockGetItemResults struct {
	op1 *models.Order
	b1  bool
}

// FacadeMockGetItemOrigins contains origins of expectations of the Facade.GetItem
type FacadeMockGetItemExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItem *mFacadeMockGetItem) Optional() *mFacadeMockGetItem {
	mmGetItem.optional = true
	return mmGetItem
}

// Expect sets up expected params for Facade.GetItem
func (mmGetItem *mFacadeMockGetItem) Expect(ctx context.Context, id uint) *mFacadeMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("FacadeMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &FacadeMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.paramPtrs != nil {
		mmGetItem.mock.t.Fatalf("FacadeMock.GetItem mock is already set by ExpectParams functions")
	}

	mmGetItem.defaultExpectation.params = &FacadeMockGetItemParams{ctx, id}
	mmGetItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItem.expectations {
		if minimock.Equal(e.params, mmGetItem.defaultExpectation.params) {
			mmGetItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItem.defaultExpectation.params)
		}
	}

	return mmGetItem
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetItem
func (mmGetItem *mFacadeMockGetItem) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("FacadeMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &FacadeMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.params != nil {
		mmGetItem.mock.t.Fatalf("FacadeMock.GetItem mock is already set by Expect")
	}

	if mmGetItem.defaultExpectation.paramPtrs == nil {
		mmGetItem.defaultExpectation.paramPtrs = &FacadeMockGetItemParamPtrs{}
	}
	mmGetItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItem
}

// ExpectIdParam2 sets up expected param id for Facade.GetItem
func (mmGetItem *mFacadeMockGetItem) ExpectIdParam2(id uint) *mFacadeMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("FacadeMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &FacadeMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.params != nil {
		mmGetItem.mock.t.Fatalf("FacadeMock.GetItem mock is already set by Expect")
	}

	if mmGetItem.defaultExpectation.paramPtrs == nil {
		mmGetItem.defaultExpectation.paramPtrs = &FacadeMockGetItemParamPtrs{}
	}
	mmGetItem.defaultExpectation.paramPtrs.id = &id
	mmGetItem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetItem
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetItem
func (mmGetItem *mFacadeMockGetItem) Inspect(f func(ctx context.Context, id uint)) *mFacadeMockGetItem {
	if mmGetItem.mock.inspectFuncGetItem != nil {
		mmGetItem.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetItem")
	}

	mmGetItem.mock.inspectFuncGetItem = f

	return mmGetItem
}

// Return sets up results that will be returned by Facade.GetItem
func (mmGetItem *mFacadeMockGetItem) Return(op1 *models.Order, b1 bool) *FacadeMock {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("FacadeMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &FacadeMockGetItemExpectation{mock: mmGetItem.mock}
	}
	mmGetItem.defaultExpectation.results = &FacadeMockGetItemResults{op1, b1}
	mmGetItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItem.mock
}

// Set uses given function f to mock the Facade.GetItem method
func (mmGetItem *mFacadeMockGetItem) Set(f func(ctx context.Context, id uint) (op1 *models.Order, b1 bool)) *FacadeMock {
	if mmGetItem.defaultExpectation != nil {
		mmGetItem.mock.t.Fatalf("Default expectation is already set for the Facade.GetItem method")
	}

	if len(mmGetItem.expectations) > 0 {
		mmGetItem.mock.t.Fatalf("Some expectations are already set for the Facade.GetItem method")
	}

	mmGetItem.mock.funcGetItem = f
	mmGetItem.mock.funcGetItemOrigin = minimock.CallerInfo(1)
	return mmGetItem.mock
}

// When sets expectation for the Facade.GetItem which will trigger the result defined by the following
// Then helper
func (mmGetItem *mFacadeMockGetItem) When(ctx context.Context, id uint) *FacadeMockGetItemExpectation {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("FacadeMock.GetItem mock is already set by Set")
	}

	expectation := &FacadeMockGetItemExpectation{
		mock:               mmGetItem.mock,
		params:             &FacadeMockGetItemParams{ctx, id},
		expectationOrigins: FacadeMockGetItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItem.expectations = append(mmGetItem.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetItem return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetItemExpectation) Then(op1 *models.Order, b1 bool) *FacadeMock {
	e.results = &FacadeMockGetItemResults{op1, b1}
	return e.mock
}

// Times sets number of times Facade.GetItem should be invoked
func (mmGetItem *mFacadeMockGetItem) Times(n uint64) *mFacadeMockGetItem {
	if n == 0 {
		mmGetItem.mock.t.Fatalf("Times of FacadeMock.GetItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItem.expectedInvocations, n)
	mmGetItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItem
}

func (mmGetItem *mFacadeMockGetItem) invocationsDone() bool {
	if len(mmGetItem.expectations) == 0 && mmGetItem.defaultExpectation == nil && mmGetItem.mock.funcGetItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItem.mock.afterGetItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItem implements mm_storage.Facade
func (mmGetItem *FacadeMock) GetItem(ctx context.Context, id uint) (op1 *models.Order, b1 bool) {
	mm_atomic.AddUint64(&mmGetItem.beforeGetItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItem.afterGetItemCounter, 1)

	mmGetItem.t.Helper()

	if mmGetItem.inspectFuncGetItem != nil {
		mmGetItem.inspectFuncGetItem(ctx, id)
	}

	mm_params := FacadeMockGetItemParams{ctx, id}

	// Record call args
	mmGetItem.GetItemMock.mutex.Lock()
	mmGetItem.GetItemMock.callArgs = append(mmGetItem.GetItemMock.callArgs, &mm_params)
	mmGetItem.GetItemMock.mutex.Unlock()

	for _, e := range mmGetItem.GetItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.b1
		}
	}

	if mmGetItem.GetItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItem.GetItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItem.GetItemMock.defaultExpectation.params
		mm_want_ptrs := mmGetItem.GetItemMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetItemParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItem.t.Errorf("FacadeMock.GetItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetItem.t.Errorf("FacadeMock.GetItem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItem.t.Errorf("FacadeMock.GetItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItem.GetItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItem.t.Fatal("No results are set for the FacadeMock.GetItem")
		}
		return (*mm_results).op1, (*mm_results).b1
	}
	if mmGetItem.funcGetItem != nil {
		return mmGetItem.funcGetItem(ctx, id)
	}
	mmGetItem.t.Fatalf("Unexpected call to FacadeMock.GetItem. %v %v", ctx, id)
	return
}

// GetItemAfterCounter returns a count of finished FacadeMock.GetItem invocations
func (mmGetItem *FacadeMock) GetItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItem.afterGetItemCounter)
}

// GetItemBeforeCounter returns a count of FacadeMock.GetItem invocations
func (mmGetItem *FacadeMock) GetItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItem.beforeGetItemCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItem *mFacadeMockGetItem) Calls() []*FacadeMockGetItemParams {
	mmGetItem.mutex.RLock()

	argCopy := make([]*FacadeMockGetItemParams, len(mmGetItem.callArgs))
	copy(argCopy, mmGetItem.callArgs)

	mmGetItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemDone returns true if the count of the GetItem invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetItemDone() bool {
	if m.GetItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemMock.invocationsDone()
}

// MinimockGetItemInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetItemInspect() {
	for _, e := range m.GetItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemCounter := mm_atomic.LoadUint64(&m.afterGetItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemMock.defaultExpectation != nil && afterGetItemCounter < 1 {
		if m.GetItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetItem at\n%s", m.GetItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetItem at\n%s with params: %#v", m.GetItemMock.defaultExpectation.expectationOrigins.origin, *m.GetItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItem != nil && afterGetItemCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetItem at\n%s", m.funcGetItemOrigin)
	}

	if !m.GetItemMock.invocationsDone() && afterGetItemCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemMock.expectedInvocations), m.GetItemMock.expectedInvocationsOrigin, afterGetItemCounter)
	}
}

type mFacadeMockListOrders struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockListOrdersExpectation
	expectations       []*FacadeMockListOrdersExpectation

	callArgs []*FacadeMockListOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockListOrdersExpectation specifies expectation struct of the Facade.ListOrders
type FacadeMockListOrdersExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockListOrdersParams
	paramPtrs          *FacadeMockListOrdersParamPtrs
	expectationOrigins FacadeMockListOrdersExpectationOrigins
	results            *FacadeMockListOrdersResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockListOrdersParams contains parameters of the Facade.ListOrders
type FacadeMockListOrdersParams struct {
	ctx   context.Context
	id    uint
	inPuP bool
}

// FacadeMockListOrdersParamPtrs contains pointers to parameters of the Facade.ListOrders
type FacadeMockListOrdersParamPtrs struct {
	ctx   *context.Context
	id    *uint
	inPuP *bool
}

// FacadeMockListOrdersResults contains results of the Facade.ListOrders
type FacadeMockListOrdersResults struct {
	oa1 []models.Order
	err error
}

// FacadeMockListOrdersOrigins contains origins of expectations of the Facade.ListOrders
type FacadeMockListOrdersExpectationOrigins struct {
	origin      string
	originCtx   string
	originId    string
	originInPuP string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOrders *mFacadeMockListOrders) Optional() *mFacadeMockListOrders {
	mmListOrders.optional = true
	return mmListOrders
}

// Expect sets up expected params for Facade.ListOrders
func (mmListOrders *mFacadeMockListOrders) Expect(ctx context.Context, id uint, inPuP bool) *mFacadeMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &FacadeMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.paramPtrs != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by ExpectParams functions")
	}

	mmListOrders.defaultExpectation.params = &FacadeMockListOrdersParams{ctx, id, inPuP}
	mmListOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// ExpectCtxParam1 sets up expected param ctx for Facade.ListOrders
func (mmListOrders *mFacadeMockListOrders) ExpectCtxParam1(ctx context.Context) *mFacadeMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &FacadeMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &FacadeMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmListOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListOrders
}

// ExpectIdParam2 sets up expected param id for Facade.ListOrders
func (mmListOrders *mFacadeMockListOrders) ExpectIdParam2(id uint) *mFacadeMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &FacadeMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &FacadeMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.id = &id
	mmListOrders.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmListOrders
}

// ExpectInPuPParam3 sets up expected param inPuP for Facade.ListOrders
func (mmListOrders *mFacadeMockListOrders) ExpectInPuPParam3(inPuP bool) *mFacadeMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &FacadeMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &FacadeMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.inPuP = &inPuP
	mmListOrders.defaultExpectation.expectationOrigins.originInPuP = minimock.CallerInfo(1)

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the Facade.ListOrders
func (mmListOrders *mFacadeMockListOrders) Inspect(f func(ctx context.Context, id uint, inPuP bool)) *mFacadeMockListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for FacadeMock.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by Facade.ListOrders
func (mmListOrders *mFacadeMockListOrders) Return(oa1 []models.Order, err error) *FacadeMock {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &FacadeMockListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &FacadeMockListOrdersResults{oa1, err}
	mmListOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// Set uses given function f to mock the Facade.ListOrders method
func (mmListOrders *mFacadeMockListOrders) Set(f func(ctx context.Context, id uint, inPuP bool) (oa1 []models.Order, err error)) *FacadeMock {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the Facade.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the Facade.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	mmListOrders.mock.funcListOrdersOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// When sets expectation for the Facade.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mFacadeMockListOrders) When(ctx context.Context, id uint, inPuP bool) *FacadeMockListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("FacadeMock.ListOrders mock is already set by Set")
	}

	expectation := &FacadeMockListOrdersExpectation{
		mock:               mmListOrders.mock,
		params:             &FacadeMockListOrdersParams{ctx, id, inPuP},
		expectationOrigins: FacadeMockListOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up Facade.ListOrders return parameters for the expectation previously defined by the When method
func (e *FacadeMockListOrdersExpectation) Then(oa1 []models.Order, err error) *FacadeMock {
	e.results = &FacadeMockListOrdersResults{oa1, err}
	return e.mock
}

// Times sets number of times Facade.ListOrders should be invoked
func (mmListOrders *mFacadeMockListOrders) Times(n uint64) *mFacadeMockListOrders {
	if n == 0 {
		mmListOrders.mock.t.Fatalf("Times of FacadeMock.ListOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOrders.expectedInvocations, n)
	mmListOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListOrders
}

func (mmListOrders *mFacadeMockListOrders) invocationsDone() bool {
	if len(mmListOrders.expectations) == 0 && mmListOrders.defaultExpectation == nil && mmListOrders.mock.funcListOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOrders.mock.afterListOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOrders implements mm_storage.Facade
func (mmListOrders *FacadeMock) ListOrders(ctx context.Context, id uint, inPuP bool) (oa1 []models.Order, err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	mmListOrders.t.Helper()

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx, id, inPuP)
	}

	mm_params := FacadeMockListOrdersParams{ctx, id, inPuP}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmListOrders.ListOrdersMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockListOrdersParams{ctx, id, inPuP}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListOrders.t.Errorf("FacadeMock.ListOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmListOrders.t.Errorf("FacadeMock.ListOrders got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.inPuP != nil && !minimock.Equal(*mm_want_ptrs.inPuP, mm_got.inPuP) {
				mmListOrders.t.Errorf("FacadeMock.ListOrders got unexpected parameter inPuP, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originInPuP, *mm_want_ptrs.inPuP, mm_got.inPuP, minimock.Diff(*mm_want_ptrs.inPuP, mm_got.inPuP))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("FacadeMock.ListOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrders.t.Fatal("No results are set for the FacadeMock.ListOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx, id, inPuP)
	}
	mmListOrders.t.Fatalf("Unexpected call to FacadeMock.ListOrders. %v %v %v", ctx, id, inPuP)
	return
}

// ListOrdersAfterCounter returns a count of finished FacadeMock.ListOrders invocations
func (mmListOrders *FacadeMock) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of FacadeMock.ListOrders invocations
func (mmListOrders *FacadeMock) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mFacadeMockListOrders) Calls() []*FacadeMockListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*FacadeMockListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockListOrdersDone() bool {
	if m.ListOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOrdersMock.invocationsDone()
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *FacadeMock) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.ListOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListOrdersCounter := mm_atomic.LoadUint64(&m.afterListOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && afterListOrdersCounter < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.ListOrders at\n%s", m.ListOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.ListOrders at\n%s with params: %#v", m.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && afterListOrdersCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.ListOrders at\n%s", m.funcListOrdersOrigin)
	}

	if !m.ListOrdersMock.invocationsDone() && afterListOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.ListOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListOrdersMock.expectedInvocations), m.ListOrdersMock.expectedInvocationsOrigin, afterListOrdersCounter)
	}
}

type mFacadeMockListReturns struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockListReturnsExpectation
	expectations       []*FacadeMockListReturnsExpectation

	callArgs []*FacadeMockListReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockListReturnsExpectation specifies expectation struct of the Facade.ListReturns
type FacadeMockListReturnsExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockListReturnsParams
	paramPtrs          *FacadeMockListReturnsParamPtrs
	expectationOrigins FacadeMockListReturnsExpectationOrigins
	results            *FacadeMockListReturnsResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockListReturnsParams contains parameters of the Facade.ListReturns
type FacadeMockListReturnsParams struct {
	ctx   context.Context
	limit int
	page  int
}

// FacadeMockListReturnsParamPtrs contains pointers to parameters of the Facade.ListReturns
type FacadeMockListReturnsParamPtrs struct {
	ctx   *context.Context
	limit *int
	page  *int
}

// FacadeMockListReturnsResults contains results of the Facade.ListReturns
type FacadeMockListReturnsResults struct {
	oa1 []models.Order
	err error
}

// FacadeMockListReturnsOrigins contains origins of expectations of the Facade.ListReturns
type FacadeMockListReturnsExpectationOrigins struct {
	origin      string
	originCtx   string
	originLimit string
	originPage  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReturns *mFacadeMockListReturns) Optional() *mFacadeMockListReturns {
	mmListReturns.optional = true
	return mmListReturns
}

// Expect sets up expected params for Facade.ListReturns
func (mmListReturns *mFacadeMockListReturns) Expect(ctx context.Context, limit int, page int) *mFacadeMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &FacadeMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.paramPtrs != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by ExpectParams functions")
	}

	mmListReturns.defaultExpectation.params = &FacadeMockListReturnsParams{ctx, limit, page}
	mmListReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListReturns.expectations {
		if minimock.Equal(e.params, mmListReturns.defaultExpectation.params) {
			mmListReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturns.defaultExpectation.params)
		}
	}

	return mmListReturns
}

// ExpectCtxParam1 sets up expected param ctx for Facade.ListReturns
func (mmListReturns *mFacadeMockListReturns) ExpectCtxParam1(ctx context.Context) *mFacadeMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &FacadeMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &FacadeMockListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListReturns
}

// ExpectLimitParam2 sets up expected param limit for Facade.ListReturns
func (mmListReturns *mFacadeMockListReturns) ExpectLimitParam2(limit int) *mFacadeMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &FacadeMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &FacadeMockListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.limit = &limit
	mmListReturns.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmListReturns
}

// ExpectPageParam3 sets up expected param page for Facade.ListReturns
func (mmListReturns *mFacadeMockListReturns) ExpectPageParam3(page int) *mFacadeMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &FacadeMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &FacadeMockListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.page = &page
	mmListReturns.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmListReturns
}

// Inspect accepts an inspector function that has same arguments as the Facade.ListReturns
func (mmListReturns *mFacadeMockListReturns) Inspect(f func(ctx context.Context, limit int, page int)) *mFacadeMockListReturns {
	if mmListReturns.mock.inspectFuncListReturns != nil {
		mmListReturns.mock.t.Fatalf("Inspect function is already set for FacadeMock.ListReturns")
	}

	mmListReturns.mock.inspectFuncListReturns = f

	return mmListReturns
}

// Return sets up results that will be returned by Facade.ListReturns
func (mmListReturns *mFacadeMockListReturns) Return(oa1 []models.Order, err error) *FacadeMock {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &FacadeMockListReturnsExpectation{mock: mmListReturns.mock}
	}
	mmListReturns.defaultExpectation.results = &FacadeMockListReturnsResults{oa1, err}
	mmListReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListReturns.mock
}

// Set uses given function f to mock the Facade.ListReturns method
func (mmListReturns *mFacadeMockListReturns) Set(f func(ctx context.Context, limit int, page int) (oa1 []models.Order, err error)) *FacadeMock {
	if mmListReturns.defaultExpectation != nil {
		mmListReturns.mock.t.Fatalf("Default expectation is already set for the Facade.ListReturns method")
	}

	if len(mmListReturns.expectations) > 0 {
		mmListReturns.mock.t.Fatalf("Some expectations are already set for the Facade.ListReturns method")
	}

	mmListReturns.mock.funcListReturns = f
	mmListReturns.mock.funcListReturnsOrigin = minimock.CallerInfo(1)
	return mmListReturns.mock
}

// When sets expectation for the Facade.ListReturns which will trigger the result defined by the following
// Then helper
func (mmListReturns *mFacadeMockListReturns) When(ctx context.Context, limit int, page int) *FacadeMockListReturnsExpectation {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("FacadeMock.ListReturns mock is already set by Set")
	}

	expectation := &FacadeMockListReturnsExpectation{
		mock:               mmListReturns.mock,
		params:             &FacadeMockListReturnsParams{ctx, limit, page},
		expectationOrigins: FacadeMockListReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListReturns.expectations = append(mmListReturns.expectations, expectation)
	return expectation
}

// Then sets up Facade.ListReturns return parameters for the expectation previously defined by the When method
func (e *FacadeMockListReturnsExpectation) Then(oa1 []models.Order, err error) *FacadeMock {
	e.results = &FacadeMockListReturnsResults{oa1, err}
	return e.mock
}

// Times sets number of times Facade.ListReturns should be invoked
func (mmListReturns *mFacadeMockListReturns) Times(n uint64) *mFacadeMockListReturns {
	if n == 0 {
		mmListReturns.mock.t.Fatalf("Times of FacadeMock.ListReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListReturns.expectedInvocations, n)
	mmListReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListReturns
}

func (mmListReturns *mFacadeMockListReturns) invocationsDone() bool {
	if len(mmListReturns.expectations) == 0 && mmListReturns.defaultExpectation == nil && mmListReturns.mock.funcListReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListReturns.mock.afterListReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListReturns implements mm_storage.Facade
func (mmListReturns *FacadeMock) ListReturns(ctx context.Context, limit int, page int) (oa1 []models.Order, err error) {
	mm_atomic.AddUint64(&mmListReturns.beforeListReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmListReturns.afterListReturnsCounter, 1)

	mmListReturns.t.Helper()

	if mmListReturns.inspectFuncListReturns != nil {
		mmListReturns.inspectFuncListReturns(ctx, limit, page)
	}

	mm_params := FacadeMockListReturnsParams{ctx, limit, page}

	// Record call args
	mmListReturns.ListReturnsMock.mutex.Lock()
	mmListReturns.ListReturnsMock.callArgs = append(mmListReturns.ListReturnsMock.callArgs, &mm_params)
	mmListReturns.ListReturnsMock.mutex.Unlock()

	for _, e := range mmListReturns.ListReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListReturns.ListReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReturns.ListReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmListReturns.ListReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmListReturns.ListReturnsMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockListReturnsParams{ctx, limit, page}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListReturns.t.Errorf("FacadeMock.ListReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmListReturns.t.Errorf("FacadeMock.ListReturns got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmListReturns.t.Errorf("FacadeMock.ListReturns got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReturns.t.Errorf("FacadeMock.ListReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReturns.ListReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmListReturns.t.Fatal("No results are set for the FacadeMock.ListReturns")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListReturns.funcListReturns != nil {
		return mmListReturns.funcListReturns(ctx, limit, page)
	}
	mmListReturns.t.Fatalf("Unexpected call to FacadeMock.ListReturns. %v %v %v", ctx, limit, page)
	return
}

// ListReturnsAfterCounter returns a count of finished FacadeMock.ListReturns invocations
func (mmListReturns *FacadeMock) ListReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.afterListReturnsCounter)
}

// ListReturnsBeforeCounter returns a count of FacadeMock.ListReturns invocations
func (mmListReturns *FacadeMock) ListReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.beforeListReturnsCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.ListReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturns *mFacadeMockListReturns) Calls() []*FacadeMockListReturnsParams {
	mmListReturns.mutex.RLock()

	argCopy := make([]*FacadeMockListReturnsParams, len(mmListReturns.callArgs))
	copy(argCopy, mmListReturns.callArgs)

	mmListReturns.mutex.RUnlock()

	return argCopy
}

// MinimockListReturnsDone returns true if the count of the ListReturns invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockListReturnsDone() bool {
	if m.ListReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListReturnsMock.invocationsDone()
}

// MinimockListReturnsInspect logs each unmet expectation
func (m *FacadeMock) MinimockListReturnsInspect() {
	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.ListReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListReturnsCounter := mm_atomic.LoadUint64(&m.afterListReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnsMock.defaultExpectation != nil && afterListReturnsCounter < 1 {
		if m.ListReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.ListReturns at\n%s", m.ListReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.ListReturns at\n%s with params: %#v", m.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *m.ListReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturns != nil && afterListReturnsCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.ListReturns at\n%s", m.funcListReturnsOrigin)
	}

	if !m.ListReturnsMock.invocationsDone() && afterListReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.ListReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListReturnsMock.expectedInvocations), m.ListReturnsMock.expectedInvocationsOrigin, afterListReturnsCounter)
	}
}

type mFacadeMockPlaceOrder struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockPlaceOrderExpectation
	expectations       []*FacadeMockPlaceOrderExpectation

	callArgs []*FacadeMockPlaceOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockPlaceOrderExpectation specifies expectation struct of the Facade.PlaceOrder
type FacadeMockPlaceOrderExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockPlaceOrderParams
	paramPtrs          *FacadeMockPlaceOrderParamPtrs
	expectationOrigins FacadeMockPlaceOrderExpectationOrigins
	results            *FacadeMockPlaceOrderResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockPlaceOrderParams contains parameters of the Facade.PlaceOrder
type FacadeMockPlaceOrderParams struct {
	ctx context.Context
	ids []uint
}

// FacadeMockPlaceOrderParamPtrs contains pointers to parameters of the Facade.PlaceOrder
type FacadeMockPlaceOrderParamPtrs struct {
	ctx *context.Context
	ids *[]uint
}

// FacadeMockPlaceOrderResults contains results of the Facade.PlaceOrder
type FacadeMockPlaceOrderResults struct {
	err error
}

// FacadeMockPlaceOrderOrigins contains origins of expectations of the Facade.PlaceOrder
type FacadeMockPlaceOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPlaceOrder *mFacadeMockPlaceOrder) Optional() *mFacadeMockPlaceOrder {
	mmPlaceOrder.optional = true
	return mmPlaceOrder
}

// Expect sets up expected params for Facade.PlaceOrder
func (mmPlaceOrder *mFacadeMockPlaceOrder) Expect(ctx context.Context, ids []uint) *mFacadeMockPlaceOrder {
	if mmPlaceOrder.mock.funcPlaceOrder != nil {
		mmPlaceOrder.mock.t.Fatalf("FacadeMock.PlaceOrder mock is already set by Set")
	}

	if mmPlaceOrder.defaultExpectation == nil {
		mmPlaceOrder.defaultExpectation = &FacadeMockPlaceOrderExpectation{}
	}

	if mmPlaceOrder.defaultExpectation.paramPtrs != nil {
		mmPlaceOrder.mock.t.Fatalf("FacadeMock.PlaceOrder mock is already set by ExpectParams functions")
	}

	mmPlaceOrder.defaultExpectation.params = &FacadeMockPlaceOrderParams{ctx, ids}
	mmPlaceOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPlaceOrder.expectations {
		if minimock.Equal(e.params, mmPlaceOrder.defaultExpectation.params) {
			mmPlaceOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPlaceOrder.defaultExpectation.params)
		}
	}

	return mmPlaceOrder
}

// ExpectCtxParam1 sets up expected param ctx for Facade.PlaceOrder
func (mmPlaceOrder *mFacadeMockPlaceOrder) ExpectCtxParam1(ctx context.Context) *mFacadeMockPlaceOrder {
	if mmPlaceOrder.mock.funcPlaceOrder != nil {
		mmPlaceOrder.mock.t.Fatalf("FacadeMock.PlaceOrder mock is already set by Set")
	}

	if mmPlaceOrder.defaultExpectation == nil {
		mmPlaceOrder.defaultExpectation = &FacadeMockPlaceOrderExpectation{}
	}

	if mmPlaceOrder.defaultExpectation.params != nil {
		mmPlaceOrder.mock.t.Fatalf("FacadeMock.PlaceOrder mock is already set by Expect")
	}

	if mmPlaceOrder.defaultExpectation.paramPtrs == nil {
		mmPlaceOrder.defaultExpectation.paramPtrs = &FacadeMockPlaceOrderParamPtrs{}
	}
	mmPlaceOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmPlaceOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPlaceOrder
}

// ExpectIdsParam2 sets up expected param ids for Facade.PlaceOrder
func (mmPlaceOrder *mFacadeMockPlaceOrder) ExpectIdsParam2(ids []uint) *mFacadeMockPlaceOrder {
	if mmPlaceOrder.mock.funcPlaceOrder != nil {
		mmPlaceOrder.mock.t.Fatalf("FacadeMock.PlaceOrder mock is already set by Set")
	}

	if mmPlaceOrder.defaultExpectation == nil {
		mmPlaceOrder.defaultExpectation = &FacadeMockPlaceOrderExpectation{}
	}

	if mmPlaceOrder.defaultExpectation.params != nil {
		mmPlaceOrder.mock.t.Fatalf("FacadeMock.PlaceOrder mock is already set by Expect")
	}

	if mmPlaceOrder.defaultExpectation.paramPtrs == nil {
		mmPlaceOrder.defaultExpectation.paramPtrs = &FacadeMockPlaceOrderParamPtrs{}
	}
	mmPlaceOrder.defaultExpectation.paramPtrs.ids = &ids
	mmPlaceOrder.defaultExpectation.expectationOrigins.originIds = minimock.CallerInfo(1)

	return mmPlaceOrder
}

// Inspect accepts an inspector function that has same arguments as the Facade.PlaceOrder
func (mmPlaceOrder *mFacadeMockPlaceOrder) Inspect(f func(ctx context.Context, ids []uint)) *mFacadeMockPlaceOrder {
	if mmPlaceOrder.mock.inspectFuncPlaceOrder != nil {
		mmPlaceOrder.mock.t.Fatalf("Inspect function is already set for FacadeMock.PlaceOrder")
	}

	mmPlaceOrder.mock.inspectFuncPlaceOrder = f

	return mmPlaceOrder
}

// Return sets up results that will be returned by Facade.PlaceOrder
func (mmPlaceOrder *mFacadeMockPlaceOrder) Return(err error) *FacadeMock {
	if mmPlaceOrder.mock.funcPlaceOrder != nil {
		mmPlaceOrder.mock.t.Fatalf("FacadeMock.PlaceOrder mock is already set by Set")
	}

	if mmPlaceOrder.defaultExpectation == nil {
		mmPlaceOrder.defaultExpectation = &FacadeMockPlaceOrderExpectation{mock: mmPlaceOrder.mock}
	}
	mmPlaceOrder.defaultExpectation.results = &FacadeMockPlaceOrderResults{err}
	mmPlaceOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPlaceOrder.mock
}

// Set uses given function f to mock the Facade.PlaceOrder method
func (mmPlaceOrder *mFacadeMockPlaceOrder) Set(f func(ctx context.Context, ids []uint) (err error)) *FacadeMock {
	if mmPlaceOrder.defaultExpectation != nil {
		mmPlaceOrder.mock.t.Fatalf("Default expectation is already set for the Facade.PlaceOrder method")
	}

	if len(mmPlaceOrder.expectations) > 0 {
		mmPlaceOrder.mock.t.Fatalf("Some expectations are already set for the Facade.PlaceOrder method")
	}

	mmPlaceOrder.mock.funcPlaceOrder = f
	mmPlaceOrder.mock.funcPlaceOrderOrigin = minimock.CallerInfo(1)
	return mmPlaceOrder.mock
}

// When sets expectation for the Facade.PlaceOrder which will trigger the result defined by the following
// Then helper
func (mmPlaceOrder *mFacadeMockPlaceOrder) When(ctx context.Context, ids []uint) *FacadeMockPlaceOrderExpectation {
	if mmPlaceOrder.mock.funcPlaceOrder != nil {
		mmPlaceOrder.mock.t.Fatalf("FacadeMock.PlaceOrder mock is already set by Set")
	}

	expectation := &FacadeMockPlaceOrderExpectation{
		mock:               mmPlaceOrder.mock,
		params:             &FacadeMockPlaceOrderParams{ctx, ids},
		expectationOrigins: FacadeMockPlaceOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPlaceOrder.expectations = append(mmPlaceOrder.expectations, expectation)
	return expectation
}

// Then sets up Facade.PlaceOrder return parameters for the expectation previously defined by the When method
func (e *FacadeMockPlaceOrderExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockPlaceOrderResults{err}
	return e.mock
}

// Times sets number of times Facade.PlaceOrder should be invoked
func (mmPlaceOrder *mFacadeMockPlaceOrder) Times(n uint64) *mFacadeMockPlaceOrder {
	if n == 0 {
		mmPlaceOrder.mock.t.Fatalf("Times of FacadeMock.PlaceOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPlaceOrder.expectedInvocations, n)
	mmPlaceOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPlaceOrder
}

func (mmPlaceOrder *mFacadeMockPlaceOrder) invocationsDone() bool {
	if len(mmPlaceOrder.expectations) == 0 && mmPlaceOrder.defaultExpectation == nil && mmPlaceOrder.mock.funcPlaceOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPlaceOrder.mock.afterPlaceOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPlaceOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PlaceOrder implements mm_storage.Facade
func (mmPlaceOrder *FacadeMock) PlaceOrder(ctx context.Context, ids []uint) (err error) {
	mm_atomic.AddUint64(&mmPlaceOrder.beforePlaceOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmPlaceOrder.afterPlaceOrderCounter, 1)

	mmPlaceOrder.t.Helper()

	if mmPlaceOrder.inspectFuncPlaceOrder != nil {
		mmPlaceOrder.inspectFuncPlaceOrder(ctx, ids)
	}

	mm_params := FacadeMockPlaceOrderParams{ctx, ids}

	// Record call args
	mmPlaceOrder.PlaceOrderMock.mutex.Lock()
	mmPlaceOrder.PlaceOrderMock.callArgs = append(mmPlaceOrder.PlaceOrderMock.callArgs, &mm_params)
	mmPlaceOrder.PlaceOrderMock.mutex.Unlock()

	for _, e := range mmPlaceOrder.PlaceOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPlaceOrder.PlaceOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPlaceOrder.PlaceOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmPlaceOrder.PlaceOrderMock.defaultExpectation.params
		mm_want_ptrs := mmPlaceOrder.PlaceOrderMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockPlaceOrderParams{ctx, ids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPlaceOrder.t.Errorf("FacadeMock.PlaceOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPlaceOrder.PlaceOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ids != nil && !minimock.Equal(*mm_want_ptrs.ids, mm_got.ids) {
				mmPlaceOrder.t.Errorf("FacadeMock.PlaceOrder got unexpected parameter ids, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPlaceOrder.PlaceOrderMock.defaultExpectation.expectationOrigins.originIds, *mm_want_ptrs.ids, mm_got.ids, minimock.Diff(*mm_want_ptrs.ids, mm_got.ids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPlaceOrder.t.Errorf("FacadeMock.PlaceOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPlaceOrder.PlaceOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPlaceOrder.PlaceOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmPlaceOrder.t.Fatal("No results are set for the FacadeMock.PlaceOrder")
		}
		return (*mm_results).err
	}
	if mmPlaceOrder.funcPlaceOrder != nil {
		return mmPlaceOrder.funcPlaceOrder(ctx, ids)
	}
	mmPlaceOrder.t.Fatalf("Unexpected call to FacadeMock.PlaceOrder. %v %v", ctx, ids)
	return
}

// PlaceOrderAfterCounter returns a count of finished FacadeMock.PlaceOrder invocations
func (mmPlaceOrder *FacadeMock) PlaceOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPlaceOrder.afterPlaceOrderCounter)
}

// PlaceOrderBeforeCounter returns a count of FacadeMock.PlaceOrder invocations
func (mmPlaceOrder *FacadeMock) PlaceOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPlaceOrder.beforePlaceOrderCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.PlaceOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPlaceOrder *mFacadeMockPlaceOrder) Calls() []*FacadeMockPlaceOrderParams {
	mmPlaceOrder.mutex.RLock()

	argCopy := make([]*FacadeMockPlaceOrderParams, len(mmPlaceOrder.callArgs))
	copy(argCopy, mmPlaceOrder.callArgs)

	mmPlaceOrder.mutex.RUnlock()

	return argCopy
}

// MinimockPlaceOrderDone returns true if the count of the PlaceOrder invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockPlaceOrderDone() bool {
	if m.PlaceOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PlaceOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PlaceOrderMock.invocationsDone()
}

// MinimockPlaceOrderInspect logs each unmet expectation
func (m *FacadeMock) MinimockPlaceOrderInspect() {
	for _, e := range m.PlaceOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.PlaceOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPlaceOrderCounter := mm_atomic.LoadUint64(&m.afterPlaceOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PlaceOrderMock.defaultExpectation != nil && afterPlaceOrderCounter < 1 {
		if m.PlaceOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.PlaceOrder at\n%s", m.PlaceOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.PlaceOrder at\n%s with params: %#v", m.PlaceOrderMock.defaultExpectation.expectationOrigins.origin, *m.PlaceOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPlaceOrder != nil && afterPlaceOrderCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.PlaceOrder at\n%s", m.funcPlaceOrderOrigin)
	}

	if !m.PlaceOrderMock.invocationsDone() && afterPlaceOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.PlaceOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PlaceOrderMock.expectedInvocations), m.PlaceOrderMock.expectedInvocationsOrigin, afterPlaceOrderCounter)
	}
}

type mFacadeMockRefundOrder struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockRefundOrderExpectation
	expectations       []*FacadeMockRefundOrderExpectation

	callArgs []*FacadeMockRefundOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockRefundOrderExpectation specifies expectation struct of the Facade.RefundOrder
type FacadeMockRefundOrderExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockRefundOrderParams
	paramPtrs          *FacadeMockRefundOrderParamPtrs
	expectationOrigins FacadeMockRefundOrderExpectationOrigins
	results            *FacadeMockRefundOrderResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockRefundOrderParams contains parameters of the Facade.RefundOrder
type FacadeMockRefundOrderParams struct {
	ctx    context.Context
	id     uint
	userId uint
}

// FacadeMockRefundOrderParamPtrs contains pointers to parameters of the Facade.RefundOrder
type FacadeMockRefundOrderParamPtrs struct {
	ctx    *context.Context
	id     *uint
	userId *uint
}

// FacadeMockRefundOrderResults contains results of the Facade.RefundOrder
type FacadeMockRefundOrderResults struct {
	err error
}

// FacadeMockRefundOrderOrigins contains origins of expectations of the Facade.RefundOrder
type FacadeMockRefundOrderExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefundOrder *mFacadeMockRefundOrder) Optional() *mFacadeMockRefundOrder {
	mmRefundOrder.optional = true
	return mmRefundOrder
}

// Expect sets up expected params for Facade.RefundOrder
func (mmRefundOrder *mFacadeMockRefundOrder) Expect(ctx context.Context, id uint, userId uint) *mFacadeMockRefundOrder {
	if mmRefundOrder.mock.funcRefundOrder != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Set")
	}

	if mmRefundOrder.defaultExpectation == nil {
		mmRefundOrder.defaultExpectation = &FacadeMockRefundOrderExpectation{}
	}

	if mmRefundOrder.defaultExpectation.paramPtrs != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by ExpectParams functions")
	}

	mmRefundOrder.defaultExpectation.params = &FacadeMockRefundOrderParams{ctx, id, userId}
	mmRefundOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRefundOrder.expectations {
		if minimock.Equal(e.params, mmRefundOrder.defaultExpectation.params) {
			mmRefundOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefundOrder.defaultExpectation.params)
		}
	}

	return mmRefundOrder
}

// ExpectCtxParam1 sets up expected param ctx for Facade.RefundOrder
func (mmRefundOrder *mFacadeMockRefundOrder) ExpectCtxParam1(ctx context.Context) *mFacadeMockRefundOrder {
	if mmRefundOrder.mock.funcRefundOrder != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Set")
	}

	if mmRefundOrder.defaultExpectation == nil {
		mmRefundOrder.defaultExpectation = &FacadeMockRefundOrderExpectation{}
	}

	if mmRefundOrder.defaultExpectation.params != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Expect")
	}

	if mmRefundOrder.defaultExpectation.paramPtrs == nil {
		mmRefundOrder.defaultExpectation.paramPtrs = &FacadeMockRefundOrderParamPtrs{}
	}
	mmRefundOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmRefundOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRefundOrder
}

// ExpectIdParam2 sets up expected param id for Facade.RefundOrder
func (mmRefundOrder *mFacadeMockRefundOrder) ExpectIdParam2(id uint) *mFacadeMockRefundOrder {
	if mmRefundOrder.mock.funcRefundOrder != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Set")
	}

	if mmRefundOrder.defaultExpectation == nil {
		mmRefundOrder.defaultExpectation = &FacadeMockRefundOrderExpectation{}
	}

	if mmRefundOrder.defaultExpectation.params != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Expect")
	}

	if mmRefundOrder.defaultExpectation.paramPtrs == nil {
		mmRefundOrder.defaultExpectation.paramPtrs = &FacadeMockRefundOrderParamPtrs{}
	}
	mmRefundOrder.defaultExpectation.paramPtrs.id = &id
	mmRefundOrder.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmRefundOrder
}

// ExpectUserIdParam3 sets up expected param userId for Facade.RefundOrder
func (mmRefundOrder *mFacadeMockRefundOrder) ExpectUserIdParam3(userId uint) *mFacadeMockRefundOrder {
	if mmRefundOrder.mock.funcRefundOrder != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Set")
	}

	if mmRefundOrder.defaultExpectation == nil {
		mmRefundOrder.defaultExpectation = &FacadeMockRefundOrderExpectation{}
	}

	if mmRefundOrder.defaultExpectation.params != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Expect")
	}

	if mmRefundOrder.defaultExpectation.paramPtrs == nil {
		mmRefundOrder.defaultExpectation.paramPtrs = &FacadeMockRefundOrderParamPtrs{}
	}
	mmRefundOrder.defaultExpectation.paramPtrs.userId = &userId
	mmRefundOrder.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmRefundOrder
}

// Inspect accepts an inspector function that has same arguments as the Facade.RefundOrder
func (mmRefundOrder *mFacadeMockRefundOrder) Inspect(f func(ctx context.Context, id uint, userId uint)) *mFacadeMockRefundOrder {
	if mmRefundOrder.mock.inspectFuncRefundOrder != nil {
		mmRefundOrder.mock.t.Fatalf("Inspect function is already set for FacadeMock.RefundOrder")
	}

	mmRefundOrder.mock.inspectFuncRefundOrder = f

	return mmRefundOrder
}

// Return sets up results that will be returned by Facade.RefundOrder
func (mmRefundOrder *mFacadeMockRefundOrder) Return(err error) *FacadeMock {
	if mmRefundOrder.mock.funcRefundOrder != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Set")
	}

	if mmRefundOrder.defaultExpectation == nil {
		mmRefundOrder.defaultExpectation = &FacadeMockRefundOrderExpectation{mock: mmRefundOrder.mock}
	}
	mmRefundOrder.defaultExpectation.results = &FacadeMockRefundOrderResults{err}
	mmRefundOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRefundOrder.mock
}

// Set uses given function f to mock the Facade.RefundOrder method
func (mmRefundOrder *mFacadeMockRefundOrder) Set(f func(ctx context.Context, id uint, userId uint) (err error)) *FacadeMock {
	if mmRefundOrder.defaultExpectation != nil {
		mmRefundOrder.mock.t.Fatalf("Default expectation is already set for the Facade.RefundOrder method")
	}

	if len(mmRefundOrder.expectations) > 0 {
		mmRefundOrder.mock.t.Fatalf("Some expectations are already set for the Facade.RefundOrder method")
	}

	mmRefundOrder.mock.funcRefundOrder = f
	mmRefundOrder.mock.funcRefundOrderOrigin = minimock.CallerInfo(1)
	return mmRefundOrder.mock
}

// When sets expectation for the Facade.RefundOrder which will trigger the result defined by the following
// Then helper
func (mmRefundOrder *mFacadeMockRefundOrder) When(ctx context.Context, id uint, userId uint) *FacadeMockRefundOrderExpectation {
	if mmRefundOrder.mock.funcRefundOrder != nil {
		mmRefundOrder.mock.t.Fatalf("FacadeMock.RefundOrder mock is already set by Set")
	}

	expectation := &FacadeMockRefundOrderExpectation{
		mock:               mmRefundOrder.mock,
		params:             &FacadeMockRefundOrderParams{ctx, id, userId},
		expectationOrigins: FacadeMockRefundOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRefundOrder.expectations = append(mmRefundOrder.expectations, expectation)
	return expectation
}

// Then sets up Facade.RefundOrder return parameters for the expectation previously defined by the When method
func (e *FacadeMockRefundOrderExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockRefundOrderResults{err}
	return e.mock
}

// Times sets number of times Facade.RefundOrder should be invoked
func (mmRefundOrder *mFacadeMockRefundOrder) Times(n uint64) *mFacadeMockRefundOrder {
	if n == 0 {
		mmRefundOrder.mock.t.Fatalf("Times of FacadeMock.RefundOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefundOrder.expectedInvocations, n)
	mmRefundOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRefundOrder
}

func (mmRefundOrder *mFacadeMockRefundOrder) invocationsDone() bool {
	if len(mmRefundOrder.expectations) == 0 && mmRefundOrder.defaultExpectation == nil && mmRefundOrder.mock.funcRefundOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefundOrder.mock.afterRefundOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefundOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RefundOrder implements mm_storage.Facade
func (mmRefundOrder *FacadeMock) RefundOrder(ctx context.Context, id uint, userId uint) (err error) {
	mm_atomic.AddUint64(&mmRefundOrder.beforeRefundOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmRefundOrder.afterRefundOrderCounter, 1)

	mmRefundOrder.t.Helper()

	if mmRefundOrder.inspectFuncRefundOrder != nil {
		mmRefundOrder.inspectFuncRefundOrder(ctx, id, userId)
	}

	mm_params := FacadeMockRefundOrderParams{ctx, id, userId}

	// Record call args
	mmRefundOrder.RefundOrderMock.mutex.Lock()
	mmRefundOrder.RefundOrderMock.callArgs = append(mmRefundOrder.RefundOrderMock.callArgs, &mm_params)
	mmRefundOrder.RefundOrderMock.mutex.Unlock()

	for _, e := range mmRefundOrder.RefundOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRefundOrder.RefundOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefundOrder.RefundOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmRefundOrder.RefundOrderMock.defaultExpectation.params
		mm_want_ptrs := mmRefundOrder.RefundOrderMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockRefundOrderParams{ctx, id, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRefundOrder.t.Errorf("FacadeMock.RefundOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefundOrder.RefundOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmRefundOrder.t.Errorf("FacadeMock.RefundOrder got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefundOrder.RefundOrderMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRefundOrder.t.Errorf("FacadeMock.RefundOrder got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefundOrder.RefundOrderMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefundOrder.t.Errorf("FacadeMock.RefundOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRefundOrder.RefundOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefundOrder.RefundOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmRefundOrder.t.Fatal("No results are set for the FacadeMock.RefundOrder")
		}
		return (*mm_results).err
	}
	if mmRefundOrder.funcRefundOrder != nil {
		return mmRefundOrder.funcRefundOrder(ctx, id, userId)
	}
	mmRefundOrder.t.Fatalf("Unexpected call to FacadeMock.RefundOrder. %v %v %v", ctx, id, userId)
	return
}

// RefundOrderAfterCounter returns a count of finished FacadeMock.RefundOrder invocations
func (mmRefundOrder *FacadeMock) RefundOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefundOrder.afterRefundOrderCounter)
}

// RefundOrderBeforeCounter returns a count of FacadeMock.RefundOrder invocations
func (mmRefundOrder *FacadeMock) RefundOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefundOrder.beforeRefundOrderCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.RefundOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefundOrder *mFacadeMockRefundOrder) Calls() []*FacadeMockRefundOrderParams {
	mmRefundOrder.mutex.RLock()

	argCopy := make([]*FacadeMockRefundOrderParams, len(mmRefundOrder.callArgs))
	copy(argCopy, mmRefundOrder.callArgs)

	mmRefundOrder.mutex.RUnlock()

	return argCopy
}

// MinimockRefundOrderDone returns true if the count of the RefundOrder invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockRefundOrderDone() bool {
	if m.RefundOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefundOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefundOrderMock.invocationsDone()
}

// MinimockRefundOrderInspect logs each unmet expectation
func (m *FacadeMock) MinimockRefundOrderInspect() {
	for _, e := range m.RefundOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.RefundOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRefundOrderCounter := mm_atomic.LoadUint64(&m.afterRefundOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefundOrderMock.defaultExpectation != nil && afterRefundOrderCounter < 1 {
		if m.RefundOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.RefundOrder at\n%s", m.RefundOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.RefundOrder at\n%s with params: %#v", m.RefundOrderMock.defaultExpectation.expectationOrigins.origin, *m.RefundOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefundOrder != nil && afterRefundOrderCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.RefundOrder at\n%s", m.funcRefundOrderOrigin)
	}

	if !m.RefundOrderMock.invocationsDone() && afterRefundOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.RefundOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RefundOrderMock.expectedInvocations), m.RefundOrderMock.expectedInvocationsOrigin, afterRefundOrderCounter)
	}
}

type mFacadeMockReturnOrder struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockReturnOrderExpectation
	expectations       []*FacadeMockReturnOrderExpectation

	callArgs []*FacadeMockReturnOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockReturnOrderExpectation specifies expectation struct of the Facade.ReturnOrder
type FacadeMockReturnOrderExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockReturnOrderParams
	paramPtrs          *FacadeMockReturnOrderParamPtrs
	expectationOrigins FacadeMockReturnOrderExpectationOrigins
	results            *FacadeMockReturnOrderResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockReturnOrderParams contains parameters of the Facade.ReturnOrder
type FacadeMockReturnOrderParams struct {
	ctx context.Context
	id  uint
}

// FacadeMockReturnOrderParamPtrs contains pointers to parameters of the Facade.ReturnOrder
type FacadeMockReturnOrderParamPtrs struct {
	ctx *context.Context
	id  *uint
}

// FacadeMockReturnOrderResults contains results of the Facade.ReturnOrder
type FacadeMockReturnOrderResults struct {
	err error
}

// FacadeMockReturnOrderOrigins contains origins of expectations of the Facade.ReturnOrder
type FacadeMockReturnOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReturnOrder *mFacadeMockReturnOrder) Optional() *mFacadeMockReturnOrder {
	mmReturnOrder.optional = true
	return mmReturnOrder
}

// Expect sets up expected params for Facade.ReturnOrder
func (mmReturnOrder *mFacadeMockReturnOrder) Expect(ctx context.Context, id uint) *mFacadeMockReturnOrder {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("FacadeMock.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &FacadeMockReturnOrderExpectation{}
	}

	if mmReturnOrder.defaultExpectation.paramPtrs != nil {
		mmReturnOrder.mock.t.Fatalf("FacadeMock.ReturnOrder mock is already set by ExpectParams functions")
	}

	mmReturnOrder.defaultExpectation.params = &FacadeMockReturnOrderParams{ctx, id}
	mmReturnOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReturnOrder.expectations {
		if minimock.Equal(e.params, mmReturnOrder.defaultExpectation.params) {
			mmReturnOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturnOrder.defaultExpectation.params)
		}
	}

	return mmReturnOrder
}

// ExpectCtxParam1 sets up expected param ctx for Facade.ReturnOrder
func (mmReturnOrder *mFacadeMockReturnOrder) ExpectCtxParam1(ctx context.Context) *mFacadeMockReturnOrder {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("FacadeMock.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &FacadeMockReturnOrderExpectation{}
	}

	if mmReturnOrder.defaultExpectation.params != nil {
		mmReturnOrder.mock.t.Fatalf("FacadeMock.ReturnOrder mock is already set by Expect")
	}

	if mmReturnOrder.defaultExpectation.paramPtrs == nil {
		mmReturnOrder.defaultExpectation.paramPtrs = &FacadeMockReturnOrderParamPtrs{}
	}
	mmReturnOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmReturnOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReturnOrder
}

// ExpectIdParam2 sets up expected param id for Facade.ReturnOrder
func (mmReturnOrder *mFacadeMockReturnOrder) ExpectIdParam2(id uint) *mFacadeMockReturnOrder {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("FacadeMock.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &FacadeMockReturnOrderExpectation{}
	}

	if mmReturnOrder.defaultExpectation.params != nil {
		mmReturnOrder.mock.t.Fatalf("FacadeMock.ReturnOrder mock is already set by Expect")
	}

	if mmReturnOrder.defaultExpectation.paramPtrs == nil {
		mmReturnOrder.defaultExpectation.paramPtrs = &FacadeMockReturnOrderParamPtrs{}
	}
	mmReturnOrder.defaultExpectation.paramPtrs.id = &id
	mmReturnOrder.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmReturnOrder
}

// Inspect accepts an inspector function that has same arguments as the Facade.ReturnOrder
func (mmReturnOrder *mFacadeMockReturnOrder) Inspect(f func(ctx context.Context, id uint)) *mFacadeMockReturnOrder {
	if mmReturnOrder.mock.inspectFuncReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Inspect function is already set for FacadeMock.ReturnOrder")
	}

	mmReturnOrder.mock.inspectFuncReturnOrder = f

	return mmReturnOrder
}

// Return sets up results that will be returned by Facade.ReturnOrder
func (mmReturnOrder *mFacadeMockReturnOrder) Return(err error) *FacadeMock {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("FacadeMock.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &FacadeMockReturnOrderExpectation{mock: mmReturnOrder.mock}
	}
	mmReturnOrder.defaultExpectation.results = &FacadeMockReturnOrderResults{err}
	mmReturnOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReturnOrder.mock
}

// Set uses given function f to mock the Facade.ReturnOrder method
func (mmReturnOrder *mFacadeMockReturnOrder) Set(f func(ctx context.Context, id uint) (err error)) *FacadeMock {
	if mmReturnOrder.defaultExpectation != nil {
		mmReturnOrder.mock.t.Fatalf("Default expectation is already set for the Facade.ReturnOrder method")
	}

	if len(mmReturnOrder.expectations) > 0 {
		mmReturnOrder.mock.t.Fatalf("Some expectations are already set for the Facade.ReturnOrder method")
	}

	mmReturnOrder.mock.funcReturnOrder = f
	mmReturnOrder.mock.funcReturnOrderOrigin = minimock.CallerInfo(1)
	return mmReturnOrder.mock
}

// When sets expectation for the Facade.ReturnOrder which will trigger the result defined by the following
// Then helper
func (mmReturnOrder *mFacadeMockReturnOrder) When(ctx context.Context, id uint) *FacadeMockReturnOrderExpectation {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("FacadeMock.ReturnOrder mock is already set by Set")
	}

	expectation := &FacadeMockReturnOrderExpectation{
		mock:               mmReturnOrder.mock,
		params:             &FacadeMockReturnOrderParams{ctx, id},
		expectationOrigins: FacadeMockReturnOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReturnOrder.expectations = append(mmReturnOrder.expectations, expectation)
	return expectation
}

// Then sets up Facade.ReturnOrder return parameters for the expectation previously defined by the When method
func (e *FacadeMockReturnOrderExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockReturnOrderResults{err}
	return e.mock
}

// Times sets number of times Facade.ReturnOrder should be invoked
func (mmReturnOrder *mFacadeMockReturnOrder) Times(n uint64) *mFacadeMockReturnOrder {
	if n == 0 {
		mmReturnOrder.mock.t.Fatalf("Times of FacadeMock.ReturnOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReturnOrder.expectedInvocations, n)
	mmReturnOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReturnOrder
}

func (mmReturnOrder *mFacadeMockReturnOrder) invocationsDone() bool {
	if len(mmReturnOrder.expectations) == 0 && mmReturnOrder.defaultExpectation == nil && mmReturnOrder.mock.funcReturnOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReturnOrder.mock.afterReturnOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReturnOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReturnOrder implements mm_storage.Facade
func (mmReturnOrder *FacadeMock) ReturnOrder(ctx context.Context, id uint) (err error) {
	mm_atomic.AddUint64(&mmReturnOrder.beforeReturnOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmReturnOrder.afterReturnOrderCounter, 1)

	mmReturnOrder.t.Helper()

	if mmReturnOrder.inspectFuncReturnOrder != nil {
		mmReturnOrder.inspectFuncReturnOrder(ctx, id)
	}

	mm_params := FacadeMockReturnOrderParams{ctx, id}

	// Record call args
	mmReturnOrder.ReturnOrderMock.mutex.Lock()
	mmReturnOrder.ReturnOrderMock.callArgs = append(mmReturnOrder.ReturnOrderMock.callArgs, &mm_params)
	mmReturnOrder.ReturnOrderMock.mutex.Unlock()

	for _, e := range mmReturnOrder.ReturnOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReturnOrder.ReturnOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturnOrder.ReturnOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmReturnOrder.ReturnOrderMock.defaultExpectation.params
		mm_want_ptrs := mmReturnOrder.ReturnOrderMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockReturnOrderParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReturnOrder.t.Errorf("FacadeMock.ReturnOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReturnOrder.ReturnOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmReturnOrder.t.Errorf("FacadeMock.ReturnOrder got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReturnOrder.ReturnOrderMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturnOrder.t.Errorf("FacadeMock.ReturnOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReturnOrder.ReturnOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturnOrder.ReturnOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmReturnOrder.t.Fatal("No results are set for the FacadeMock.ReturnOrder")
		}
		return (*mm_results).err
	}
	if mmReturnOrder.funcReturnOrder != nil {
		return mmReturnOrder.funcReturnOrder(ctx, id)
	}
	mmReturnOrder.t.Fatalf("Unexpected call to FacadeMock.ReturnOrder. %v %v", ctx, id)
	return
}

// ReturnOrderAfterCounter returns a count of finished FacadeMock.ReturnOrder invocations
func (mmReturnOrder *FacadeMock) ReturnOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrder.afterReturnOrderCounter)
}

// ReturnOrderBeforeCounter returns a count of FacadeMock.ReturnOrder invocations
func (mmReturnOrder *FacadeMock) ReturnOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrder.beforeReturnOrderCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.ReturnOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturnOrder *mFacadeMockReturnOrder) Calls() []*FacadeMockReturnOrderParams {
	mmReturnOrder.mutex.RLock()

	argCopy := make([]*FacadeMockReturnOrderParams, len(mmReturnOrder.callArgs))
	copy(argCopy, mmReturnOrder.callArgs)

	mmReturnOrder.mutex.RUnlock()

	return argCopy
}

// MinimockReturnOrderDone returns true if the count of the ReturnOrder invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockReturnOrderDone() bool {
	if m.ReturnOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReturnOrderMock.invocationsDone()
}

// MinimockReturnOrderInspect logs each unmet expectation
func (m *FacadeMock) MinimockReturnOrderInspect() {
	for _, e := range m.ReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.ReturnOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReturnOrderCounter := mm_atomic.LoadUint64(&m.afterReturnOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnOrderMock.defaultExpectation != nil && afterReturnOrderCounter < 1 {
		if m.ReturnOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.ReturnOrder at\n%s", m.ReturnOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.ReturnOrder at\n%s with params: %#v", m.ReturnOrderMock.defaultExpectation.expectationOrigins.origin, *m.ReturnOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnOrder != nil && afterReturnOrderCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.ReturnOrder at\n%s", m.funcReturnOrderOrigin)
	}

	if !m.ReturnOrderMock.invocationsDone() && afterReturnOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.ReturnOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReturnOrderMock.expectedInvocations), m.ReturnOrderMock.expectedInvocationsOrigin, afterReturnOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FacadeMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptOrderInspect()

			m.MinimockGetItemInspect()

			m.MinimockListOrdersInspect()

			m.MinimockListReturnsInspect()

			m.MinimockPlaceOrderInspect()

			m.MinimockRefundOrderInspect()

			m.MinimockReturnOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FacadeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FacadeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptOrderDone() &&
		m.MinimockGetItemDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockListReturnsDone() &&
		m.MinimockPlaceOrderDone() &&
		m.MinimockRefundOrderDone() &&
		m.MinimockReturnOrderDone()
}
