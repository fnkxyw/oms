
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitlab.ozon.dev/akugnerevich/homework.git/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">gitlab.ozon.dev/akugnerevich/homework.git/cmd/signals/signal.go (0.0%)</option>
				
				<option value="file2">gitlab.ozon.dev/akugnerevich/homework.git/internal/cli/cli.go (0.0%)</option>
				
				<option value="file3">gitlab.ozon.dev/akugnerevich/homework.git/internal/models/orders.go (100.0%)</option>
				
				<option value="file4">gitlab.ozon.dev/akugnerevich/homework.git/internal/service/controller/controller.go (0.0%)</option>
				
				<option value="file5">gitlab.ozon.dev/akugnerevich/homework.git/internal/service/mocks/order_storage_interface_mock.go (25.6%)</option>
				
				<option value="file6">gitlab.ozon.dev/akugnerevich/homework.git/internal/service/mocks/return_storage_interface_mock.go (19.2%)</option>
				
				<option value="file7">gitlab.ozon.dev/akugnerevich/homework.git/internal/service/orders/orders.go (89.7%)</option>
				
				<option value="file8">gitlab.ozon.dev/akugnerevich/homework.git/internal/service/packing/controller/controller.go (0.0%)</option>
				
				<option value="file9">gitlab.ozon.dev/akugnerevich/homework.git/internal/service/packing/packing.go (0.0%)</option>
				
				<option value="file10">gitlab.ozon.dev/akugnerevich/homework.git/internal/service/pagination/pagination.go (84.4%)</option>
				
				<option value="file11">gitlab.ozon.dev/akugnerevich/homework.git/internal/service/returns/returns.go (100.0%)</option>
				
				<option value="file12">gitlab.ozon.dev/akugnerevich/homework.git/internal/storage/orders.go (0.0%)</option>
				
				<option value="file13">gitlab.ozon.dev/akugnerevich/homework.git/internal/storage/returns.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        signals "gitlab.ozon.dev/akugnerevich/homework.git/cmd/signals"
        c "gitlab.ozon.dev/akugnerevich/homework.git/internal/cli"
        s "gitlab.ozon.dev/akugnerevich/homework.git/internal/storage"
)

func main() <span class="cov0" title="0">{
        orderStorage := s.NewOrderStorage()
        returnStorage := s.NewReturnStorage()
        err := orderStorage.ReadFromJSON()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                err = orderStorage.Create()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        }
        <span class="cov0" title="0">err = returnStorage.ReadFromJSON()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                err = returnStorage.Create()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        }
        <span class="cov0" title="0">signals.SygnalSearch(orderStorage, returnStorage)

        c.Run(orderStorage, returnStorage)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package sygnal

import (
        "fmt"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/storage"
        "os"
        "os/signal"
        "syscall"
)

//файл для ловли сигналов завершения, чтобы не потерять данные

func SygnalSearch(oS storage.OrderStorageInterface, rS storage.ReturnStorageInterface) error <span class="cov0" title="0">{
        signalls := make(chan os.Signal, 1)

        signal.Notify(signalls, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-signalls
                fmt.Println()
                fmt.Println("exit")
                oS.WriteToJSON()
                rS.WriteToJSON()
                os.Exit(1)

        }</span>()
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cli

import (
        "bufio"
        "fmt"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/controller"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/storage"
        "os"
        "strings"
)

var helpText = `
         here is the available set of commands
     help - shows the available commands
     acceptOrder - allows you to take the order from the courier 
     returnOrder - allows you to return the order to the courier
     placeOrder - allow the order to be released to the user
     listOrders - allows you to get a list of orders  
     refundOrder - allows you to accept a return from a user
     listReturns - allows you to get a list of returns 
`

func Run(oS storage.OrderStorageInterface, rS storage.ReturnStorageInterface) error <span class="cov0" title="0">{
        showHelp()

        in := bufio.NewReader(os.Stdin)
        out := bufio.NewWriter(os.Stdout)
        defer out.Flush()

        for </span><span class="cov0" title="0">{
                fmt.Fprint(out, "&gt;")
                if err := out.Flush(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">input, _ := readInput(in)

                switch input </span>{
                case "exit":<span class="cov0" title="0">
                        oS.WriteToJSON()
                        rS.WriteToJSON()
                        return nil</span>
                case "acceptOrder":<span class="cov0" title="0">
                        handleErr(controller.WAcceptOrder(oS))</span>
                case "returnOrder":<span class="cov0" title="0">
                        handleErr(controller.WReturnOrder(oS))</span>
                case "placeOrder":<span class="cov0" title="0">
                        handleErr(controller.WPlaceOrder(oS))</span>
                case "listOrders":<span class="cov0" title="0">
                        handleErr(controller.WListOrders(oS))</span>
                case "refundOrder":<span class="cov0" title="0">
                        handleErr(controller.WRefundOrder(rS, oS))</span>
                case "listReturns":<span class="cov0" title="0">
                        handleErr(controller.WListReturns(rS))</span>
                case "help":<span class="cov0" title="0">
                        showHelp()</span>
                default:<span class="cov0" title="0">
                        fmt.Fprintln(out, "Unknown command")</span>
                }
        }
}

func readInput(in *bufio.Reader) (string, error) <span class="cov0" title="0">{
        var input string
        if _, err := fmt.Fscanln(in, &amp;input); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(input), nil</span>
}

func handleErr(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Correct!")
        }</span>
}
func showHelp() error <span class="cov0" title="0">{
        fmt.Println(helpText)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "time"
)

func (o *Order) CanReturned() error <span class="cov8" title="1">{
        if o.State == ReturnedState || (o.KeepUntilDate.Before(time.Now()) &amp;&amp; o.State == AcceptState) </span><span class="cov8" title="1">{
                o.State = SoftDelete
        }</span> else<span class="cov8" title="1"> {
                return ErrCanReturned
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "bufio"
        "fmt"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
        e "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/errors"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/orders"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/packing"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/returns"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/storage"
        "log"
        "os"
        "strconv"
        "strings"
        "time"
)

//Файл с обертками для организации входа данных

func WAcceptOrder(s storage.OrderStorageInterface) error <span class="cov0" title="0">{

        var order models.Order
        var pacakgeType string
        fmt.Println("Input OrderID _ UserID _ Date(form[2024-12(m)-12(d)])")
        fmt.Print("&gt;")

        var dateString string
        _, err := fmt.Scan(&amp;order.ID, &amp;order.UserID, &amp;dateString)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Input api Err: %w\n", err)
        }</span>
        <span class="cov0" title="0">if s.IsConsist(order.ID) </span><span class="cov0" title="0">{
                return e.ErrIsConsist
        }</span>

        <span class="cov0" title="0">order.KeepUntilDate, err = time.Parse("2006-01-02", dateString)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Date parse Err: %w\n", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Input weight[kg], price[₽], package type [box, bundle, wrap]")
        fmt.Print("&gt;")
        fmt.Scan(&amp;order.Weight, &amp;order.Price, &amp;pacakgeType)

        err = packing.Packing(&amp;order, pacakgeType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = orders.AcceptOrder(s, &amp;order)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

func WReturnOrder(s storage.OrderStorageInterface) error <span class="cov0" title="0">{
        var id uint
        fmt.Println("Input OrderID")
        fmt.Print("&gt;")
        fmt.Scan(&amp;id)
        if !s.IsConsist(id) </span><span class="cov0" title="0">{
                return e.ErrNoConsist
        }</span>
        <span class="cov0" title="0">err := orders.ReturnOrder(s, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func WPlaceOrder(s storage.OrderStorageInterface) error <span class="cov0" title="0">{
        fmt.Println("Input all IDs that you want to place")
        fmt.Print("&gt;")
        var temp string
        reader := bufio.NewReader(os.Stdin)
        temp, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">data := strings.Fields(temp)
        var uintdata []uint
        for _, v := range data </span><span class="cov0" title="0">{

                uval, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Wrong conv id in PlaceOrder")
                        return err
                }</span>
                <span class="cov0" title="0">if !s.IsConsist(uint(uval)) </span><span class="cov0" title="0">{
                        return e.ErrNoConsist
                }</span>
                <span class="cov0" title="0">uintdata = append(uintdata, uint(uval))</span>
        }
        <span class="cov0" title="0">err = orders.PlaceOrder(s, uintdata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func WListOrders(s storage.OrderStorageInterface) error <span class="cov0" title="0">{
        var (
                id   uint
                n    int
                temp int
        )
        fmt.Println("Input UserID")
        fmt.Print("&gt;")
        fmt.Scan(&amp;id)
        fmt.Println("1.List all orders witch consists on our PuP\n" +
                "2.List last N orders")
        fmt.Print("&gt;")
        fmt.Scan(&amp;temp)
        switch temp </span>{
        case 1:<span class="cov0" title="0">
                err := orders.ListOrders(s, id, 0, true)
                return err</span>
        case 2:<span class="cov0" title="0">
                fmt.Println("Input n")
                fmt.Print("&gt;")
                fmt.Scan(&amp;n)
                err := orders.ListOrders(s, id, n, false)
                return err</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func WRefundOrder(rS storage.ReturnStorageInterface, oS storage.OrderStorageInterface) error <span class="cov0" title="0">{
        fmt.Println("Input OrderID and UserId")
        fmt.Print("&gt;")
        var (
                orderId uint
                userdId uint
        )
        fmt.Scan(&amp;orderId, &amp;userdId)
        err := returns.RefundOrder(rS, oS, orderId, userdId)
        return err
}</span>

func WListReturns(rs storage.ReturnStorageInterface) error <span class="cov0" title="0">{
        fmt.Println("Input max Returns on one page and Page")
        var (
                limit int
                page  int
        )
        fmt.Print("&gt;")
        fmt.Scan(&amp;limit, &amp;page)

        return returns.ListReturns(rs, limit, page)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i gitlab.ozon.dev/akugnerevich/homework.git/internal/storage.OrderStorageInterface -o order_storage_interface_mock_test.go -n OrderStorageInterfaceMock -p mocks

import (
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
)

// OrderStorageInterfaceMock implements mm_storage.OrderStorageInterface
type OrderStorageInterfaceMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAddOrderToStorage          func(or *models.Order)
        funcAddOrderToStorageOrigin    string
        inspectFuncAddOrderToStorage   func(or *models.Order)
        afterAddOrderToStorageCounter  uint64
        beforeAddOrderToStorageCounter uint64
        AddOrderToStorageMock          mOrderStorageInterfaceMockAddOrderToStorage

        funcDeleteOrderFromStorage          func(id uint)
        funcDeleteOrderFromStorageOrigin    string
        inspectFuncDeleteOrderFromStorage   func(id uint)
        afterDeleteOrderFromStorageCounter  uint64
        beforeDeleteOrderFromStorageCounter uint64
        DeleteOrderFromStorageMock          mOrderStorageInterfaceMockDeleteOrderFromStorage

        funcGetOrder          func(id uint) (op1 *models.Order, b1 bool)
        funcGetOrderOrigin    string
        inspectFuncGetOrder   func(id uint)
        afterGetOrderCounter  uint64
        beforeGetOrderCounter uint64
        GetOrderMock          mOrderStorageInterfaceMockGetOrder

        funcGetOrderIDs          func() (ua1 []uint)
        funcGetOrderIDsOrigin    string
        inspectFuncGetOrderIDs   func()
        afterGetOrderIDsCounter  uint64
        beforeGetOrderIDsCounter uint64
        GetOrderIDsMock          mOrderStorageInterfaceMockGetOrderIDs

        funcIsConsist          func(id uint) (b1 bool)
        funcIsConsistOrigin    string
        inspectFuncIsConsist   func(id uint)
        afterIsConsistCounter  uint64
        beforeIsConsistCounter uint64
        IsConsistMock          mOrderStorageInterfaceMockIsConsist

        funcReadFromJSON          func() (err error)
        funcReadFromJSONOrigin    string
        inspectFuncReadFromJSON   func()
        afterReadFromJSONCounter  uint64
        beforeReadFromJSONCounter uint64
        ReadFromJSONMock          mOrderStorageInterfaceMockReadFromJSON

        funcWriteToJSON          func() (err error)
        funcWriteToJSONOrigin    string
        inspectFuncWriteToJSON   func()
        afterWriteToJSONCounter  uint64
        beforeWriteToJSONCounter uint64
        WriteToJSONMock          mOrderStorageInterfaceMockWriteToJSON
}

// NewOrderStorageInterfaceMock returns a mock for mm_storage.OrderStorageInterface
func NewOrderStorageInterfaceMock(t minimock.Tester) *OrderStorageInterfaceMock <span class="cov8" title="1">{
        m := &amp;OrderStorageInterfaceMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.AddOrderToStorageMock = mOrderStorageInterfaceMockAddOrderToStorage{mock: m}
        m.AddOrderToStorageMock.callArgs = []*OrderStorageInterfaceMockAddOrderToStorageParams{}

        m.DeleteOrderFromStorageMock = mOrderStorageInterfaceMockDeleteOrderFromStorage{mock: m}
        m.DeleteOrderFromStorageMock.callArgs = []*OrderStorageInterfaceMockDeleteOrderFromStorageParams{}

        m.GetOrderMock = mOrderStorageInterfaceMockGetOrder{mock: m}
        m.GetOrderMock.callArgs = []*OrderStorageInterfaceMockGetOrderParams{}

        m.GetOrderIDsMock = mOrderStorageInterfaceMockGetOrderIDs{mock: m}

        m.IsConsistMock = mOrderStorageInterfaceMockIsConsist{mock: m}
        m.IsConsistMock.callArgs = []*OrderStorageInterfaceMockIsConsistParams{}

        m.ReadFromJSONMock = mOrderStorageInterfaceMockReadFromJSON{mock: m}

        m.WriteToJSONMock = mOrderStorageInterfaceMockWriteToJSON{mock: m}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mOrderStorageInterfaceMockAddOrderToStorage struct {
        optional           bool
        mock               *OrderStorageInterfaceMock
        defaultExpectation *OrderStorageInterfaceMockAddOrderToStorageExpectation
        expectations       []*OrderStorageInterfaceMockAddOrderToStorageExpectation

        callArgs []*OrderStorageInterfaceMockAddOrderToStorageParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockAddOrderToStorageExpectation specifies expectation struct of the OrderStorageInterface.AddOrderToStorage
type OrderStorageInterfaceMockAddOrderToStorageExpectation struct {
        mock               *OrderStorageInterfaceMock
        params             *OrderStorageInterfaceMockAddOrderToStorageParams
        paramPtrs          *OrderStorageInterfaceMockAddOrderToStorageParamPtrs
        expectationOrigins OrderStorageInterfaceMockAddOrderToStorageExpectationOrigins

        returnOrigin string
        Counter      uint64
}

// OrderStorageInterfaceMockAddOrderToStorageParams contains parameters of the OrderStorageInterface.AddOrderToStorage
type OrderStorageInterfaceMockAddOrderToStorageParams struct {
        or *models.Order
}

// OrderStorageInterfaceMockAddOrderToStorageParamPtrs contains pointers to parameters of the OrderStorageInterface.AddOrderToStorage
type OrderStorageInterfaceMockAddOrderToStorageParamPtrs struct {
        or **models.Order
}

// OrderStorageInterfaceMockAddOrderToStorageOrigins contains origins of expectations of the OrderStorageInterface.AddOrderToStorage
type OrderStorageInterfaceMockAddOrderToStorageExpectationOrigins struct {
        origin   string
        originOr string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Optional() *mOrderStorageInterfaceMockAddOrderToStorage <span class="cov0" title="0">{
        mmAddOrderToStorage.optional = true
        return mmAddOrderToStorage
}</span>

// Expect sets up expected params for OrderStorageInterface.AddOrderToStorage
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Expect(or *models.Order) *mOrderStorageInterfaceMockAddOrderToStorage <span class="cov8" title="1">{
        if mmAddOrderToStorage.mock.funcAddOrderToStorage != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmAddOrderToStorage.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmAddOrderToStorage.defaultExpectation = &amp;OrderStorageInterfaceMockAddOrderToStorageExpectation{}
        }</span>

        <span class="cov8" title="1">if mmAddOrderToStorage.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmAddOrderToStorage.defaultExpectation.params = &amp;OrderStorageInterfaceMockAddOrderToStorageParams{or}
        mmAddOrderToStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmAddOrderToStorage.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAddOrderToStorage.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAddOrderToStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrderToStorage.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmAddOrderToStorage</span>
}

// ExpectOrParam1 sets up expected param or for OrderStorageInterface.AddOrderToStorage
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) ExpectOrParam1(or *models.Order) *mOrderStorageInterfaceMockAddOrderToStorage <span class="cov0" title="0">{
        if mmAddOrderToStorage.mock.funcAddOrderToStorage != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddOrderToStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.defaultExpectation = &amp;OrderStorageInterfaceMockAddOrderToStorageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddOrderToStorage.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddOrderToStorage.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.defaultExpectation.paramPtrs = &amp;OrderStorageInterfaceMockAddOrderToStorageParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddOrderToStorage.defaultExpectation.paramPtrs.or = &amp;or
        mmAddOrderToStorage.defaultExpectation.expectationOrigins.originOr = minimock.CallerInfo(1)

        return mmAddOrderToStorage</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.AddOrderToStorage
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Inspect(f func(or *models.Order)) *mOrderStorageInterfaceMockAddOrderToStorage <span class="cov0" title="0">{
        if mmAddOrderToStorage.mock.inspectFuncAddOrderToStorage != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.AddOrderToStorage")
        }</span>

        <span class="cov0" title="0">mmAddOrderToStorage.mock.inspectFuncAddOrderToStorage = f

        return mmAddOrderToStorage</span>
}

// Return sets up results that will be returned by OrderStorageInterface.AddOrderToStorage
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Return() *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmAddOrderToStorage.mock.funcAddOrderToStorage != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("OrderStorageInterfaceMock.AddOrderToStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddOrderToStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.defaultExpectation = &amp;OrderStorageInterfaceMockAddOrderToStorageExpectation{mock: mmAddOrderToStorage.mock}
        }</span>

        <span class="cov0" title="0">mmAddOrderToStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmAddOrderToStorage.mock</span>
}

// Set uses given function f to mock the OrderStorageInterface.AddOrderToStorage method
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Set(f func(or *models.Order)) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmAddOrderToStorage.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.AddOrderToStorage method")
        }</span>

        <span class="cov0" title="0">if len(mmAddOrderToStorage.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.AddOrderToStorage method")
        }</span>

        <span class="cov0" title="0">mmAddOrderToStorage.mock.funcAddOrderToStorage = f
        mmAddOrderToStorage.mock.funcAddOrderToStorageOrigin = minimock.CallerInfo(1)
        return mmAddOrderToStorage.mock</span>
}

// Times sets number of times OrderStorageInterface.AddOrderToStorage should be invoked
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Times(n uint64) *mOrderStorageInterfaceMockAddOrderToStorage <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAddOrderToStorage.mock.t.Fatalf("Times of OrderStorageInterfaceMock.AddOrderToStorage mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAddOrderToStorage.expectedInvocations, n)
        mmAddOrderToStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmAddOrderToStorage</span>
}

func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmAddOrderToStorage.expectations) == 0 &amp;&amp; mmAddOrderToStorage.defaultExpectation == nil &amp;&amp; mmAddOrderToStorage.mock.funcAddOrderToStorage == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmAddOrderToStorage.mock.afterAddOrderToStorageCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAddOrderToStorage.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// AddOrderToStorage implements mm_storage.OrderStorageInterface
func (mmAddOrderToStorage *OrderStorageInterfaceMock) AddOrderToStorage(or *models.Order) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmAddOrderToStorage.beforeAddOrderToStorageCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAddOrderToStorage.afterAddOrderToStorageCounter, 1)

        mmAddOrderToStorage.t.Helper()

        if mmAddOrderToStorage.inspectFuncAddOrderToStorage != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.inspectFuncAddOrderToStorage(or)
        }</span>

        <span class="cov8" title="1">mm_params := OrderStorageInterfaceMockAddOrderToStorageParams{or}

        // Record call args
        mmAddOrderToStorage.AddOrderToStorageMock.mutex.Lock()
        mmAddOrderToStorage.AddOrderToStorageMock.callArgs = append(mmAddOrderToStorage.AddOrderToStorageMock.callArgs, &amp;mm_params)
        mmAddOrderToStorage.AddOrderToStorageMock.mutex.Unlock()

        for _, e := range mmAddOrderToStorage.AddOrderToStorageMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return
                }</span>
        }

        <span class="cov8" title="1">if mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.Counter, 1)
                mm_want := mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.params
                mm_want_ptrs := mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.paramPtrs

                mm_got := OrderStorageInterfaceMockAddOrderToStorageParams{or}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.or != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.or, mm_got.or) </span><span class="cov0" title="0">{
                                mmAddOrderToStorage.t.Errorf("OrderStorageInterfaceMock.AddOrderToStorage got unexpected parameter or, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.expectationOrigins.originOr, *mm_want_ptrs.or, mm_got.or, minimock.Diff(*mm_want_ptrs.or, mm_got.or))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAddOrderToStorage.t.Errorf("OrderStorageInterfaceMock.AddOrderToStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmAddOrderToStorage.AddOrderToStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">return</span>

        }
        <span class="cov0" title="0">if mmAddOrderToStorage.funcAddOrderToStorage != nil </span><span class="cov0" title="0">{
                mmAddOrderToStorage.funcAddOrderToStorage(or)
                return
        }</span>
        <span class="cov0" title="0">mmAddOrderToStorage.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.AddOrderToStorage. %v", or)</span>

}

// AddOrderToStorageAfterCounter returns a count of finished OrderStorageInterfaceMock.AddOrderToStorage invocations
func (mmAddOrderToStorage *OrderStorageInterfaceMock) AddOrderToStorageAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddOrderToStorage.afterAddOrderToStorageCounter)
}</span>

// AddOrderToStorageBeforeCounter returns a count of OrderStorageInterfaceMock.AddOrderToStorage invocations
func (mmAddOrderToStorage *OrderStorageInterfaceMock) AddOrderToStorageBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddOrderToStorage.beforeAddOrderToStorageCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderStorageInterfaceMock.AddOrderToStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrderToStorage *mOrderStorageInterfaceMockAddOrderToStorage) Calls() []*OrderStorageInterfaceMockAddOrderToStorageParams <span class="cov0" title="0">{
        mmAddOrderToStorage.mutex.RLock()

        argCopy := make([]*OrderStorageInterfaceMockAddOrderToStorageParams, len(mmAddOrderToStorage.callArgs))
        copy(argCopy, mmAddOrderToStorage.callArgs)

        mmAddOrderToStorage.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddOrderToStorageDone returns true if the count of the AddOrderToStorage invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockAddOrderToStorageDone() bool <span class="cov8" title="1">{
        if m.AddOrderToStorageMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.AddOrderToStorageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.AddOrderToStorageMock.invocationsDone()</span>
}

// MinimockAddOrderToStorageInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockAddOrderToStorageInspect() <span class="cov0" title="0">{
        for _, e := range m.AddOrderToStorageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.AddOrderToStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddOrderToStorageCounter := mm_atomic.LoadUint64(&amp;m.afterAddOrderToStorageCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddOrderToStorageMock.defaultExpectation != nil &amp;&amp; afterAddOrderToStorageCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddOrderToStorageMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.AddOrderToStorage at\n%s", m.AddOrderToStorageMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.AddOrderToStorage at\n%s with params: %#v", m.AddOrderToStorageMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderToStorageMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAddOrderToStorage != nil &amp;&amp; afterAddOrderToStorageCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.AddOrderToStorage at\n%s", m.funcAddOrderToStorageOrigin)
        }</span>

        <span class="cov0" title="0">if !m.AddOrderToStorageMock.invocationsDone() &amp;&amp; afterAddOrderToStorageCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.AddOrderToStorage at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddOrderToStorageMock.expectedInvocations), m.AddOrderToStorageMock.expectedInvocationsOrigin, afterAddOrderToStorageCounter)
        }</span>
}

type mOrderStorageInterfaceMockDeleteOrderFromStorage struct {
        optional           bool
        mock               *OrderStorageInterfaceMock
        defaultExpectation *OrderStorageInterfaceMockDeleteOrderFromStorageExpectation
        expectations       []*OrderStorageInterfaceMockDeleteOrderFromStorageExpectation

        callArgs []*OrderStorageInterfaceMockDeleteOrderFromStorageParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockDeleteOrderFromStorageExpectation specifies expectation struct of the OrderStorageInterface.DeleteOrderFromStorage
type OrderStorageInterfaceMockDeleteOrderFromStorageExpectation struct {
        mock               *OrderStorageInterfaceMock
        params             *OrderStorageInterfaceMockDeleteOrderFromStorageParams
        paramPtrs          *OrderStorageInterfaceMockDeleteOrderFromStorageParamPtrs
        expectationOrigins OrderStorageInterfaceMockDeleteOrderFromStorageExpectationOrigins

        returnOrigin string
        Counter      uint64
}

// OrderStorageInterfaceMockDeleteOrderFromStorageParams contains parameters of the OrderStorageInterface.DeleteOrderFromStorage
type OrderStorageInterfaceMockDeleteOrderFromStorageParams struct {
        id uint
}

// OrderStorageInterfaceMockDeleteOrderFromStorageParamPtrs contains pointers to parameters of the OrderStorageInterface.DeleteOrderFromStorage
type OrderStorageInterfaceMockDeleteOrderFromStorageParamPtrs struct {
        id *uint
}

// OrderStorageInterfaceMockDeleteOrderFromStorageOrigins contains origins of expectations of the OrderStorageInterface.DeleteOrderFromStorage
type OrderStorageInterfaceMockDeleteOrderFromStorageExpectationOrigins struct {
        origin   string
        originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Optional() *mOrderStorageInterfaceMockDeleteOrderFromStorage <span class="cov0" title="0">{
        mmDeleteOrderFromStorage.optional = true
        return mmDeleteOrderFromStorage
}</span>

// Expect sets up expected params for OrderStorageInterface.DeleteOrderFromStorage
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Expect(id uint) *mOrderStorageInterfaceMockDeleteOrderFromStorage <span class="cov0" title="0">{
        if mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteOrderFromStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.defaultExpectation = &amp;OrderStorageInterfaceMockDeleteOrderFromStorageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteOrderFromStorage.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmDeleteOrderFromStorage.defaultExpectation.params = &amp;OrderStorageInterfaceMockDeleteOrderFromStorageParams{id}
        mmDeleteOrderFromStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmDeleteOrderFromStorage.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteOrderFromStorage.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteOrderFromStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrderFromStorage.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmDeleteOrderFromStorage</span>
}

// ExpectIdParam1 sets up expected param id for OrderStorageInterface.DeleteOrderFromStorage
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) ExpectIdParam1(id uint) *mOrderStorageInterfaceMockDeleteOrderFromStorage <span class="cov0" title="0">{
        if mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteOrderFromStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.defaultExpectation = &amp;OrderStorageInterfaceMockDeleteOrderFromStorageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteOrderFromStorage.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteOrderFromStorage.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.defaultExpectation.paramPtrs = &amp;OrderStorageInterfaceMockDeleteOrderFromStorageParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteOrderFromStorage.defaultExpectation.paramPtrs.id = &amp;id
        mmDeleteOrderFromStorage.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmDeleteOrderFromStorage</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.DeleteOrderFromStorage
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Inspect(f func(id uint)) *mOrderStorageInterfaceMockDeleteOrderFromStorage <span class="cov0" title="0">{
        if mmDeleteOrderFromStorage.mock.inspectFuncDeleteOrderFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.DeleteOrderFromStorage")
        }</span>

        <span class="cov0" title="0">mmDeleteOrderFromStorage.mock.inspectFuncDeleteOrderFromStorage = f

        return mmDeleteOrderFromStorage</span>
}

// Return sets up results that will be returned by OrderStorageInterface.DeleteOrderFromStorage
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Return() *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("OrderStorageInterfaceMock.DeleteOrderFromStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteOrderFromStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.defaultExpectation = &amp;OrderStorageInterfaceMockDeleteOrderFromStorageExpectation{mock: mmDeleteOrderFromStorage.mock}
        }</span>

        <span class="cov0" title="0">mmDeleteOrderFromStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmDeleteOrderFromStorage.mock</span>
}

// Set uses given function f to mock the OrderStorageInterface.DeleteOrderFromStorage method
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Set(f func(id uint)) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmDeleteOrderFromStorage.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.DeleteOrderFromStorage method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteOrderFromStorage.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.DeleteOrderFromStorage method")
        }</span>

        <span class="cov0" title="0">mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage = f
        mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorageOrigin = minimock.CallerInfo(1)
        return mmDeleteOrderFromStorage.mock</span>
}

// Times sets number of times OrderStorageInterface.DeleteOrderFromStorage should be invoked
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Times(n uint64) *mOrderStorageInterfaceMockDeleteOrderFromStorage <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.mock.t.Fatalf("Times of OrderStorageInterfaceMock.DeleteOrderFromStorage mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteOrderFromStorage.expectedInvocations, n)
        mmDeleteOrderFromStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmDeleteOrderFromStorage</span>
}

func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmDeleteOrderFromStorage.expectations) == 0 &amp;&amp; mmDeleteOrderFromStorage.defaultExpectation == nil &amp;&amp; mmDeleteOrderFromStorage.mock.funcDeleteOrderFromStorage == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteOrderFromStorage.mock.afterDeleteOrderFromStorageCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteOrderFromStorage.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteOrderFromStorage implements mm_storage.OrderStorageInterface
func (mmDeleteOrderFromStorage *OrderStorageInterfaceMock) DeleteOrderFromStorage(id uint) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmDeleteOrderFromStorage.beforeDeleteOrderFromStorageCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteOrderFromStorage.afterDeleteOrderFromStorageCounter, 1)

        mmDeleteOrderFromStorage.t.Helper()

        if mmDeleteOrderFromStorage.inspectFuncDeleteOrderFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.inspectFuncDeleteOrderFromStorage(id)
        }</span>

        <span class="cov0" title="0">mm_params := OrderStorageInterfaceMockDeleteOrderFromStorageParams{id}

        // Record call args
        mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.mutex.Lock()
        mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.callArgs = append(mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.callArgs, &amp;mm_params)
        mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.mutex.Unlock()

        for _, e := range mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return
                }</span>
        }

        <span class="cov0" title="0">if mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.paramPtrs

                mm_got := OrderStorageInterfaceMockDeleteOrderFromStorageParams{id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDeleteOrderFromStorage.t.Errorf("OrderStorageInterfaceMock.DeleteOrderFromStorage got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteOrderFromStorage.t.Errorf("OrderStorageInterfaceMock.DeleteOrderFromStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmDeleteOrderFromStorage.DeleteOrderFromStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">return</span>

        }
        <span class="cov0" title="0">if mmDeleteOrderFromStorage.funcDeleteOrderFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteOrderFromStorage.funcDeleteOrderFromStorage(id)
                return
        }</span>
        <span class="cov0" title="0">mmDeleteOrderFromStorage.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.DeleteOrderFromStorage. %v", id)</span>

}

// DeleteOrderFromStorageAfterCounter returns a count of finished OrderStorageInterfaceMock.DeleteOrderFromStorage invocations
func (mmDeleteOrderFromStorage *OrderStorageInterfaceMock) DeleteOrderFromStorageAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteOrderFromStorage.afterDeleteOrderFromStorageCounter)
}</span>

// DeleteOrderFromStorageBeforeCounter returns a count of OrderStorageInterfaceMock.DeleteOrderFromStorage invocations
func (mmDeleteOrderFromStorage *OrderStorageInterfaceMock) DeleteOrderFromStorageBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteOrderFromStorage.beforeDeleteOrderFromStorageCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderStorageInterfaceMock.DeleteOrderFromStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrderFromStorage *mOrderStorageInterfaceMockDeleteOrderFromStorage) Calls() []*OrderStorageInterfaceMockDeleteOrderFromStorageParams <span class="cov0" title="0">{
        mmDeleteOrderFromStorage.mutex.RLock()

        argCopy := make([]*OrderStorageInterfaceMockDeleteOrderFromStorageParams, len(mmDeleteOrderFromStorage.callArgs))
        copy(argCopy, mmDeleteOrderFromStorage.callArgs)

        mmDeleteOrderFromStorage.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteOrderFromStorageDone returns true if the count of the DeleteOrderFromStorage invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockDeleteOrderFromStorageDone() bool <span class="cov8" title="1">{
        if m.DeleteOrderFromStorageMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.DeleteOrderFromStorageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.DeleteOrderFromStorageMock.invocationsDone()</span>
}

// MinimockDeleteOrderFromStorageInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockDeleteOrderFromStorageInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteOrderFromStorageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteOrderFromStorageCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteOrderFromStorageCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteOrderFromStorageMock.defaultExpectation != nil &amp;&amp; afterDeleteOrderFromStorageCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteOrderFromStorageMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s", m.DeleteOrderFromStorageMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s with params: %#v", m.DeleteOrderFromStorageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrderFromStorageMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteOrderFromStorage != nil &amp;&amp; afterDeleteOrderFromStorageCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s", m.funcDeleteOrderFromStorageOrigin)
        }</span>

        <span class="cov0" title="0">if !m.DeleteOrderFromStorageMock.invocationsDone() &amp;&amp; afterDeleteOrderFromStorageCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.DeleteOrderFromStorage at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteOrderFromStorageMock.expectedInvocations), m.DeleteOrderFromStorageMock.expectedInvocationsOrigin, afterDeleteOrderFromStorageCounter)
        }</span>
}

type mOrderStorageInterfaceMockGetOrder struct {
        optional           bool
        mock               *OrderStorageInterfaceMock
        defaultExpectation *OrderStorageInterfaceMockGetOrderExpectation
        expectations       []*OrderStorageInterfaceMockGetOrderExpectation

        callArgs []*OrderStorageInterfaceMockGetOrderParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockGetOrderExpectation specifies expectation struct of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderExpectation struct {
        mock               *OrderStorageInterfaceMock
        params             *OrderStorageInterfaceMockGetOrderParams
        paramPtrs          *OrderStorageInterfaceMockGetOrderParamPtrs
        expectationOrigins OrderStorageInterfaceMockGetOrderExpectationOrigins
        results            *OrderStorageInterfaceMockGetOrderResults
        returnOrigin       string
        Counter            uint64
}

// OrderStorageInterfaceMockGetOrderParams contains parameters of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderParams struct {
        id uint
}

// OrderStorageInterfaceMockGetOrderParamPtrs contains pointers to parameters of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderParamPtrs struct {
        id *uint
}

// OrderStorageInterfaceMockGetOrderResults contains results of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderResults struct {
        op1 *models.Order
        b1  bool
}

// OrderStorageInterfaceMockGetOrderOrigins contains origins of expectations of the OrderStorageInterface.GetOrder
type OrderStorageInterfaceMockGetOrderExpectationOrigins struct {
        origin   string
        originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Optional() *mOrderStorageInterfaceMockGetOrder <span class="cov0" title="0">{
        mmGetOrder.optional = true
        return mmGetOrder
}</span>

// Expect sets up expected params for OrderStorageInterface.GetOrder
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Expect(id uint) *mOrderStorageInterfaceMockGetOrder <span class="cov8" title="1">{
        if mmGetOrder.mock.funcGetOrder != nil </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetOrder.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmGetOrder.defaultExpectation = &amp;OrderStorageInterfaceMockGetOrderExpectation{}
        }</span>

        <span class="cov8" title="1">if mmGetOrder.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmGetOrder.defaultExpectation.params = &amp;OrderStorageInterfaceMockGetOrderParams{id}
        mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetOrder.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmGetOrder</span>
}

// ExpectIdParam1 sets up expected param id for OrderStorageInterface.GetOrder
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) ExpectIdParam1(id uint) *mOrderStorageInterfaceMockGetOrder <span class="cov0" title="0">{
        if mmGetOrder.mock.funcGetOrder != nil </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetOrder.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetOrder.defaultExpectation = &amp;OrderStorageInterfaceMockGetOrderExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetOrder.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetOrder.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetOrder.defaultExpectation.paramPtrs = &amp;OrderStorageInterfaceMockGetOrderParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetOrder.defaultExpectation.paramPtrs.id = &amp;id
        mmGetOrder.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmGetOrder</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.GetOrder
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Inspect(f func(id uint)) *mOrderStorageInterfaceMockGetOrder <span class="cov0" title="0">{
        if mmGetOrder.mock.inspectFuncGetOrder != nil </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.GetOrder")
        }</span>

        <span class="cov0" title="0">mmGetOrder.mock.inspectFuncGetOrder = f

        return mmGetOrder</span>
}

// Return sets up results that will be returned by OrderStorageInterface.GetOrder
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Return(op1 *models.Order, b1 bool) *OrderStorageInterfaceMock <span class="cov8" title="1">{
        if mmGetOrder.mock.funcGetOrder != nil </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetOrder.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetOrder.defaultExpectation = &amp;OrderStorageInterfaceMockGetOrderExpectation{mock: mmGetOrder.mock}
        }</span>
        <span class="cov8" title="1">mmGetOrder.defaultExpectation.results = &amp;OrderStorageInterfaceMockGetOrderResults{op1, b1}
        mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetOrder.mock</span>
}

// Set uses given function f to mock the OrderStorageInterface.GetOrder method
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Set(f func(id uint) (op1 *models.Order, b1 bool)) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmGetOrder.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.GetOrder method")
        }</span>

        <span class="cov0" title="0">if len(mmGetOrder.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.GetOrder method")
        }</span>

        <span class="cov0" title="0">mmGetOrder.mock.funcGetOrder = f
        mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
        return mmGetOrder.mock</span>
}

// When sets expectation for the OrderStorageInterface.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) When(id uint) *OrderStorageInterfaceMockGetOrderExpectation <span class="cov0" title="0">{
        if mmGetOrder.mock.funcGetOrder != nil </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrder mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderStorageInterfaceMockGetOrderExpectation{
                mock:               mmGetOrder.mock,
                params:             &amp;OrderStorageInterfaceMockGetOrderParams{id},
                expectationOrigins: OrderStorageInterfaceMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderStorageInterface.GetOrder return parameters for the expectation previously defined by the When method
func (e *OrderStorageInterfaceMockGetOrderExpectation) Then(op1 *models.Order, b1 bool) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        e.results = &amp;OrderStorageInterfaceMockGetOrderResults{op1, b1}
        return e.mock
}</span>

// Times sets number of times OrderStorageInterface.GetOrder should be invoked
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Times(n uint64) *mOrderStorageInterfaceMockGetOrder <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetOrder.mock.t.Fatalf("Times of OrderStorageInterfaceMock.GetOrder mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetOrder.expectedInvocations, n)
        mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetOrder</span>
}

func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetOrder.expectations) == 0 &amp;&amp; mmGetOrder.defaultExpectation == nil &amp;&amp; mmGetOrder.mock.funcGetOrder == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetOrder.mock.afterGetOrderCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetOrder.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetOrder implements mm_storage.OrderStorageInterface
func (mmGetOrder *OrderStorageInterfaceMock) GetOrder(id uint) (op1 *models.Order, b1 bool) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmGetOrder.beforeGetOrderCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetOrder.afterGetOrderCounter, 1)

        mmGetOrder.t.Helper()

        if mmGetOrder.inspectFuncGetOrder != nil </span><span class="cov0" title="0">{
                mmGetOrder.inspectFuncGetOrder(id)
        }</span>

        <span class="cov8" title="1">mm_params := OrderStorageInterfaceMockGetOrderParams{id}

        // Record call args
        mmGetOrder.GetOrderMock.mutex.Lock()
        mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &amp;mm_params)
        mmGetOrder.GetOrderMock.mutex.Unlock()

        for _, e := range mmGetOrder.GetOrderMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.op1, e.results.b1
                }</span>
        }

        <span class="cov8" title="1">if mmGetOrder.GetOrderMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
                mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
                mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

                mm_got := OrderStorageInterfaceMockGetOrderParams{id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmGetOrder.t.Errorf("OrderStorageInterfaceMock.GetOrder got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetOrder.t.Errorf("OrderStorageInterfaceMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetOrder.t.Fatal("No results are set for the OrderStorageInterfaceMock.GetOrder")
                }</span>
                <span class="cov8" title="1">return (*mm_results).op1, (*mm_results).b1</span>
        }
        <span class="cov0" title="0">if mmGetOrder.funcGetOrder != nil </span><span class="cov0" title="0">{
                return mmGetOrder.funcGetOrder(id)
        }</span>
        <span class="cov0" title="0">mmGetOrder.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.GetOrder. %v", id)
        return</span>
}

// GetOrderAfterCounter returns a count of finished OrderStorageInterfaceMock.GetOrder invocations
func (mmGetOrder *OrderStorageInterfaceMock) GetOrderAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetOrder.afterGetOrderCounter)
}</span>

// GetOrderBeforeCounter returns a count of OrderStorageInterfaceMock.GetOrder invocations
func (mmGetOrder *OrderStorageInterfaceMock) GetOrderBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetOrder.beforeGetOrderCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderStorageInterfaceMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mOrderStorageInterfaceMockGetOrder) Calls() []*OrderStorageInterfaceMockGetOrderParams <span class="cov0" title="0">{
        mmGetOrder.mutex.RLock()

        argCopy := make([]*OrderStorageInterfaceMockGetOrderParams, len(mmGetOrder.callArgs))
        copy(argCopy, mmGetOrder.callArgs)

        mmGetOrder.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockGetOrderDone() bool <span class="cov8" title="1">{
        if m.GetOrderMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetOrderMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetOrderMock.invocationsDone()</span>
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockGetOrderInspect() <span class="cov0" title="0">{
        for _, e := range m.GetOrderMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetOrderCounter := mm_atomic.LoadUint64(&amp;m.afterGetOrderCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetOrderMock.defaultExpectation != nil &amp;&amp; afterGetOrderCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetOrderMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetOrder != nil &amp;&amp; afterGetOrderCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrder at\n%s", m.funcGetOrderOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetOrderMock.invocationsDone() &amp;&amp; afterGetOrderCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.GetOrder at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
        }</span>
}

type mOrderStorageInterfaceMockGetOrderIDs struct {
        optional           bool
        mock               *OrderStorageInterfaceMock
        defaultExpectation *OrderStorageInterfaceMockGetOrderIDsExpectation
        expectations       []*OrderStorageInterfaceMockGetOrderIDsExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockGetOrderIDsExpectation specifies expectation struct of the OrderStorageInterface.GetOrderIDs
type OrderStorageInterfaceMockGetOrderIDsExpectation struct {
        mock *OrderStorageInterfaceMock

        results      *OrderStorageInterfaceMockGetOrderIDsResults
        returnOrigin string
        Counter      uint64
}

// OrderStorageInterfaceMockGetOrderIDsResults contains results of the OrderStorageInterface.GetOrderIDs
type OrderStorageInterfaceMockGetOrderIDsResults struct {
        ua1 []uint
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Optional() *mOrderStorageInterfaceMockGetOrderIDs <span class="cov0" title="0">{
        mmGetOrderIDs.optional = true
        return mmGetOrderIDs
}</span>

// Expect sets up expected params for OrderStorageInterface.GetOrderIDs
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Expect() *mOrderStorageInterfaceMockGetOrderIDs <span class="cov8" title="1">{
        if mmGetOrderIDs.mock.funcGetOrderIDs != nil </span><span class="cov0" title="0">{
                mmGetOrderIDs.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrderIDs mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetOrderIDs.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmGetOrderIDs.defaultExpectation = &amp;OrderStorageInterfaceMockGetOrderIDsExpectation{}
        }</span>

        <span class="cov8" title="1">return mmGetOrderIDs</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.GetOrderIDs
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Inspect(f func()) *mOrderStorageInterfaceMockGetOrderIDs <span class="cov0" title="0">{
        if mmGetOrderIDs.mock.inspectFuncGetOrderIDs != nil </span><span class="cov0" title="0">{
                mmGetOrderIDs.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.GetOrderIDs")
        }</span>

        <span class="cov0" title="0">mmGetOrderIDs.mock.inspectFuncGetOrderIDs = f

        return mmGetOrderIDs</span>
}

// Return sets up results that will be returned by OrderStorageInterface.GetOrderIDs
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Return(ua1 []uint) *OrderStorageInterfaceMock <span class="cov8" title="1">{
        if mmGetOrderIDs.mock.funcGetOrderIDs != nil </span><span class="cov0" title="0">{
                mmGetOrderIDs.mock.t.Fatalf("OrderStorageInterfaceMock.GetOrderIDs mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetOrderIDs.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetOrderIDs.defaultExpectation = &amp;OrderStorageInterfaceMockGetOrderIDsExpectation{mock: mmGetOrderIDs.mock}
        }</span>
        <span class="cov8" title="1">mmGetOrderIDs.defaultExpectation.results = &amp;OrderStorageInterfaceMockGetOrderIDsResults{ua1}
        mmGetOrderIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetOrderIDs.mock</span>
}

// Set uses given function f to mock the OrderStorageInterface.GetOrderIDs method
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Set(f func() (ua1 []uint)) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmGetOrderIDs.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetOrderIDs.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.GetOrderIDs method")
        }</span>

        <span class="cov0" title="0">if len(mmGetOrderIDs.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetOrderIDs.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.GetOrderIDs method")
        }</span>

        <span class="cov0" title="0">mmGetOrderIDs.mock.funcGetOrderIDs = f
        mmGetOrderIDs.mock.funcGetOrderIDsOrigin = minimock.CallerInfo(1)
        return mmGetOrderIDs.mock</span>
}

// Times sets number of times OrderStorageInterface.GetOrderIDs should be invoked
func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) Times(n uint64) *mOrderStorageInterfaceMockGetOrderIDs <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetOrderIDs.mock.t.Fatalf("Times of OrderStorageInterfaceMock.GetOrderIDs mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetOrderIDs.expectedInvocations, n)
        mmGetOrderIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetOrderIDs</span>
}

func (mmGetOrderIDs *mOrderStorageInterfaceMockGetOrderIDs) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetOrderIDs.expectations) == 0 &amp;&amp; mmGetOrderIDs.defaultExpectation == nil &amp;&amp; mmGetOrderIDs.mock.funcGetOrderIDs == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetOrderIDs.mock.afterGetOrderIDsCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetOrderIDs.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetOrderIDs implements mm_storage.OrderStorageInterface
func (mmGetOrderIDs *OrderStorageInterfaceMock) GetOrderIDs() (ua1 []uint) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmGetOrderIDs.beforeGetOrderIDsCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetOrderIDs.afterGetOrderIDsCounter, 1)

        mmGetOrderIDs.t.Helper()

        if mmGetOrderIDs.inspectFuncGetOrderIDs != nil </span><span class="cov0" title="0">{
                mmGetOrderIDs.inspectFuncGetOrderIDs()
        }</span>

        <span class="cov8" title="1">if mmGetOrderIDs.GetOrderIDsMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmGetOrderIDs.GetOrderIDsMock.defaultExpectation.Counter, 1)

                mm_results := mmGetOrderIDs.GetOrderIDsMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetOrderIDs.t.Fatal("No results are set for the OrderStorageInterfaceMock.GetOrderIDs")
                }</span>
                <span class="cov8" title="1">return (*mm_results).ua1</span>
        }
        <span class="cov0" title="0">if mmGetOrderIDs.funcGetOrderIDs != nil </span><span class="cov0" title="0">{
                return mmGetOrderIDs.funcGetOrderIDs()
        }</span>
        <span class="cov0" title="0">mmGetOrderIDs.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.GetOrderIDs.")
        return</span>
}

// GetOrderIDsAfterCounter returns a count of finished OrderStorageInterfaceMock.GetOrderIDs invocations
func (mmGetOrderIDs *OrderStorageInterfaceMock) GetOrderIDsAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetOrderIDs.afterGetOrderIDsCounter)
}</span>

// GetOrderIDsBeforeCounter returns a count of OrderStorageInterfaceMock.GetOrderIDs invocations
func (mmGetOrderIDs *OrderStorageInterfaceMock) GetOrderIDsBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetOrderIDs.beforeGetOrderIDsCounter)
}</span>

// MinimockGetOrderIDsDone returns true if the count of the GetOrderIDs invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockGetOrderIDsDone() bool <span class="cov8" title="1">{
        if m.GetOrderIDsMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetOrderIDsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetOrderIDsMock.invocationsDone()</span>
}

// MinimockGetOrderIDsInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockGetOrderIDsInspect() <span class="cov0" title="0">{
        for _, e := range m.GetOrderIDsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to OrderStorageInterfaceMock.GetOrderIDs")
                }</span>
        }

        <span class="cov0" title="0">afterGetOrderIDsCounter := mm_atomic.LoadUint64(&amp;m.afterGetOrderIDsCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetOrderIDsMock.defaultExpectation != nil &amp;&amp; afterGetOrderIDsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrderIDs at\n%s", m.GetOrderIDsMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetOrderIDs != nil &amp;&amp; afterGetOrderIDsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.GetOrderIDs at\n%s", m.funcGetOrderIDsOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetOrderIDsMock.invocationsDone() &amp;&amp; afterGetOrderIDsCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.GetOrderIDs at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetOrderIDsMock.expectedInvocations), m.GetOrderIDsMock.expectedInvocationsOrigin, afterGetOrderIDsCounter)
        }</span>
}

type mOrderStorageInterfaceMockIsConsist struct {
        optional           bool
        mock               *OrderStorageInterfaceMock
        defaultExpectation *OrderStorageInterfaceMockIsConsistExpectation
        expectations       []*OrderStorageInterfaceMockIsConsistExpectation

        callArgs []*OrderStorageInterfaceMockIsConsistParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockIsConsistExpectation specifies expectation struct of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistExpectation struct {
        mock               *OrderStorageInterfaceMock
        params             *OrderStorageInterfaceMockIsConsistParams
        paramPtrs          *OrderStorageInterfaceMockIsConsistParamPtrs
        expectationOrigins OrderStorageInterfaceMockIsConsistExpectationOrigins
        results            *OrderStorageInterfaceMockIsConsistResults
        returnOrigin       string
        Counter            uint64
}

// OrderStorageInterfaceMockIsConsistParams contains parameters of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistParams struct {
        id uint
}

// OrderStorageInterfaceMockIsConsistParamPtrs contains pointers to parameters of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistParamPtrs struct {
        id *uint
}

// OrderStorageInterfaceMockIsConsistResults contains results of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistResults struct {
        b1 bool
}

// OrderStorageInterfaceMockIsConsistOrigins contains origins of expectations of the OrderStorageInterface.IsConsist
type OrderStorageInterfaceMockIsConsistExpectationOrigins struct {
        origin   string
        originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Optional() *mOrderStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        mmIsConsist.optional = true
        return mmIsConsist
}</span>

// Expect sets up expected params for OrderStorageInterface.IsConsist
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Expect(id uint) *mOrderStorageInterfaceMockIsConsist <span class="cov8" title="1">{
        if mmIsConsist.mock.funcIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmIsConsist.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmIsConsist.defaultExpectation = &amp;OrderStorageInterfaceMockIsConsistExpectation{}
        }</span>

        <span class="cov8" title="1">if mmIsConsist.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmIsConsist.defaultExpectation.params = &amp;OrderStorageInterfaceMockIsConsistParams{id}
        mmIsConsist.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmIsConsist.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmIsConsist.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmIsConsist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsConsist.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmIsConsist</span>
}

// ExpectIdParam1 sets up expected param id for OrderStorageInterface.IsConsist
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) ExpectIdParam1(id uint) *mOrderStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        if mmIsConsist.mock.funcIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsConsist.defaultExpectation = &amp;OrderStorageInterfaceMockIsConsistExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmIsConsist.defaultExpectation.paramPtrs = &amp;OrderStorageInterfaceMockIsConsistParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmIsConsist.defaultExpectation.paramPtrs.id = &amp;id
        mmIsConsist.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmIsConsist</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.IsConsist
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Inspect(f func(id uint)) *mOrderStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        if mmIsConsist.mock.inspectFuncIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.IsConsist")
        }</span>

        <span class="cov0" title="0">mmIsConsist.mock.inspectFuncIsConsist = f

        return mmIsConsist</span>
}

// Return sets up results that will be returned by OrderStorageInterface.IsConsist
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Return(b1 bool) *OrderStorageInterfaceMock <span class="cov8" title="1">{
        if mmIsConsist.mock.funcIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmIsConsist.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsConsist.defaultExpectation = &amp;OrderStorageInterfaceMockIsConsistExpectation{mock: mmIsConsist.mock}
        }</span>
        <span class="cov8" title="1">mmIsConsist.defaultExpectation.results = &amp;OrderStorageInterfaceMockIsConsistResults{b1}
        mmIsConsist.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmIsConsist.mock</span>
}

// Set uses given function f to mock the OrderStorageInterface.IsConsist method
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Set(f func(id uint) (b1 bool)) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmIsConsist.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.IsConsist method")
        }</span>

        <span class="cov0" title="0">if len(mmIsConsist.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.IsConsist method")
        }</span>

        <span class="cov0" title="0">mmIsConsist.mock.funcIsConsist = f
        mmIsConsist.mock.funcIsConsistOrigin = minimock.CallerInfo(1)
        return mmIsConsist.mock</span>
}

// When sets expectation for the OrderStorageInterface.IsConsist which will trigger the result defined by the following
// Then helper
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) When(id uint) *OrderStorageInterfaceMockIsConsistExpectation <span class="cov0" title="0">{
        if mmIsConsist.mock.funcIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("OrderStorageInterfaceMock.IsConsist mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderStorageInterfaceMockIsConsistExpectation{
                mock:               mmIsConsist.mock,
                params:             &amp;OrderStorageInterfaceMockIsConsistParams{id},
                expectationOrigins: OrderStorageInterfaceMockIsConsistExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmIsConsist.expectations = append(mmIsConsist.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderStorageInterface.IsConsist return parameters for the expectation previously defined by the When method
func (e *OrderStorageInterfaceMockIsConsistExpectation) Then(b1 bool) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        e.results = &amp;OrderStorageInterfaceMockIsConsistResults{b1}
        return e.mock
}</span>

// Times sets number of times OrderStorageInterface.IsConsist should be invoked
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Times(n uint64) *mOrderStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("Times of OrderStorageInterfaceMock.IsConsist mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmIsConsist.expectedInvocations, n)
        mmIsConsist.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmIsConsist</span>
}

func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmIsConsist.expectations) == 0 &amp;&amp; mmIsConsist.defaultExpectation == nil &amp;&amp; mmIsConsist.mock.funcIsConsist == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmIsConsist.mock.afterIsConsistCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmIsConsist.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// IsConsist implements mm_storage.OrderStorageInterface
func (mmIsConsist *OrderStorageInterfaceMock) IsConsist(id uint) (b1 bool) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmIsConsist.beforeIsConsistCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmIsConsist.afterIsConsistCounter, 1)

        mmIsConsist.t.Helper()

        if mmIsConsist.inspectFuncIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.inspectFuncIsConsist(id)
        }</span>

        <span class="cov8" title="1">mm_params := OrderStorageInterfaceMockIsConsistParams{id}

        // Record call args
        mmIsConsist.IsConsistMock.mutex.Lock()
        mmIsConsist.IsConsistMock.callArgs = append(mmIsConsist.IsConsistMock.callArgs, &amp;mm_params)
        mmIsConsist.IsConsistMock.mutex.Unlock()

        for _, e := range mmIsConsist.IsConsistMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.b1
                }</span>
        }

        <span class="cov8" title="1">if mmIsConsist.IsConsistMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmIsConsist.IsConsistMock.defaultExpectation.Counter, 1)
                mm_want := mmIsConsist.IsConsistMock.defaultExpectation.params
                mm_want_ptrs := mmIsConsist.IsConsistMock.defaultExpectation.paramPtrs

                mm_got := OrderStorageInterfaceMockIsConsistParams{id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmIsConsist.t.Errorf("OrderStorageInterfaceMock.IsConsist got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmIsConsist.IsConsistMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmIsConsist.t.Errorf("OrderStorageInterfaceMock.IsConsist got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmIsConsist.IsConsistMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmIsConsist.IsConsistMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmIsConsist.t.Fatal("No results are set for the OrderStorageInterfaceMock.IsConsist")
                }</span>
                <span class="cov8" title="1">return (*mm_results).b1</span>
        }
        <span class="cov0" title="0">if mmIsConsist.funcIsConsist != nil </span><span class="cov0" title="0">{
                return mmIsConsist.funcIsConsist(id)
        }</span>
        <span class="cov0" title="0">mmIsConsist.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.IsConsist. %v", id)
        return</span>
}

// IsConsistAfterCounter returns a count of finished OrderStorageInterfaceMock.IsConsist invocations
func (mmIsConsist *OrderStorageInterfaceMock) IsConsistAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIsConsist.afterIsConsistCounter)
}</span>

// IsConsistBeforeCounter returns a count of OrderStorageInterfaceMock.IsConsist invocations
func (mmIsConsist *OrderStorageInterfaceMock) IsConsistBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIsConsist.beforeIsConsistCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderStorageInterfaceMock.IsConsist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsConsist *mOrderStorageInterfaceMockIsConsist) Calls() []*OrderStorageInterfaceMockIsConsistParams <span class="cov0" title="0">{
        mmIsConsist.mutex.RLock()

        argCopy := make([]*OrderStorageInterfaceMockIsConsistParams, len(mmIsConsist.callArgs))
        copy(argCopy, mmIsConsist.callArgs)

        mmIsConsist.mutex.RUnlock()

        return argCopy
}</span>

// MinimockIsConsistDone returns true if the count of the IsConsist invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockIsConsistDone() bool <span class="cov8" title="1">{
        if m.IsConsistMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.IsConsistMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.IsConsistMock.invocationsDone()</span>
}

// MinimockIsConsistInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockIsConsistInspect() <span class="cov0" title="0">{
        for _, e := range m.IsConsistMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.IsConsist at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterIsConsistCounter := mm_atomic.LoadUint64(&amp;m.afterIsConsistCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.IsConsistMock.defaultExpectation != nil &amp;&amp; afterIsConsistCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.IsConsistMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.IsConsist at\n%s", m.IsConsistMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderStorageInterfaceMock.IsConsist at\n%s with params: %#v", m.IsConsistMock.defaultExpectation.expectationOrigins.origin, *m.IsConsistMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcIsConsist != nil &amp;&amp; afterIsConsistCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.IsConsist at\n%s", m.funcIsConsistOrigin)
        }</span>

        <span class="cov0" title="0">if !m.IsConsistMock.invocationsDone() &amp;&amp; afterIsConsistCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.IsConsist at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.IsConsistMock.expectedInvocations), m.IsConsistMock.expectedInvocationsOrigin, afterIsConsistCounter)
        }</span>
}

type mOrderStorageInterfaceMockReadFromJSON struct {
        optional           bool
        mock               *OrderStorageInterfaceMock
        defaultExpectation *OrderStorageInterfaceMockReadFromJSONExpectation
        expectations       []*OrderStorageInterfaceMockReadFromJSONExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockReadFromJSONExpectation specifies expectation struct of the OrderStorageInterface.ReadFromJSON
type OrderStorageInterfaceMockReadFromJSONExpectation struct {
        mock *OrderStorageInterfaceMock

        results      *OrderStorageInterfaceMockReadFromJSONResults
        returnOrigin string
        Counter      uint64
}

// OrderStorageInterfaceMockReadFromJSONResults contains results of the OrderStorageInterface.ReadFromJSON
type OrderStorageInterfaceMockReadFromJSONResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Optional() *mOrderStorageInterfaceMockReadFromJSON <span class="cov0" title="0">{
        mmReadFromJSON.optional = true
        return mmReadFromJSON
}</span>

// Expect sets up expected params for OrderStorageInterface.ReadFromJSON
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Expect() *mOrderStorageInterfaceMockReadFromJSON <span class="cov0" title="0">{
        if mmReadFromJSON.mock.funcReadFromJSON != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("OrderStorageInterfaceMock.ReadFromJSON mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmReadFromJSON.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmReadFromJSON.defaultExpectation = &amp;OrderStorageInterfaceMockReadFromJSONExpectation{}
        }</span>

        <span class="cov0" title="0">return mmReadFromJSON</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.ReadFromJSON
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Inspect(f func()) *mOrderStorageInterfaceMockReadFromJSON <span class="cov0" title="0">{
        if mmReadFromJSON.mock.inspectFuncReadFromJSON != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.ReadFromJSON")
        }</span>

        <span class="cov0" title="0">mmReadFromJSON.mock.inspectFuncReadFromJSON = f

        return mmReadFromJSON</span>
}

// Return sets up results that will be returned by OrderStorageInterface.ReadFromJSON
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Return(err error) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmReadFromJSON.mock.funcReadFromJSON != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("OrderStorageInterfaceMock.ReadFromJSON mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmReadFromJSON.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmReadFromJSON.defaultExpectation = &amp;OrderStorageInterfaceMockReadFromJSONExpectation{mock: mmReadFromJSON.mock}
        }</span>
        <span class="cov0" title="0">mmReadFromJSON.defaultExpectation.results = &amp;OrderStorageInterfaceMockReadFromJSONResults{err}
        mmReadFromJSON.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmReadFromJSON.mock</span>
}

// Set uses given function f to mock the OrderStorageInterface.ReadFromJSON method
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Set(f func() (err error)) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmReadFromJSON.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.ReadFromJSON method")
        }</span>

        <span class="cov0" title="0">if len(mmReadFromJSON.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.ReadFromJSON method")
        }</span>

        <span class="cov0" title="0">mmReadFromJSON.mock.funcReadFromJSON = f
        mmReadFromJSON.mock.funcReadFromJSONOrigin = minimock.CallerInfo(1)
        return mmReadFromJSON.mock</span>
}

// Times sets number of times OrderStorageInterface.ReadFromJSON should be invoked
func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) Times(n uint64) *mOrderStorageInterfaceMockReadFromJSON <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("Times of OrderStorageInterfaceMock.ReadFromJSON mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmReadFromJSON.expectedInvocations, n)
        mmReadFromJSON.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmReadFromJSON</span>
}

func (mmReadFromJSON *mOrderStorageInterfaceMockReadFromJSON) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmReadFromJSON.expectations) == 0 &amp;&amp; mmReadFromJSON.defaultExpectation == nil &amp;&amp; mmReadFromJSON.mock.funcReadFromJSON == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmReadFromJSON.mock.afterReadFromJSONCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmReadFromJSON.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ReadFromJSON implements mm_storage.OrderStorageInterface
func (mmReadFromJSON *OrderStorageInterfaceMock) ReadFromJSON() (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmReadFromJSON.beforeReadFromJSONCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmReadFromJSON.afterReadFromJSONCounter, 1)

        mmReadFromJSON.t.Helper()

        if mmReadFromJSON.inspectFuncReadFromJSON != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.inspectFuncReadFromJSON()
        }</span>

        <span class="cov0" title="0">if mmReadFromJSON.ReadFromJSONMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmReadFromJSON.ReadFromJSONMock.defaultExpectation.Counter, 1)

                mm_results := mmReadFromJSON.ReadFromJSONMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmReadFromJSON.t.Fatal("No results are set for the OrderStorageInterfaceMock.ReadFromJSON")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmReadFromJSON.funcReadFromJSON != nil </span><span class="cov0" title="0">{
                return mmReadFromJSON.funcReadFromJSON()
        }</span>
        <span class="cov0" title="0">mmReadFromJSON.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.ReadFromJSON.")
        return</span>
}

// ReadFromJSONAfterCounter returns a count of finished OrderStorageInterfaceMock.ReadFromJSON invocations
func (mmReadFromJSON *OrderStorageInterfaceMock) ReadFromJSONAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmReadFromJSON.afterReadFromJSONCounter)
}</span>

// ReadFromJSONBeforeCounter returns a count of OrderStorageInterfaceMock.ReadFromJSON invocations
func (mmReadFromJSON *OrderStorageInterfaceMock) ReadFromJSONBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmReadFromJSON.beforeReadFromJSONCounter)
}</span>

// MinimockReadFromJSONDone returns true if the count of the ReadFromJSON invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockReadFromJSONDone() bool <span class="cov8" title="1">{
        if m.ReadFromJSONMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.ReadFromJSONMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.ReadFromJSONMock.invocationsDone()</span>
}

// MinimockReadFromJSONInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockReadFromJSONInspect() <span class="cov0" title="0">{
        for _, e := range m.ReadFromJSONMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to OrderStorageInterfaceMock.ReadFromJSON")
                }</span>
        }

        <span class="cov0" title="0">afterReadFromJSONCounter := mm_atomic.LoadUint64(&amp;m.afterReadFromJSONCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ReadFromJSONMock.defaultExpectation != nil &amp;&amp; afterReadFromJSONCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.ReadFromJSON at\n%s", m.ReadFromJSONMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcReadFromJSON != nil &amp;&amp; afterReadFromJSONCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.ReadFromJSON at\n%s", m.funcReadFromJSONOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ReadFromJSONMock.invocationsDone() &amp;&amp; afterReadFromJSONCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.ReadFromJSON at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ReadFromJSONMock.expectedInvocations), m.ReadFromJSONMock.expectedInvocationsOrigin, afterReadFromJSONCounter)
        }</span>
}

type mOrderStorageInterfaceMockWriteToJSON struct {
        optional           bool
        mock               *OrderStorageInterfaceMock
        defaultExpectation *OrderStorageInterfaceMockWriteToJSONExpectation
        expectations       []*OrderStorageInterfaceMockWriteToJSONExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderStorageInterfaceMockWriteToJSONExpectation specifies expectation struct of the OrderStorageInterface.WriteToJSON
type OrderStorageInterfaceMockWriteToJSONExpectation struct {
        mock *OrderStorageInterfaceMock

        results      *OrderStorageInterfaceMockWriteToJSONResults
        returnOrigin string
        Counter      uint64
}

// OrderStorageInterfaceMockWriteToJSONResults contains results of the OrderStorageInterface.WriteToJSON
type OrderStorageInterfaceMockWriteToJSONResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Optional() *mOrderStorageInterfaceMockWriteToJSON <span class="cov0" title="0">{
        mmWriteToJSON.optional = true
        return mmWriteToJSON
}</span>

// Expect sets up expected params for OrderStorageInterface.WriteToJSON
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Expect() *mOrderStorageInterfaceMockWriteToJSON <span class="cov0" title="0">{
        if mmWriteToJSON.mock.funcWriteToJSON != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("OrderStorageInterfaceMock.WriteToJSON mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWriteToJSON.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWriteToJSON.defaultExpectation = &amp;OrderStorageInterfaceMockWriteToJSONExpectation{}
        }</span>

        <span class="cov0" title="0">return mmWriteToJSON</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderStorageInterface.WriteToJSON
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Inspect(f func()) *mOrderStorageInterfaceMockWriteToJSON <span class="cov0" title="0">{
        if mmWriteToJSON.mock.inspectFuncWriteToJSON != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("Inspect function is already set for OrderStorageInterfaceMock.WriteToJSON")
        }</span>

        <span class="cov0" title="0">mmWriteToJSON.mock.inspectFuncWriteToJSON = f

        return mmWriteToJSON</span>
}

// Return sets up results that will be returned by OrderStorageInterface.WriteToJSON
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Return(err error) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmWriteToJSON.mock.funcWriteToJSON != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("OrderStorageInterfaceMock.WriteToJSON mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWriteToJSON.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWriteToJSON.defaultExpectation = &amp;OrderStorageInterfaceMockWriteToJSONExpectation{mock: mmWriteToJSON.mock}
        }</span>
        <span class="cov0" title="0">mmWriteToJSON.defaultExpectation.results = &amp;OrderStorageInterfaceMockWriteToJSONResults{err}
        mmWriteToJSON.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmWriteToJSON.mock</span>
}

// Set uses given function f to mock the OrderStorageInterface.WriteToJSON method
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Set(f func() (err error)) *OrderStorageInterfaceMock <span class="cov0" title="0">{
        if mmWriteToJSON.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("Default expectation is already set for the OrderStorageInterface.WriteToJSON method")
        }</span>

        <span class="cov0" title="0">if len(mmWriteToJSON.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("Some expectations are already set for the OrderStorageInterface.WriteToJSON method")
        }</span>

        <span class="cov0" title="0">mmWriteToJSON.mock.funcWriteToJSON = f
        mmWriteToJSON.mock.funcWriteToJSONOrigin = minimock.CallerInfo(1)
        return mmWriteToJSON.mock</span>
}

// Times sets number of times OrderStorageInterface.WriteToJSON should be invoked
func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) Times(n uint64) *mOrderStorageInterfaceMockWriteToJSON <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("Times of OrderStorageInterfaceMock.WriteToJSON mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmWriteToJSON.expectedInvocations, n)
        mmWriteToJSON.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmWriteToJSON</span>
}

func (mmWriteToJSON *mOrderStorageInterfaceMockWriteToJSON) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmWriteToJSON.expectations) == 0 &amp;&amp; mmWriteToJSON.defaultExpectation == nil &amp;&amp; mmWriteToJSON.mock.funcWriteToJSON == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmWriteToJSON.mock.afterWriteToJSONCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmWriteToJSON.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// WriteToJSON implements mm_storage.OrderStorageInterface
func (mmWriteToJSON *OrderStorageInterfaceMock) WriteToJSON() (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmWriteToJSON.beforeWriteToJSONCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmWriteToJSON.afterWriteToJSONCounter, 1)

        mmWriteToJSON.t.Helper()

        if mmWriteToJSON.inspectFuncWriteToJSON != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.inspectFuncWriteToJSON()
        }</span>

        <span class="cov0" title="0">if mmWriteToJSON.WriteToJSONMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmWriteToJSON.WriteToJSONMock.defaultExpectation.Counter, 1)

                mm_results := mmWriteToJSON.WriteToJSONMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmWriteToJSON.t.Fatal("No results are set for the OrderStorageInterfaceMock.WriteToJSON")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmWriteToJSON.funcWriteToJSON != nil </span><span class="cov0" title="0">{
                return mmWriteToJSON.funcWriteToJSON()
        }</span>
        <span class="cov0" title="0">mmWriteToJSON.t.Fatalf("Unexpected call to OrderStorageInterfaceMock.WriteToJSON.")
        return</span>
}

// WriteToJSONAfterCounter returns a count of finished OrderStorageInterfaceMock.WriteToJSON invocations
func (mmWriteToJSON *OrderStorageInterfaceMock) WriteToJSONAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWriteToJSON.afterWriteToJSONCounter)
}</span>

// WriteToJSONBeforeCounter returns a count of OrderStorageInterfaceMock.WriteToJSON invocations
func (mmWriteToJSON *OrderStorageInterfaceMock) WriteToJSONBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWriteToJSON.beforeWriteToJSONCounter)
}</span>

// MinimockWriteToJSONDone returns true if the count of the WriteToJSON invocations corresponds
// the number of defined expectations
func (m *OrderStorageInterfaceMock) MinimockWriteToJSONDone() bool <span class="cov8" title="1">{
        if m.WriteToJSONMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.WriteToJSONMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.WriteToJSONMock.invocationsDone()</span>
}

// MinimockWriteToJSONInspect logs each unmet expectation
func (m *OrderStorageInterfaceMock) MinimockWriteToJSONInspect() <span class="cov0" title="0">{
        for _, e := range m.WriteToJSONMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to OrderStorageInterfaceMock.WriteToJSON")
                }</span>
        }

        <span class="cov0" title="0">afterWriteToJSONCounter := mm_atomic.LoadUint64(&amp;m.afterWriteToJSONCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.WriteToJSONMock.defaultExpectation != nil &amp;&amp; afterWriteToJSONCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.WriteToJSON at\n%s", m.WriteToJSONMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcWriteToJSON != nil &amp;&amp; afterWriteToJSONCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderStorageInterfaceMock.WriteToJSON at\n%s", m.funcWriteToJSONOrigin)
        }</span>

        <span class="cov0" title="0">if !m.WriteToJSONMock.invocationsDone() &amp;&amp; afterWriteToJSONCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderStorageInterfaceMock.WriteToJSON at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.WriteToJSONMock.expectedInvocations), m.WriteToJSONMock.expectedInvocationsOrigin, afterWriteToJSONCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderStorageInterfaceMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddOrderToStorageInspect()

                        m.MinimockDeleteOrderFromStorageInspect()

                        m.MinimockGetOrderInspect()

                        m.MinimockGetOrderIDsInspect()

                        m.MinimockIsConsistInspect()

                        m.MinimockReadFromJSONInspect()

                        m.MinimockWriteToJSONInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderStorageInterfaceMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *OrderStorageInterfaceMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockAddOrderToStorageDone() &amp;&amp;
                m.MinimockDeleteOrderFromStorageDone() &amp;&amp;
                m.MinimockGetOrderDone() &amp;&amp;
                m.MinimockGetOrderIDsDone() &amp;&amp;
                m.MinimockIsConsistDone() &amp;&amp;
                m.MinimockReadFromJSONDone() &amp;&amp;
                m.MinimockWriteToJSONDone()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i gitlab.ozon.dev/akugnerevich/homework.git/internal/storage.ReturnStorageInterface -o return_storage_interface_mock_test.go -n ReturnStorageInterfaceMock -p mocks

import (
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
)

// ReturnStorageInterfaceMock implements mm_storage.ReturnStorageInterface
type ReturnStorageInterfaceMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAddReturnToStorage          func(r *models.Return) (err error)
        funcAddReturnToStorageOrigin    string
        inspectFuncAddReturnToStorage   func(r *models.Return)
        afterAddReturnToStorageCounter  uint64
        beforeAddReturnToStorageCounter uint64
        AddReturnToStorageMock          mReturnStorageInterfaceMockAddReturnToStorage

        funcDeleteReturnFromStorage          func(id uint)
        funcDeleteReturnFromStorageOrigin    string
        inspectFuncDeleteReturnFromStorage   func(id uint)
        afterDeleteReturnFromStorageCounter  uint64
        beforeDeleteReturnFromStorageCounter uint64
        DeleteReturnFromStorageMock          mReturnStorageInterfaceMockDeleteReturnFromStorage

        funcGetReturn          func(id uint) (rp1 *models.Return, b1 bool)
        funcGetReturnOrigin    string
        inspectFuncGetReturn   func(id uint)
        afterGetReturnCounter  uint64
        beforeGetReturnCounter uint64
        GetReturnMock          mReturnStorageInterfaceMockGetReturn

        funcGetReturnIDs          func() (ua1 []uint)
        funcGetReturnIDsOrigin    string
        inspectFuncGetReturnIDs   func()
        afterGetReturnIDsCounter  uint64
        beforeGetReturnIDsCounter uint64
        GetReturnIDsMock          mReturnStorageInterfaceMockGetReturnIDs

        funcIsConsist          func(id uint) (b1 bool)
        funcIsConsistOrigin    string
        inspectFuncIsConsist   func(id uint)
        afterIsConsistCounter  uint64
        beforeIsConsistCounter uint64
        IsConsistMock          mReturnStorageInterfaceMockIsConsist

        funcReadFromJSON          func() (err error)
        funcReadFromJSONOrigin    string
        inspectFuncReadFromJSON   func()
        afterReadFromJSONCounter  uint64
        beforeReadFromJSONCounter uint64
        ReadFromJSONMock          mReturnStorageInterfaceMockReadFromJSON

        funcWriteToJSON          func() (err error)
        funcWriteToJSONOrigin    string
        inspectFuncWriteToJSON   func()
        afterWriteToJSONCounter  uint64
        beforeWriteToJSONCounter uint64
        WriteToJSONMock          mReturnStorageInterfaceMockWriteToJSON
}

// NewReturnStorageInterfaceMock returns a mock for mm_storage.ReturnStorageInterface
func NewReturnStorageInterfaceMock(t minimock.Tester) *ReturnStorageInterfaceMock <span class="cov8" title="1">{
        m := &amp;ReturnStorageInterfaceMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.AddReturnToStorageMock = mReturnStorageInterfaceMockAddReturnToStorage{mock: m}
        m.AddReturnToStorageMock.callArgs = []*ReturnStorageInterfaceMockAddReturnToStorageParams{}

        m.DeleteReturnFromStorageMock = mReturnStorageInterfaceMockDeleteReturnFromStorage{mock: m}
        m.DeleteReturnFromStorageMock.callArgs = []*ReturnStorageInterfaceMockDeleteReturnFromStorageParams{}

        m.GetReturnMock = mReturnStorageInterfaceMockGetReturn{mock: m}
        m.GetReturnMock.callArgs = []*ReturnStorageInterfaceMockGetReturnParams{}

        m.GetReturnIDsMock = mReturnStorageInterfaceMockGetReturnIDs{mock: m}

        m.IsConsistMock = mReturnStorageInterfaceMockIsConsist{mock: m}
        m.IsConsistMock.callArgs = []*ReturnStorageInterfaceMockIsConsistParams{}

        m.ReadFromJSONMock = mReturnStorageInterfaceMockReadFromJSON{mock: m}

        m.WriteToJSONMock = mReturnStorageInterfaceMockWriteToJSON{mock: m}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mReturnStorageInterfaceMockAddReturnToStorage struct {
        optional           bool
        mock               *ReturnStorageInterfaceMock
        defaultExpectation *ReturnStorageInterfaceMockAddReturnToStorageExpectation
        expectations       []*ReturnStorageInterfaceMockAddReturnToStorageExpectation

        callArgs []*ReturnStorageInterfaceMockAddReturnToStorageParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockAddReturnToStorageExpectation specifies expectation struct of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageExpectation struct {
        mock               *ReturnStorageInterfaceMock
        params             *ReturnStorageInterfaceMockAddReturnToStorageParams
        paramPtrs          *ReturnStorageInterfaceMockAddReturnToStorageParamPtrs
        expectationOrigins ReturnStorageInterfaceMockAddReturnToStorageExpectationOrigins
        results            *ReturnStorageInterfaceMockAddReturnToStorageResults
        returnOrigin       string
        Counter            uint64
}

// ReturnStorageInterfaceMockAddReturnToStorageParams contains parameters of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageParams struct {
        r *models.Return
}

// ReturnStorageInterfaceMockAddReturnToStorageParamPtrs contains pointers to parameters of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageParamPtrs struct {
        r **models.Return
}

// ReturnStorageInterfaceMockAddReturnToStorageResults contains results of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageResults struct {
        err error
}

// ReturnStorageInterfaceMockAddReturnToStorageOrigins contains origins of expectations of the ReturnStorageInterface.AddReturnToStorage
type ReturnStorageInterfaceMockAddReturnToStorageExpectationOrigins struct {
        origin  string
        originR string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Optional() *mReturnStorageInterfaceMockAddReturnToStorage <span class="cov0" title="0">{
        mmAddReturnToStorage.optional = true
        return mmAddReturnToStorage
}</span>

// Expect sets up expected params for ReturnStorageInterface.AddReturnToStorage
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Expect(r *models.Return) *mReturnStorageInterfaceMockAddReturnToStorage <span class="cov8" title="1">{
        if mmAddReturnToStorage.mock.funcAddReturnToStorage != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmAddReturnToStorage.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmAddReturnToStorage.defaultExpectation = &amp;ReturnStorageInterfaceMockAddReturnToStorageExpectation{}
        }</span>

        <span class="cov8" title="1">if mmAddReturnToStorage.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmAddReturnToStorage.defaultExpectation.params = &amp;ReturnStorageInterfaceMockAddReturnToStorageParams{r}
        mmAddReturnToStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmAddReturnToStorage.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAddReturnToStorage.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAddReturnToStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReturnToStorage.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmAddReturnToStorage</span>
}

// ExpectRParam1 sets up expected param r for ReturnStorageInterface.AddReturnToStorage
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) ExpectRParam1(r *models.Return) *mReturnStorageInterfaceMockAddReturnToStorage <span class="cov0" title="0">{
        if mmAddReturnToStorage.mock.funcAddReturnToStorage != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddReturnToStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.defaultExpectation = &amp;ReturnStorageInterfaceMockAddReturnToStorageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddReturnToStorage.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddReturnToStorage.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.defaultExpectation.paramPtrs = &amp;ReturnStorageInterfaceMockAddReturnToStorageParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddReturnToStorage.defaultExpectation.paramPtrs.r = &amp;r
        mmAddReturnToStorage.defaultExpectation.expectationOrigins.originR = minimock.CallerInfo(1)

        return mmAddReturnToStorage</span>
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.AddReturnToStorage
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Inspect(f func(r *models.Return)) *mReturnStorageInterfaceMockAddReturnToStorage <span class="cov0" title="0">{
        if mmAddReturnToStorage.mock.inspectFuncAddReturnToStorage != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.AddReturnToStorage")
        }</span>

        <span class="cov0" title="0">mmAddReturnToStorage.mock.inspectFuncAddReturnToStorage = f

        return mmAddReturnToStorage</span>
}

// Return sets up results that will be returned by ReturnStorageInterface.AddReturnToStorage
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Return(err error) *ReturnStorageInterfaceMock <span class="cov8" title="1">{
        if mmAddReturnToStorage.mock.funcAddReturnToStorage != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmAddReturnToStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.defaultExpectation = &amp;ReturnStorageInterfaceMockAddReturnToStorageExpectation{mock: mmAddReturnToStorage.mock}
        }</span>
        <span class="cov8" title="1">mmAddReturnToStorage.defaultExpectation.results = &amp;ReturnStorageInterfaceMockAddReturnToStorageResults{err}
        mmAddReturnToStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmAddReturnToStorage.mock</span>
}

// Set uses given function f to mock the ReturnStorageInterface.AddReturnToStorage method
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Set(f func(r *models.Return) (err error)) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmAddReturnToStorage.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.AddReturnToStorage method")
        }</span>

        <span class="cov0" title="0">if len(mmAddReturnToStorage.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.AddReturnToStorage method")
        }</span>

        <span class="cov0" title="0">mmAddReturnToStorage.mock.funcAddReturnToStorage = f
        mmAddReturnToStorage.mock.funcAddReturnToStorageOrigin = minimock.CallerInfo(1)
        return mmAddReturnToStorage.mock</span>
}

// When sets expectation for the ReturnStorageInterface.AddReturnToStorage which will trigger the result defined by the following
// Then helper
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) When(r *models.Return) *ReturnStorageInterfaceMockAddReturnToStorageExpectation <span class="cov0" title="0">{
        if mmAddReturnToStorage.mock.funcAddReturnToStorage != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.AddReturnToStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ReturnStorageInterfaceMockAddReturnToStorageExpectation{
                mock:               mmAddReturnToStorage.mock,
                params:             &amp;ReturnStorageInterfaceMockAddReturnToStorageParams{r},
                expectationOrigins: ReturnStorageInterfaceMockAddReturnToStorageExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmAddReturnToStorage.expectations = append(mmAddReturnToStorage.expectations, expectation)
        return expectation</span>
}

// Then sets up ReturnStorageInterface.AddReturnToStorage return parameters for the expectation previously defined by the When method
func (e *ReturnStorageInterfaceMockAddReturnToStorageExpectation) Then(err error) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        e.results = &amp;ReturnStorageInterfaceMockAddReturnToStorageResults{err}
        return e.mock
}</span>

// Times sets number of times ReturnStorageInterface.AddReturnToStorage should be invoked
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Times(n uint64) *mReturnStorageInterfaceMockAddReturnToStorage <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAddReturnToStorage.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.AddReturnToStorage mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAddReturnToStorage.expectedInvocations, n)
        mmAddReturnToStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmAddReturnToStorage</span>
}

func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmAddReturnToStorage.expectations) == 0 &amp;&amp; mmAddReturnToStorage.defaultExpectation == nil &amp;&amp; mmAddReturnToStorage.mock.funcAddReturnToStorage == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmAddReturnToStorage.mock.afterAddReturnToStorageCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAddReturnToStorage.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// AddReturnToStorage implements mm_storage.ReturnStorageInterface
func (mmAddReturnToStorage *ReturnStorageInterfaceMock) AddReturnToStorage(r *models.Return) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmAddReturnToStorage.beforeAddReturnToStorageCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAddReturnToStorage.afterAddReturnToStorageCounter, 1)

        mmAddReturnToStorage.t.Helper()

        if mmAddReturnToStorage.inspectFuncAddReturnToStorage != nil </span><span class="cov0" title="0">{
                mmAddReturnToStorage.inspectFuncAddReturnToStorage(r)
        }</span>

        <span class="cov8" title="1">mm_params := ReturnStorageInterfaceMockAddReturnToStorageParams{r}

        // Record call args
        mmAddReturnToStorage.AddReturnToStorageMock.mutex.Lock()
        mmAddReturnToStorage.AddReturnToStorageMock.callArgs = append(mmAddReturnToStorage.AddReturnToStorageMock.callArgs, &amp;mm_params)
        mmAddReturnToStorage.AddReturnToStorageMock.mutex.Unlock()

        for _, e := range mmAddReturnToStorage.AddReturnToStorageMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.Counter, 1)
                mm_want := mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.params
                mm_want_ptrs := mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.paramPtrs

                mm_got := ReturnStorageInterfaceMockAddReturnToStorageParams{r}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.r != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.r, mm_got.r) </span><span class="cov0" title="0">{
                                mmAddReturnToStorage.t.Errorf("ReturnStorageInterfaceMock.AddReturnToStorage got unexpected parameter r, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.expectationOrigins.originR, *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAddReturnToStorage.t.Errorf("ReturnStorageInterfaceMock.AddReturnToStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmAddReturnToStorage.AddReturnToStorageMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAddReturnToStorage.t.Fatal("No results are set for the ReturnStorageInterfaceMock.AddReturnToStorage")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAddReturnToStorage.funcAddReturnToStorage != nil </span><span class="cov0" title="0">{
                return mmAddReturnToStorage.funcAddReturnToStorage(r)
        }</span>
        <span class="cov0" title="0">mmAddReturnToStorage.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.AddReturnToStorage. %v", r)
        return</span>
}

// AddReturnToStorageAfterCounter returns a count of finished ReturnStorageInterfaceMock.AddReturnToStorage invocations
func (mmAddReturnToStorage *ReturnStorageInterfaceMock) AddReturnToStorageAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddReturnToStorage.afterAddReturnToStorageCounter)
}</span>

// AddReturnToStorageBeforeCounter returns a count of ReturnStorageInterfaceMock.AddReturnToStorage invocations
func (mmAddReturnToStorage *ReturnStorageInterfaceMock) AddReturnToStorageBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddReturnToStorage.beforeAddReturnToStorageCounter)
}</span>

// Calls returns a list of arguments used in each call to ReturnStorageInterfaceMock.AddReturnToStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReturnToStorage *mReturnStorageInterfaceMockAddReturnToStorage) Calls() []*ReturnStorageInterfaceMockAddReturnToStorageParams <span class="cov0" title="0">{
        mmAddReturnToStorage.mutex.RLock()

        argCopy := make([]*ReturnStorageInterfaceMockAddReturnToStorageParams, len(mmAddReturnToStorage.callArgs))
        copy(argCopy, mmAddReturnToStorage.callArgs)

        mmAddReturnToStorage.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddReturnToStorageDone returns true if the count of the AddReturnToStorage invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockAddReturnToStorageDone() bool <span class="cov8" title="1">{
        if m.AddReturnToStorageMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.AddReturnToStorageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.AddReturnToStorageMock.invocationsDone()</span>
}

// MinimockAddReturnToStorageInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockAddReturnToStorageInspect() <span class="cov0" title="0">{
        for _, e := range m.AddReturnToStorageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddReturnToStorageCounter := mm_atomic.LoadUint64(&amp;m.afterAddReturnToStorageCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddReturnToStorageMock.defaultExpectation != nil &amp;&amp; afterAddReturnToStorageCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddReturnToStorageMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s", m.AddReturnToStorageMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s with params: %#v", m.AddReturnToStorageMock.defaultExpectation.expectationOrigins.origin, *m.AddReturnToStorageMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAddReturnToStorage != nil &amp;&amp; afterAddReturnToStorageCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s", m.funcAddReturnToStorageOrigin)
        }</span>

        <span class="cov0" title="0">if !m.AddReturnToStorageMock.invocationsDone() &amp;&amp; afterAddReturnToStorageCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.AddReturnToStorage at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddReturnToStorageMock.expectedInvocations), m.AddReturnToStorageMock.expectedInvocationsOrigin, afterAddReturnToStorageCounter)
        }</span>
}

type mReturnStorageInterfaceMockDeleteReturnFromStorage struct {
        optional           bool
        mock               *ReturnStorageInterfaceMock
        defaultExpectation *ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation
        expectations       []*ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation

        callArgs []*ReturnStorageInterfaceMockDeleteReturnFromStorageParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation specifies expectation struct of the ReturnStorageInterface.DeleteReturnFromStorage
type ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation struct {
        mock               *ReturnStorageInterfaceMock
        params             *ReturnStorageInterfaceMockDeleteReturnFromStorageParams
        paramPtrs          *ReturnStorageInterfaceMockDeleteReturnFromStorageParamPtrs
        expectationOrigins ReturnStorageInterfaceMockDeleteReturnFromStorageExpectationOrigins

        returnOrigin string
        Counter      uint64
}

// ReturnStorageInterfaceMockDeleteReturnFromStorageParams contains parameters of the ReturnStorageInterface.DeleteReturnFromStorage
type ReturnStorageInterfaceMockDeleteReturnFromStorageParams struct {
        id uint
}

// ReturnStorageInterfaceMockDeleteReturnFromStorageParamPtrs contains pointers to parameters of the ReturnStorageInterface.DeleteReturnFromStorage
type ReturnStorageInterfaceMockDeleteReturnFromStorageParamPtrs struct {
        id *uint
}

// ReturnStorageInterfaceMockDeleteReturnFromStorageOrigins contains origins of expectations of the ReturnStorageInterface.DeleteReturnFromStorage
type ReturnStorageInterfaceMockDeleteReturnFromStorageExpectationOrigins struct {
        origin   string
        originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Optional() *mReturnStorageInterfaceMockDeleteReturnFromStorage <span class="cov0" title="0">{
        mmDeleteReturnFromStorage.optional = true
        return mmDeleteReturnFromStorage
}</span>

// Expect sets up expected params for ReturnStorageInterface.DeleteReturnFromStorage
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Expect(id uint) *mReturnStorageInterfaceMockDeleteReturnFromStorage <span class="cov0" title="0">{
        if mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteReturnFromStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.defaultExpectation = &amp;ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteReturnFromStorage.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmDeleteReturnFromStorage.defaultExpectation.params = &amp;ReturnStorageInterfaceMockDeleteReturnFromStorageParams{id}
        mmDeleteReturnFromStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmDeleteReturnFromStorage.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteReturnFromStorage.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteReturnFromStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteReturnFromStorage.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmDeleteReturnFromStorage</span>
}

// ExpectIdParam1 sets up expected param id for ReturnStorageInterface.DeleteReturnFromStorage
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) ExpectIdParam1(id uint) *mReturnStorageInterfaceMockDeleteReturnFromStorage <span class="cov0" title="0">{
        if mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteReturnFromStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.defaultExpectation = &amp;ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteReturnFromStorage.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteReturnFromStorage.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.defaultExpectation.paramPtrs = &amp;ReturnStorageInterfaceMockDeleteReturnFromStorageParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteReturnFromStorage.defaultExpectation.paramPtrs.id = &amp;id
        mmDeleteReturnFromStorage.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmDeleteReturnFromStorage</span>
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.DeleteReturnFromStorage
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Inspect(f func(id uint)) *mReturnStorageInterfaceMockDeleteReturnFromStorage <span class="cov0" title="0">{
        if mmDeleteReturnFromStorage.mock.inspectFuncDeleteReturnFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.DeleteReturnFromStorage")
        }</span>

        <span class="cov0" title="0">mmDeleteReturnFromStorage.mock.inspectFuncDeleteReturnFromStorage = f

        return mmDeleteReturnFromStorage</span>
}

// Return sets up results that will be returned by ReturnStorageInterface.DeleteReturnFromStorage
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Return() *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("ReturnStorageInterfaceMock.DeleteReturnFromStorage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteReturnFromStorage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.defaultExpectation = &amp;ReturnStorageInterfaceMockDeleteReturnFromStorageExpectation{mock: mmDeleteReturnFromStorage.mock}
        }</span>

        <span class="cov0" title="0">mmDeleteReturnFromStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmDeleteReturnFromStorage.mock</span>
}

// Set uses given function f to mock the ReturnStorageInterface.DeleteReturnFromStorage method
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Set(f func(id uint)) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmDeleteReturnFromStorage.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.DeleteReturnFromStorage method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteReturnFromStorage.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.DeleteReturnFromStorage method")
        }</span>

        <span class="cov0" title="0">mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage = f
        mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorageOrigin = minimock.CallerInfo(1)
        return mmDeleteReturnFromStorage.mock</span>
}

// Times sets number of times ReturnStorageInterface.DeleteReturnFromStorage should be invoked
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Times(n uint64) *mReturnStorageInterfaceMockDeleteReturnFromStorage <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.DeleteReturnFromStorage mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteReturnFromStorage.expectedInvocations, n)
        mmDeleteReturnFromStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmDeleteReturnFromStorage</span>
}

func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmDeleteReturnFromStorage.expectations) == 0 &amp;&amp; mmDeleteReturnFromStorage.defaultExpectation == nil &amp;&amp; mmDeleteReturnFromStorage.mock.funcDeleteReturnFromStorage == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteReturnFromStorage.mock.afterDeleteReturnFromStorageCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteReturnFromStorage.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteReturnFromStorage implements mm_storage.ReturnStorageInterface
func (mmDeleteReturnFromStorage *ReturnStorageInterfaceMock) DeleteReturnFromStorage(id uint) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmDeleteReturnFromStorage.beforeDeleteReturnFromStorageCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteReturnFromStorage.afterDeleteReturnFromStorageCounter, 1)

        mmDeleteReturnFromStorage.t.Helper()

        if mmDeleteReturnFromStorage.inspectFuncDeleteReturnFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.inspectFuncDeleteReturnFromStorage(id)
        }</span>

        <span class="cov0" title="0">mm_params := ReturnStorageInterfaceMockDeleteReturnFromStorageParams{id}

        // Record call args
        mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.mutex.Lock()
        mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.callArgs = append(mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.callArgs, &amp;mm_params)
        mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.mutex.Unlock()

        for _, e := range mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return
                }</span>
        }

        <span class="cov0" title="0">if mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.paramPtrs

                mm_got := ReturnStorageInterfaceMockDeleteReturnFromStorageParams{id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDeleteReturnFromStorage.t.Errorf("ReturnStorageInterfaceMock.DeleteReturnFromStorage got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteReturnFromStorage.t.Errorf("ReturnStorageInterfaceMock.DeleteReturnFromStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmDeleteReturnFromStorage.DeleteReturnFromStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">return</span>

        }
        <span class="cov0" title="0">if mmDeleteReturnFromStorage.funcDeleteReturnFromStorage != nil </span><span class="cov0" title="0">{
                mmDeleteReturnFromStorage.funcDeleteReturnFromStorage(id)
                return
        }</span>
        <span class="cov0" title="0">mmDeleteReturnFromStorage.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage. %v", id)</span>

}

// DeleteReturnFromStorageAfterCounter returns a count of finished ReturnStorageInterfaceMock.DeleteReturnFromStorage invocations
func (mmDeleteReturnFromStorage *ReturnStorageInterfaceMock) DeleteReturnFromStorageAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteReturnFromStorage.afterDeleteReturnFromStorageCounter)
}</span>

// DeleteReturnFromStorageBeforeCounter returns a count of ReturnStorageInterfaceMock.DeleteReturnFromStorage invocations
func (mmDeleteReturnFromStorage *ReturnStorageInterfaceMock) DeleteReturnFromStorageBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteReturnFromStorage.beforeDeleteReturnFromStorageCounter)
}</span>

// Calls returns a list of arguments used in each call to ReturnStorageInterfaceMock.DeleteReturnFromStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteReturnFromStorage *mReturnStorageInterfaceMockDeleteReturnFromStorage) Calls() []*ReturnStorageInterfaceMockDeleteReturnFromStorageParams <span class="cov0" title="0">{
        mmDeleteReturnFromStorage.mutex.RLock()

        argCopy := make([]*ReturnStorageInterfaceMockDeleteReturnFromStorageParams, len(mmDeleteReturnFromStorage.callArgs))
        copy(argCopy, mmDeleteReturnFromStorage.callArgs)

        mmDeleteReturnFromStorage.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteReturnFromStorageDone returns true if the count of the DeleteReturnFromStorage invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockDeleteReturnFromStorageDone() bool <span class="cov8" title="1">{
        if m.DeleteReturnFromStorageMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.DeleteReturnFromStorageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.DeleteReturnFromStorageMock.invocationsDone()</span>
}

// MinimockDeleteReturnFromStorageInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockDeleteReturnFromStorageInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteReturnFromStorageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteReturnFromStorageCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteReturnFromStorageCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteReturnFromStorageMock.defaultExpectation != nil &amp;&amp; afterDeleteReturnFromStorageCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteReturnFromStorageMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s", m.DeleteReturnFromStorageMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s with params: %#v", m.DeleteReturnFromStorageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteReturnFromStorageMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteReturnFromStorage != nil &amp;&amp; afterDeleteReturnFromStorageCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s", m.funcDeleteReturnFromStorageOrigin)
        }</span>

        <span class="cov0" title="0">if !m.DeleteReturnFromStorageMock.invocationsDone() &amp;&amp; afterDeleteReturnFromStorageCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.DeleteReturnFromStorage at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteReturnFromStorageMock.expectedInvocations), m.DeleteReturnFromStorageMock.expectedInvocationsOrigin, afterDeleteReturnFromStorageCounter)
        }</span>
}

type mReturnStorageInterfaceMockGetReturn struct {
        optional           bool
        mock               *ReturnStorageInterfaceMock
        defaultExpectation *ReturnStorageInterfaceMockGetReturnExpectation
        expectations       []*ReturnStorageInterfaceMockGetReturnExpectation

        callArgs []*ReturnStorageInterfaceMockGetReturnParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockGetReturnExpectation specifies expectation struct of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnExpectation struct {
        mock               *ReturnStorageInterfaceMock
        params             *ReturnStorageInterfaceMockGetReturnParams
        paramPtrs          *ReturnStorageInterfaceMockGetReturnParamPtrs
        expectationOrigins ReturnStorageInterfaceMockGetReturnExpectationOrigins
        results            *ReturnStorageInterfaceMockGetReturnResults
        returnOrigin       string
        Counter            uint64
}

// ReturnStorageInterfaceMockGetReturnParams contains parameters of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnParams struct {
        id uint
}

// ReturnStorageInterfaceMockGetReturnParamPtrs contains pointers to parameters of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnParamPtrs struct {
        id *uint
}

// ReturnStorageInterfaceMockGetReturnResults contains results of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnResults struct {
        rp1 *models.Return
        b1  bool
}

// ReturnStorageInterfaceMockGetReturnOrigins contains origins of expectations of the ReturnStorageInterface.GetReturn
type ReturnStorageInterfaceMockGetReturnExpectationOrigins struct {
        origin   string
        originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Optional() *mReturnStorageInterfaceMockGetReturn <span class="cov0" title="0">{
        mmGetReturn.optional = true
        return mmGetReturn
}</span>

// Expect sets up expected params for ReturnStorageInterface.GetReturn
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Expect(id uint) *mReturnStorageInterfaceMockGetReturn <span class="cov0" title="0">{
        if mmGetReturn.mock.funcGetReturn != nil </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetReturn.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReturn.defaultExpectation = &amp;ReturnStorageInterfaceMockGetReturnExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetReturn.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetReturn.defaultExpectation.params = &amp;ReturnStorageInterfaceMockGetReturnParams{id}
        mmGetReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetReturn.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetReturn.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturn.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetReturn</span>
}

// ExpectIdParam1 sets up expected param id for ReturnStorageInterface.GetReturn
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) ExpectIdParam1(id uint) *mReturnStorageInterfaceMockGetReturn <span class="cov0" title="0">{
        if mmGetReturn.mock.funcGetReturn != nil </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetReturn.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReturn.defaultExpectation = &amp;ReturnStorageInterfaceMockGetReturnExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetReturn.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetReturn.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetReturn.defaultExpectation.paramPtrs = &amp;ReturnStorageInterfaceMockGetReturnParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetReturn.defaultExpectation.paramPtrs.id = &amp;id
        mmGetReturn.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmGetReturn</span>
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.GetReturn
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Inspect(f func(id uint)) *mReturnStorageInterfaceMockGetReturn <span class="cov0" title="0">{
        if mmGetReturn.mock.inspectFuncGetReturn != nil </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.GetReturn")
        }</span>

        <span class="cov0" title="0">mmGetReturn.mock.inspectFuncGetReturn = f

        return mmGetReturn</span>
}

// Return sets up results that will be returned by ReturnStorageInterface.GetReturn
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Return(rp1 *models.Return, b1 bool) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmGetReturn.mock.funcGetReturn != nil </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetReturn.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReturn.defaultExpectation = &amp;ReturnStorageInterfaceMockGetReturnExpectation{mock: mmGetReturn.mock}
        }</span>
        <span class="cov0" title="0">mmGetReturn.defaultExpectation.results = &amp;ReturnStorageInterfaceMockGetReturnResults{rp1, b1}
        mmGetReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetReturn.mock</span>
}

// Set uses given function f to mock the ReturnStorageInterface.GetReturn method
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Set(f func(id uint) (rp1 *models.Return, b1 bool)) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmGetReturn.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.GetReturn method")
        }</span>

        <span class="cov0" title="0">if len(mmGetReturn.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.GetReturn method")
        }</span>

        <span class="cov0" title="0">mmGetReturn.mock.funcGetReturn = f
        mmGetReturn.mock.funcGetReturnOrigin = minimock.CallerInfo(1)
        return mmGetReturn.mock</span>
}

// When sets expectation for the ReturnStorageInterface.GetReturn which will trigger the result defined by the following
// Then helper
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) When(id uint) *ReturnStorageInterfaceMockGetReturnExpectation <span class="cov8" title="1">{
        if mmGetReturn.mock.funcGetReturn != nil </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturn mock is already set by Set")
        }</span>

        <span class="cov8" title="1">expectation := &amp;ReturnStorageInterfaceMockGetReturnExpectation{
                mock:               mmGetReturn.mock,
                params:             &amp;ReturnStorageInterfaceMockGetReturnParams{id},
                expectationOrigins: ReturnStorageInterfaceMockGetReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetReturn.expectations = append(mmGetReturn.expectations, expectation)
        return expectation</span>
}

// Then sets up ReturnStorageInterface.GetReturn return parameters for the expectation previously defined by the When method
func (e *ReturnStorageInterfaceMockGetReturnExpectation) Then(rp1 *models.Return, b1 bool) *ReturnStorageInterfaceMock <span class="cov8" title="1">{
        e.results = &amp;ReturnStorageInterfaceMockGetReturnResults{rp1, b1}
        return e.mock
}</span>

// Times sets number of times ReturnStorageInterface.GetReturn should be invoked
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Times(n uint64) *mReturnStorageInterfaceMockGetReturn <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetReturn.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.GetReturn mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetReturn.expectedInvocations, n)
        mmGetReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetReturn</span>
}

func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetReturn.expectations) == 0 &amp;&amp; mmGetReturn.defaultExpectation == nil &amp;&amp; mmGetReturn.mock.funcGetReturn == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetReturn.mock.afterGetReturnCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetReturn.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetReturn implements mm_storage.ReturnStorageInterface
func (mmGetReturn *ReturnStorageInterfaceMock) GetReturn(id uint) (rp1 *models.Return, b1 bool) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmGetReturn.beforeGetReturnCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetReturn.afterGetReturnCounter, 1)

        mmGetReturn.t.Helper()

        if mmGetReturn.inspectFuncGetReturn != nil </span><span class="cov0" title="0">{
                mmGetReturn.inspectFuncGetReturn(id)
        }</span>

        <span class="cov8" title="1">mm_params := ReturnStorageInterfaceMockGetReturnParams{id}

        // Record call args
        mmGetReturn.GetReturnMock.mutex.Lock()
        mmGetReturn.GetReturnMock.callArgs = append(mmGetReturn.GetReturnMock.callArgs, &amp;mm_params)
        mmGetReturn.GetReturnMock.mutex.Unlock()

        for _, e := range mmGetReturn.GetReturnMock.expectations </span><span class="cov8" title="1">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov8" title="1">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.rp1, e.results.b1
                }</span>
        }

        <span class="cov0" title="0">if mmGetReturn.GetReturnMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetReturn.GetReturnMock.defaultExpectation.Counter, 1)
                mm_want := mmGetReturn.GetReturnMock.defaultExpectation.params
                mm_want_ptrs := mmGetReturn.GetReturnMock.defaultExpectation.paramPtrs

                mm_got := ReturnStorageInterfaceMockGetReturnParams{id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmGetReturn.t.Errorf("ReturnStorageInterfaceMock.GetReturn got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetReturn.GetReturnMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetReturn.t.Errorf("ReturnStorageInterfaceMock.GetReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetReturn.GetReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetReturn.GetReturnMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetReturn.t.Fatal("No results are set for the ReturnStorageInterfaceMock.GetReturn")
                }</span>
                <span class="cov0" title="0">return (*mm_results).rp1, (*mm_results).b1</span>
        }
        <span class="cov0" title="0">if mmGetReturn.funcGetReturn != nil </span><span class="cov0" title="0">{
                return mmGetReturn.funcGetReturn(id)
        }</span>
        <span class="cov0" title="0">mmGetReturn.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.GetReturn. %v", id)
        return</span>
}

// GetReturnAfterCounter returns a count of finished ReturnStorageInterfaceMock.GetReturn invocations
func (mmGetReturn *ReturnStorageInterfaceMock) GetReturnAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetReturn.afterGetReturnCounter)
}</span>

// GetReturnBeforeCounter returns a count of ReturnStorageInterfaceMock.GetReturn invocations
func (mmGetReturn *ReturnStorageInterfaceMock) GetReturnBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetReturn.beforeGetReturnCounter)
}</span>

// Calls returns a list of arguments used in each call to ReturnStorageInterfaceMock.GetReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturn *mReturnStorageInterfaceMockGetReturn) Calls() []*ReturnStorageInterfaceMockGetReturnParams <span class="cov0" title="0">{
        mmGetReturn.mutex.RLock()

        argCopy := make([]*ReturnStorageInterfaceMockGetReturnParams, len(mmGetReturn.callArgs))
        copy(argCopy, mmGetReturn.callArgs)

        mmGetReturn.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetReturnDone returns true if the count of the GetReturn invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockGetReturnDone() bool <span class="cov8" title="1">{
        if m.GetReturnMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetReturnMock.expectations </span><span class="cov8" title="1">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetReturnMock.invocationsDone()</span>
}

// MinimockGetReturnInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockGetReturnInspect() <span class="cov0" title="0">{
        for _, e := range m.GetReturnMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetReturnCounter := mm_atomic.LoadUint64(&amp;m.afterGetReturnCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetReturnMock.defaultExpectation != nil &amp;&amp; afterGetReturnCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetReturnMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturn at\n%s", m.GetReturnMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturn at\n%s with params: %#v", m.GetReturnMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetReturn != nil &amp;&amp; afterGetReturnCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturn at\n%s", m.funcGetReturnOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetReturnMock.invocationsDone() &amp;&amp; afterGetReturnCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.GetReturn at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetReturnMock.expectedInvocations), m.GetReturnMock.expectedInvocationsOrigin, afterGetReturnCounter)
        }</span>
}

type mReturnStorageInterfaceMockGetReturnIDs struct {
        optional           bool
        mock               *ReturnStorageInterfaceMock
        defaultExpectation *ReturnStorageInterfaceMockGetReturnIDsExpectation
        expectations       []*ReturnStorageInterfaceMockGetReturnIDsExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockGetReturnIDsExpectation specifies expectation struct of the ReturnStorageInterface.GetReturnIDs
type ReturnStorageInterfaceMockGetReturnIDsExpectation struct {
        mock *ReturnStorageInterfaceMock

        results      *ReturnStorageInterfaceMockGetReturnIDsResults
        returnOrigin string
        Counter      uint64
}

// ReturnStorageInterfaceMockGetReturnIDsResults contains results of the ReturnStorageInterface.GetReturnIDs
type ReturnStorageInterfaceMockGetReturnIDsResults struct {
        ua1 []uint
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Optional() *mReturnStorageInterfaceMockGetReturnIDs <span class="cov0" title="0">{
        mmGetReturnIDs.optional = true
        return mmGetReturnIDs
}</span>

// Expect sets up expected params for ReturnStorageInterface.GetReturnIDs
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Expect() *mReturnStorageInterfaceMockGetReturnIDs <span class="cov8" title="1">{
        if mmGetReturnIDs.mock.funcGetReturnIDs != nil </span><span class="cov0" title="0">{
                mmGetReturnIDs.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturnIDs mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetReturnIDs.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmGetReturnIDs.defaultExpectation = &amp;ReturnStorageInterfaceMockGetReturnIDsExpectation{}
        }</span>

        <span class="cov8" title="1">return mmGetReturnIDs</span>
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.GetReturnIDs
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Inspect(f func()) *mReturnStorageInterfaceMockGetReturnIDs <span class="cov0" title="0">{
        if mmGetReturnIDs.mock.inspectFuncGetReturnIDs != nil </span><span class="cov0" title="0">{
                mmGetReturnIDs.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.GetReturnIDs")
        }</span>

        <span class="cov0" title="0">mmGetReturnIDs.mock.inspectFuncGetReturnIDs = f

        return mmGetReturnIDs</span>
}

// Return sets up results that will be returned by ReturnStorageInterface.GetReturnIDs
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Return(ua1 []uint) *ReturnStorageInterfaceMock <span class="cov8" title="1">{
        if mmGetReturnIDs.mock.funcGetReturnIDs != nil </span><span class="cov0" title="0">{
                mmGetReturnIDs.mock.t.Fatalf("ReturnStorageInterfaceMock.GetReturnIDs mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetReturnIDs.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReturnIDs.defaultExpectation = &amp;ReturnStorageInterfaceMockGetReturnIDsExpectation{mock: mmGetReturnIDs.mock}
        }</span>
        <span class="cov8" title="1">mmGetReturnIDs.defaultExpectation.results = &amp;ReturnStorageInterfaceMockGetReturnIDsResults{ua1}
        mmGetReturnIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetReturnIDs.mock</span>
}

// Set uses given function f to mock the ReturnStorageInterface.GetReturnIDs method
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Set(f func() (ua1 []uint)) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmGetReturnIDs.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetReturnIDs.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.GetReturnIDs method")
        }</span>

        <span class="cov0" title="0">if len(mmGetReturnIDs.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetReturnIDs.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.GetReturnIDs method")
        }</span>

        <span class="cov0" title="0">mmGetReturnIDs.mock.funcGetReturnIDs = f
        mmGetReturnIDs.mock.funcGetReturnIDsOrigin = minimock.CallerInfo(1)
        return mmGetReturnIDs.mock</span>
}

// Times sets number of times ReturnStorageInterface.GetReturnIDs should be invoked
func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) Times(n uint64) *mReturnStorageInterfaceMockGetReturnIDs <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetReturnIDs.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.GetReturnIDs mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetReturnIDs.expectedInvocations, n)
        mmGetReturnIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetReturnIDs</span>
}

func (mmGetReturnIDs *mReturnStorageInterfaceMockGetReturnIDs) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetReturnIDs.expectations) == 0 &amp;&amp; mmGetReturnIDs.defaultExpectation == nil &amp;&amp; mmGetReturnIDs.mock.funcGetReturnIDs == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetReturnIDs.mock.afterGetReturnIDsCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetReturnIDs.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetReturnIDs implements mm_storage.ReturnStorageInterface
func (mmGetReturnIDs *ReturnStorageInterfaceMock) GetReturnIDs() (ua1 []uint) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmGetReturnIDs.beforeGetReturnIDsCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetReturnIDs.afterGetReturnIDsCounter, 1)

        mmGetReturnIDs.t.Helper()

        if mmGetReturnIDs.inspectFuncGetReturnIDs != nil </span><span class="cov0" title="0">{
                mmGetReturnIDs.inspectFuncGetReturnIDs()
        }</span>

        <span class="cov8" title="1">if mmGetReturnIDs.GetReturnIDsMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmGetReturnIDs.GetReturnIDsMock.defaultExpectation.Counter, 1)

                mm_results := mmGetReturnIDs.GetReturnIDsMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetReturnIDs.t.Fatal("No results are set for the ReturnStorageInterfaceMock.GetReturnIDs")
                }</span>
                <span class="cov8" title="1">return (*mm_results).ua1</span>
        }
        <span class="cov0" title="0">if mmGetReturnIDs.funcGetReturnIDs != nil </span><span class="cov0" title="0">{
                return mmGetReturnIDs.funcGetReturnIDs()
        }</span>
        <span class="cov0" title="0">mmGetReturnIDs.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.GetReturnIDs.")
        return</span>
}

// GetReturnIDsAfterCounter returns a count of finished ReturnStorageInterfaceMock.GetReturnIDs invocations
func (mmGetReturnIDs *ReturnStorageInterfaceMock) GetReturnIDsAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetReturnIDs.afterGetReturnIDsCounter)
}</span>

// GetReturnIDsBeforeCounter returns a count of ReturnStorageInterfaceMock.GetReturnIDs invocations
func (mmGetReturnIDs *ReturnStorageInterfaceMock) GetReturnIDsBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetReturnIDs.beforeGetReturnIDsCounter)
}</span>

// MinimockGetReturnIDsDone returns true if the count of the GetReturnIDs invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockGetReturnIDsDone() bool <span class="cov8" title="1">{
        if m.GetReturnIDsMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetReturnIDsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetReturnIDsMock.invocationsDone()</span>
}

// MinimockGetReturnIDsInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockGetReturnIDsInspect() <span class="cov0" title="0">{
        for _, e := range m.GetReturnIDsMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ReturnStorageInterfaceMock.GetReturnIDs")
                }</span>
        }

        <span class="cov0" title="0">afterGetReturnIDsCounter := mm_atomic.LoadUint64(&amp;m.afterGetReturnIDsCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetReturnIDsMock.defaultExpectation != nil &amp;&amp; afterGetReturnIDsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturnIDs at\n%s", m.GetReturnIDsMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetReturnIDs != nil &amp;&amp; afterGetReturnIDsCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.GetReturnIDs at\n%s", m.funcGetReturnIDsOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetReturnIDsMock.invocationsDone() &amp;&amp; afterGetReturnIDsCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.GetReturnIDs at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetReturnIDsMock.expectedInvocations), m.GetReturnIDsMock.expectedInvocationsOrigin, afterGetReturnIDsCounter)
        }</span>
}

type mReturnStorageInterfaceMockIsConsist struct {
        optional           bool
        mock               *ReturnStorageInterfaceMock
        defaultExpectation *ReturnStorageInterfaceMockIsConsistExpectation
        expectations       []*ReturnStorageInterfaceMockIsConsistExpectation

        callArgs []*ReturnStorageInterfaceMockIsConsistParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockIsConsistExpectation specifies expectation struct of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistExpectation struct {
        mock               *ReturnStorageInterfaceMock
        params             *ReturnStorageInterfaceMockIsConsistParams
        paramPtrs          *ReturnStorageInterfaceMockIsConsistParamPtrs
        expectationOrigins ReturnStorageInterfaceMockIsConsistExpectationOrigins
        results            *ReturnStorageInterfaceMockIsConsistResults
        returnOrigin       string
        Counter            uint64
}

// ReturnStorageInterfaceMockIsConsistParams contains parameters of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistParams struct {
        id uint
}

// ReturnStorageInterfaceMockIsConsistParamPtrs contains pointers to parameters of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistParamPtrs struct {
        id *uint
}

// ReturnStorageInterfaceMockIsConsistResults contains results of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistResults struct {
        b1 bool
}

// ReturnStorageInterfaceMockIsConsistOrigins contains origins of expectations of the ReturnStorageInterface.IsConsist
type ReturnStorageInterfaceMockIsConsistExpectationOrigins struct {
        origin   string
        originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Optional() *mReturnStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        mmIsConsist.optional = true
        return mmIsConsist
}</span>

// Expect sets up expected params for ReturnStorageInterface.IsConsist
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Expect(id uint) *mReturnStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        if mmIsConsist.mock.funcIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsConsist.defaultExpectation = &amp;ReturnStorageInterfaceMockIsConsistExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmIsConsist.defaultExpectation.params = &amp;ReturnStorageInterfaceMockIsConsistParams{id}
        mmIsConsist.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmIsConsist.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmIsConsist.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmIsConsist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsConsist.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmIsConsist</span>
}

// ExpectIdParam1 sets up expected param id for ReturnStorageInterface.IsConsist
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) ExpectIdParam1(id uint) *mReturnStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        if mmIsConsist.mock.funcIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsConsist.defaultExpectation = &amp;ReturnStorageInterfaceMockIsConsistExpectation{}
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmIsConsist.defaultExpectation.paramPtrs = &amp;ReturnStorageInterfaceMockIsConsistParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmIsConsist.defaultExpectation.paramPtrs.id = &amp;id
        mmIsConsist.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmIsConsist</span>
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.IsConsist
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Inspect(f func(id uint)) *mReturnStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        if mmIsConsist.mock.inspectFuncIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.IsConsist")
        }</span>

        <span class="cov0" title="0">mmIsConsist.mock.inspectFuncIsConsist = f

        return mmIsConsist</span>
}

// Return sets up results that will be returned by ReturnStorageInterface.IsConsist
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Return(b1 bool) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmIsConsist.mock.funcIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmIsConsist.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmIsConsist.defaultExpectation = &amp;ReturnStorageInterfaceMockIsConsistExpectation{mock: mmIsConsist.mock}
        }</span>
        <span class="cov0" title="0">mmIsConsist.defaultExpectation.results = &amp;ReturnStorageInterfaceMockIsConsistResults{b1}
        mmIsConsist.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmIsConsist.mock</span>
}

// Set uses given function f to mock the ReturnStorageInterface.IsConsist method
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Set(f func(id uint) (b1 bool)) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmIsConsist.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.IsConsist method")
        }</span>

        <span class="cov0" title="0">if len(mmIsConsist.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.IsConsist method")
        }</span>

        <span class="cov0" title="0">mmIsConsist.mock.funcIsConsist = f
        mmIsConsist.mock.funcIsConsistOrigin = minimock.CallerInfo(1)
        return mmIsConsist.mock</span>
}

// When sets expectation for the ReturnStorageInterface.IsConsist which will trigger the result defined by the following
// Then helper
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) When(id uint) *ReturnStorageInterfaceMockIsConsistExpectation <span class="cov0" title="0">{
        if mmIsConsist.mock.funcIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("ReturnStorageInterfaceMock.IsConsist mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ReturnStorageInterfaceMockIsConsistExpectation{
                mock:               mmIsConsist.mock,
                params:             &amp;ReturnStorageInterfaceMockIsConsistParams{id},
                expectationOrigins: ReturnStorageInterfaceMockIsConsistExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmIsConsist.expectations = append(mmIsConsist.expectations, expectation)
        return expectation</span>
}

// Then sets up ReturnStorageInterface.IsConsist return parameters for the expectation previously defined by the When method
func (e *ReturnStorageInterfaceMockIsConsistExpectation) Then(b1 bool) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        e.results = &amp;ReturnStorageInterfaceMockIsConsistResults{b1}
        return e.mock
}</span>

// Times sets number of times ReturnStorageInterface.IsConsist should be invoked
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Times(n uint64) *mReturnStorageInterfaceMockIsConsist <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmIsConsist.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.IsConsist mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmIsConsist.expectedInvocations, n)
        mmIsConsist.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmIsConsist</span>
}

func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmIsConsist.expectations) == 0 &amp;&amp; mmIsConsist.defaultExpectation == nil &amp;&amp; mmIsConsist.mock.funcIsConsist == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmIsConsist.mock.afterIsConsistCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmIsConsist.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// IsConsist implements mm_storage.ReturnStorageInterface
func (mmIsConsist *ReturnStorageInterfaceMock) IsConsist(id uint) (b1 bool) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmIsConsist.beforeIsConsistCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmIsConsist.afterIsConsistCounter, 1)

        mmIsConsist.t.Helper()

        if mmIsConsist.inspectFuncIsConsist != nil </span><span class="cov0" title="0">{
                mmIsConsist.inspectFuncIsConsist(id)
        }</span>

        <span class="cov0" title="0">mm_params := ReturnStorageInterfaceMockIsConsistParams{id}

        // Record call args
        mmIsConsist.IsConsistMock.mutex.Lock()
        mmIsConsist.IsConsistMock.callArgs = append(mmIsConsist.IsConsistMock.callArgs, &amp;mm_params)
        mmIsConsist.IsConsistMock.mutex.Unlock()

        for _, e := range mmIsConsist.IsConsistMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.b1
                }</span>
        }

        <span class="cov0" title="0">if mmIsConsist.IsConsistMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmIsConsist.IsConsistMock.defaultExpectation.Counter, 1)
                mm_want := mmIsConsist.IsConsistMock.defaultExpectation.params
                mm_want_ptrs := mmIsConsist.IsConsistMock.defaultExpectation.paramPtrs

                mm_got := ReturnStorageInterfaceMockIsConsistParams{id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmIsConsist.t.Errorf("ReturnStorageInterfaceMock.IsConsist got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmIsConsist.IsConsistMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmIsConsist.t.Errorf("ReturnStorageInterfaceMock.IsConsist got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmIsConsist.IsConsistMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmIsConsist.IsConsistMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmIsConsist.t.Fatal("No results are set for the ReturnStorageInterfaceMock.IsConsist")
                }</span>
                <span class="cov0" title="0">return (*mm_results).b1</span>
        }
        <span class="cov0" title="0">if mmIsConsist.funcIsConsist != nil </span><span class="cov0" title="0">{
                return mmIsConsist.funcIsConsist(id)
        }</span>
        <span class="cov0" title="0">mmIsConsist.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.IsConsist. %v", id)
        return</span>
}

// IsConsistAfterCounter returns a count of finished ReturnStorageInterfaceMock.IsConsist invocations
func (mmIsConsist *ReturnStorageInterfaceMock) IsConsistAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIsConsist.afterIsConsistCounter)
}</span>

// IsConsistBeforeCounter returns a count of ReturnStorageInterfaceMock.IsConsist invocations
func (mmIsConsist *ReturnStorageInterfaceMock) IsConsistBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmIsConsist.beforeIsConsistCounter)
}</span>

// Calls returns a list of arguments used in each call to ReturnStorageInterfaceMock.IsConsist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsConsist *mReturnStorageInterfaceMockIsConsist) Calls() []*ReturnStorageInterfaceMockIsConsistParams <span class="cov0" title="0">{
        mmIsConsist.mutex.RLock()

        argCopy := make([]*ReturnStorageInterfaceMockIsConsistParams, len(mmIsConsist.callArgs))
        copy(argCopy, mmIsConsist.callArgs)

        mmIsConsist.mutex.RUnlock()

        return argCopy
}</span>

// MinimockIsConsistDone returns true if the count of the IsConsist invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockIsConsistDone() bool <span class="cov8" title="1">{
        if m.IsConsistMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.IsConsistMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.IsConsistMock.invocationsDone()</span>
}

// MinimockIsConsistInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockIsConsistInspect() <span class="cov0" title="0">{
        for _, e := range m.IsConsistMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.IsConsist at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterIsConsistCounter := mm_atomic.LoadUint64(&amp;m.afterIsConsistCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.IsConsistMock.defaultExpectation != nil &amp;&amp; afterIsConsistCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.IsConsistMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.IsConsist at\n%s", m.IsConsistMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ReturnStorageInterfaceMock.IsConsist at\n%s with params: %#v", m.IsConsistMock.defaultExpectation.expectationOrigins.origin, *m.IsConsistMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcIsConsist != nil &amp;&amp; afterIsConsistCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.IsConsist at\n%s", m.funcIsConsistOrigin)
        }</span>

        <span class="cov0" title="0">if !m.IsConsistMock.invocationsDone() &amp;&amp; afterIsConsistCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.IsConsist at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.IsConsistMock.expectedInvocations), m.IsConsistMock.expectedInvocationsOrigin, afterIsConsistCounter)
        }</span>
}

type mReturnStorageInterfaceMockReadFromJSON struct {
        optional           bool
        mock               *ReturnStorageInterfaceMock
        defaultExpectation *ReturnStorageInterfaceMockReadFromJSONExpectation
        expectations       []*ReturnStorageInterfaceMockReadFromJSONExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockReadFromJSONExpectation specifies expectation struct of the ReturnStorageInterface.ReadFromJSON
type ReturnStorageInterfaceMockReadFromJSONExpectation struct {
        mock *ReturnStorageInterfaceMock

        results      *ReturnStorageInterfaceMockReadFromJSONResults
        returnOrigin string
        Counter      uint64
}

// ReturnStorageInterfaceMockReadFromJSONResults contains results of the ReturnStorageInterface.ReadFromJSON
type ReturnStorageInterfaceMockReadFromJSONResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Optional() *mReturnStorageInterfaceMockReadFromJSON <span class="cov0" title="0">{
        mmReadFromJSON.optional = true
        return mmReadFromJSON
}</span>

// Expect sets up expected params for ReturnStorageInterface.ReadFromJSON
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Expect() *mReturnStorageInterfaceMockReadFromJSON <span class="cov0" title="0">{
        if mmReadFromJSON.mock.funcReadFromJSON != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("ReturnStorageInterfaceMock.ReadFromJSON mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmReadFromJSON.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmReadFromJSON.defaultExpectation = &amp;ReturnStorageInterfaceMockReadFromJSONExpectation{}
        }</span>

        <span class="cov0" title="0">return mmReadFromJSON</span>
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.ReadFromJSON
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Inspect(f func()) *mReturnStorageInterfaceMockReadFromJSON <span class="cov0" title="0">{
        if mmReadFromJSON.mock.inspectFuncReadFromJSON != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.ReadFromJSON")
        }</span>

        <span class="cov0" title="0">mmReadFromJSON.mock.inspectFuncReadFromJSON = f

        return mmReadFromJSON</span>
}

// Return sets up results that will be returned by ReturnStorageInterface.ReadFromJSON
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Return(err error) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmReadFromJSON.mock.funcReadFromJSON != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("ReturnStorageInterfaceMock.ReadFromJSON mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmReadFromJSON.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmReadFromJSON.defaultExpectation = &amp;ReturnStorageInterfaceMockReadFromJSONExpectation{mock: mmReadFromJSON.mock}
        }</span>
        <span class="cov0" title="0">mmReadFromJSON.defaultExpectation.results = &amp;ReturnStorageInterfaceMockReadFromJSONResults{err}
        mmReadFromJSON.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmReadFromJSON.mock</span>
}

// Set uses given function f to mock the ReturnStorageInterface.ReadFromJSON method
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Set(f func() (err error)) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmReadFromJSON.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.ReadFromJSON method")
        }</span>

        <span class="cov0" title="0">if len(mmReadFromJSON.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.ReadFromJSON method")
        }</span>

        <span class="cov0" title="0">mmReadFromJSON.mock.funcReadFromJSON = f
        mmReadFromJSON.mock.funcReadFromJSONOrigin = minimock.CallerInfo(1)
        return mmReadFromJSON.mock</span>
}

// Times sets number of times ReturnStorageInterface.ReadFromJSON should be invoked
func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) Times(n uint64) *mReturnStorageInterfaceMockReadFromJSON <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmReadFromJSON.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.ReadFromJSON mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmReadFromJSON.expectedInvocations, n)
        mmReadFromJSON.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmReadFromJSON</span>
}

func (mmReadFromJSON *mReturnStorageInterfaceMockReadFromJSON) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmReadFromJSON.expectations) == 0 &amp;&amp; mmReadFromJSON.defaultExpectation == nil &amp;&amp; mmReadFromJSON.mock.funcReadFromJSON == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmReadFromJSON.mock.afterReadFromJSONCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmReadFromJSON.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ReadFromJSON implements mm_storage.ReturnStorageInterface
func (mmReadFromJSON *ReturnStorageInterfaceMock) ReadFromJSON() (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmReadFromJSON.beforeReadFromJSONCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmReadFromJSON.afterReadFromJSONCounter, 1)

        mmReadFromJSON.t.Helper()

        if mmReadFromJSON.inspectFuncReadFromJSON != nil </span><span class="cov0" title="0">{
                mmReadFromJSON.inspectFuncReadFromJSON()
        }</span>

        <span class="cov0" title="0">if mmReadFromJSON.ReadFromJSONMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmReadFromJSON.ReadFromJSONMock.defaultExpectation.Counter, 1)

                mm_results := mmReadFromJSON.ReadFromJSONMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmReadFromJSON.t.Fatal("No results are set for the ReturnStorageInterfaceMock.ReadFromJSON")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmReadFromJSON.funcReadFromJSON != nil </span><span class="cov0" title="0">{
                return mmReadFromJSON.funcReadFromJSON()
        }</span>
        <span class="cov0" title="0">mmReadFromJSON.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.ReadFromJSON.")
        return</span>
}

// ReadFromJSONAfterCounter returns a count of finished ReturnStorageInterfaceMock.ReadFromJSON invocations
func (mmReadFromJSON *ReturnStorageInterfaceMock) ReadFromJSONAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmReadFromJSON.afterReadFromJSONCounter)
}</span>

// ReadFromJSONBeforeCounter returns a count of ReturnStorageInterfaceMock.ReadFromJSON invocations
func (mmReadFromJSON *ReturnStorageInterfaceMock) ReadFromJSONBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmReadFromJSON.beforeReadFromJSONCounter)
}</span>

// MinimockReadFromJSONDone returns true if the count of the ReadFromJSON invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockReadFromJSONDone() bool <span class="cov8" title="1">{
        if m.ReadFromJSONMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.ReadFromJSONMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.ReadFromJSONMock.invocationsDone()</span>
}

// MinimockReadFromJSONInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockReadFromJSONInspect() <span class="cov0" title="0">{
        for _, e := range m.ReadFromJSONMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ReturnStorageInterfaceMock.ReadFromJSON")
                }</span>
        }

        <span class="cov0" title="0">afterReadFromJSONCounter := mm_atomic.LoadUint64(&amp;m.afterReadFromJSONCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ReadFromJSONMock.defaultExpectation != nil &amp;&amp; afterReadFromJSONCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.ReadFromJSON at\n%s", m.ReadFromJSONMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcReadFromJSON != nil &amp;&amp; afterReadFromJSONCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.ReadFromJSON at\n%s", m.funcReadFromJSONOrigin)
        }</span>

        <span class="cov0" title="0">if !m.ReadFromJSONMock.invocationsDone() &amp;&amp; afterReadFromJSONCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.ReadFromJSON at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ReadFromJSONMock.expectedInvocations), m.ReadFromJSONMock.expectedInvocationsOrigin, afterReadFromJSONCounter)
        }</span>
}

type mReturnStorageInterfaceMockWriteToJSON struct {
        optional           bool
        mock               *ReturnStorageInterfaceMock
        defaultExpectation *ReturnStorageInterfaceMockWriteToJSONExpectation
        expectations       []*ReturnStorageInterfaceMockWriteToJSONExpectation

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// ReturnStorageInterfaceMockWriteToJSONExpectation specifies expectation struct of the ReturnStorageInterface.WriteToJSON
type ReturnStorageInterfaceMockWriteToJSONExpectation struct {
        mock *ReturnStorageInterfaceMock

        results      *ReturnStorageInterfaceMockWriteToJSONResults
        returnOrigin string
        Counter      uint64
}

// ReturnStorageInterfaceMockWriteToJSONResults contains results of the ReturnStorageInterface.WriteToJSON
type ReturnStorageInterfaceMockWriteToJSONResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Optional() *mReturnStorageInterfaceMockWriteToJSON <span class="cov0" title="0">{
        mmWriteToJSON.optional = true
        return mmWriteToJSON
}</span>

// Expect sets up expected params for ReturnStorageInterface.WriteToJSON
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Expect() *mReturnStorageInterfaceMockWriteToJSON <span class="cov0" title="0">{
        if mmWriteToJSON.mock.funcWriteToJSON != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("ReturnStorageInterfaceMock.WriteToJSON mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWriteToJSON.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWriteToJSON.defaultExpectation = &amp;ReturnStorageInterfaceMockWriteToJSONExpectation{}
        }</span>

        <span class="cov0" title="0">return mmWriteToJSON</span>
}

// Inspect accepts an inspector function that has same arguments as the ReturnStorageInterface.WriteToJSON
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Inspect(f func()) *mReturnStorageInterfaceMockWriteToJSON <span class="cov0" title="0">{
        if mmWriteToJSON.mock.inspectFuncWriteToJSON != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("Inspect function is already set for ReturnStorageInterfaceMock.WriteToJSON")
        }</span>

        <span class="cov0" title="0">mmWriteToJSON.mock.inspectFuncWriteToJSON = f

        return mmWriteToJSON</span>
}

// Return sets up results that will be returned by ReturnStorageInterface.WriteToJSON
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Return(err error) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmWriteToJSON.mock.funcWriteToJSON != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("ReturnStorageInterfaceMock.WriteToJSON mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmWriteToJSON.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmWriteToJSON.defaultExpectation = &amp;ReturnStorageInterfaceMockWriteToJSONExpectation{mock: mmWriteToJSON.mock}
        }</span>
        <span class="cov0" title="0">mmWriteToJSON.defaultExpectation.results = &amp;ReturnStorageInterfaceMockWriteToJSONResults{err}
        mmWriteToJSON.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmWriteToJSON.mock</span>
}

// Set uses given function f to mock the ReturnStorageInterface.WriteToJSON method
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Set(f func() (err error)) *ReturnStorageInterfaceMock <span class="cov0" title="0">{
        if mmWriteToJSON.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("Default expectation is already set for the ReturnStorageInterface.WriteToJSON method")
        }</span>

        <span class="cov0" title="0">if len(mmWriteToJSON.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("Some expectations are already set for the ReturnStorageInterface.WriteToJSON method")
        }</span>

        <span class="cov0" title="0">mmWriteToJSON.mock.funcWriteToJSON = f
        mmWriteToJSON.mock.funcWriteToJSONOrigin = minimock.CallerInfo(1)
        return mmWriteToJSON.mock</span>
}

// Times sets number of times ReturnStorageInterface.WriteToJSON should be invoked
func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) Times(n uint64) *mReturnStorageInterfaceMockWriteToJSON <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmWriteToJSON.mock.t.Fatalf("Times of ReturnStorageInterfaceMock.WriteToJSON mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmWriteToJSON.expectedInvocations, n)
        mmWriteToJSON.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmWriteToJSON</span>
}

func (mmWriteToJSON *mReturnStorageInterfaceMockWriteToJSON) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmWriteToJSON.expectations) == 0 &amp;&amp; mmWriteToJSON.defaultExpectation == nil &amp;&amp; mmWriteToJSON.mock.funcWriteToJSON == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmWriteToJSON.mock.afterWriteToJSONCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmWriteToJSON.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// WriteToJSON implements mm_storage.ReturnStorageInterface
func (mmWriteToJSON *ReturnStorageInterfaceMock) WriteToJSON() (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmWriteToJSON.beforeWriteToJSONCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmWriteToJSON.afterWriteToJSONCounter, 1)

        mmWriteToJSON.t.Helper()

        if mmWriteToJSON.inspectFuncWriteToJSON != nil </span><span class="cov0" title="0">{
                mmWriteToJSON.inspectFuncWriteToJSON()
        }</span>

        <span class="cov0" title="0">if mmWriteToJSON.WriteToJSONMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmWriteToJSON.WriteToJSONMock.defaultExpectation.Counter, 1)

                mm_results := mmWriteToJSON.WriteToJSONMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmWriteToJSON.t.Fatal("No results are set for the ReturnStorageInterfaceMock.WriteToJSON")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmWriteToJSON.funcWriteToJSON != nil </span><span class="cov0" title="0">{
                return mmWriteToJSON.funcWriteToJSON()
        }</span>
        <span class="cov0" title="0">mmWriteToJSON.t.Fatalf("Unexpected call to ReturnStorageInterfaceMock.WriteToJSON.")
        return</span>
}

// WriteToJSONAfterCounter returns a count of finished ReturnStorageInterfaceMock.WriteToJSON invocations
func (mmWriteToJSON *ReturnStorageInterfaceMock) WriteToJSONAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWriteToJSON.afterWriteToJSONCounter)
}</span>

// WriteToJSONBeforeCounter returns a count of ReturnStorageInterfaceMock.WriteToJSON invocations
func (mmWriteToJSON *ReturnStorageInterfaceMock) WriteToJSONBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmWriteToJSON.beforeWriteToJSONCounter)
}</span>

// MinimockWriteToJSONDone returns true if the count of the WriteToJSON invocations corresponds
// the number of defined expectations
func (m *ReturnStorageInterfaceMock) MinimockWriteToJSONDone() bool <span class="cov8" title="1">{
        if m.WriteToJSONMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.WriteToJSONMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.WriteToJSONMock.invocationsDone()</span>
}

// MinimockWriteToJSONInspect logs each unmet expectation
func (m *ReturnStorageInterfaceMock) MinimockWriteToJSONInspect() <span class="cov0" title="0">{
        for _, e := range m.WriteToJSONMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ReturnStorageInterfaceMock.WriteToJSON")
                }</span>
        }

        <span class="cov0" title="0">afterWriteToJSONCounter := mm_atomic.LoadUint64(&amp;m.afterWriteToJSONCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.WriteToJSONMock.defaultExpectation != nil &amp;&amp; afterWriteToJSONCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.WriteToJSON at\n%s", m.WriteToJSONMock.defaultExpectation.returnOrigin)
        }</span>
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcWriteToJSON != nil &amp;&amp; afterWriteToJSONCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to ReturnStorageInterfaceMock.WriteToJSON at\n%s", m.funcWriteToJSONOrigin)
        }</span>

        <span class="cov0" title="0">if !m.WriteToJSONMock.invocationsDone() &amp;&amp; afterWriteToJSONCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ReturnStorageInterfaceMock.WriteToJSON at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.WriteToJSONMock.expectedInvocations), m.WriteToJSONMock.expectedInvocationsOrigin, afterWriteToJSONCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReturnStorageInterfaceMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddReturnToStorageInspect()

                        m.MinimockDeleteReturnFromStorageInspect()

                        m.MinimockGetReturnInspect()

                        m.MinimockGetReturnIDsInspect()

                        m.MinimockIsConsistInspect()

                        m.MinimockReadFromJSONInspect()

                        m.MinimockWriteToJSONInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReturnStorageInterfaceMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ReturnStorageInterfaceMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockAddReturnToStorageDone() &amp;&amp;
                m.MinimockDeleteReturnFromStorageDone() &amp;&amp;
                m.MinimockGetReturnDone() &amp;&amp;
                m.MinimockGetReturnIDsDone() &amp;&amp;
                m.MinimockIsConsistDone() &amp;&amp;
                m.MinimockReadFromJSONDone() &amp;&amp;
                m.MinimockWriteToJSONDone()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package orders

import (
        "fmt"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
        e "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/errors"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/pagination"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/storage"
        "sort"
        "time"
)

// принять заказ от курьера
func AcceptOrder(s storage.OrderStorageInterface, or *models.Order) error <span class="cov8" title="1">{
        if s.IsConsist(or.ID) </span><span class="cov8" title="1">{
                return e.ErrIsConsist
        }</span>
        <span class="cov8" title="1">if or.KeepUntilDate.Before(time.Now()) </span><span class="cov8" title="1">{
                return e.ErrDate
        }</span>
        <span class="cov8" title="1">or.State = models.AcceptState
        or.AcceptTime = time.Now()
        s.AddOrderToStorage(or)
        return nil</span>
}

// доставить заказ юзеру
func PlaceOrder(s storage.OrderStorageInterface, ids []uint) error <span class="cov8" title="1">{
        if len(ids) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Length of ids array is 0 ")
        }</span>

        <span class="cov8" title="1">CheckIDsOrders(s, ids)

        for _, id := range ids </span><span class="cov8" title="1">{
                order, exists := s.GetOrder(id)
                if !exists </span><span class="cov8" title="1">{
                        return e.ErrNoConsist
                }</span>
                <span class="cov8" title="1">if order.State == models.PlaceState </span><span class="cov8" title="1">{
                        return fmt.Errorf("Order by id: %d is already placed", id)
                }</span>

                <span class="cov8" title="1">if order.State == models.SoftDelete </span><span class="cov8" title="1">{
                        return fmt.Errorf("Order by id: %d was deleted", id)
                }</span>

                <span class="cov8" title="1">if !order.KeepUntilDate.After(time.Now()) </span><span class="cov8" title="1">{
                        return fmt.Errorf("Order by id: %d cannot be issued to the customer because the date is invalid", id)
                }</span>

                <span class="cov8" title="1">order.State = models.PlaceState
                order.PlaceDate = time.Now()</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ListOrders(s storage.OrderStorageInterface, id uint, n int, inPuP bool) error <span class="cov8" title="1">{
        if !s.IsConsist(id) </span><span class="cov8" title="1">{
                return e.ErrNoConsist
        }</span>
        <span class="cov8" title="1">var list []*models.Order
        list = FilterOrders(s, id, inPuP)
        SortOrders(list)
        if n &lt; 1 </span><span class="cov0" title="0">{
                n = 1
        }</span> else<span class="cov8" title="1"> if n &gt; len(list) </span><span class="cov8" title="1">{
                n = len(list)
        }</span>
        <span class="cov8" title="1">if !inPuP </span><span class="cov8" title="1">{
                list = list[:n]
        }</span>
        <span class="cov8" title="1">return pagination.ScrollPagination(list, 1)</span>
}

// вернуть заказ юзеру
func ReturnOrder(s storage.OrderStorageInterface, id uint) error <span class="cov8" title="1">{
        order, exists := s.GetOrder(id)
        if !exists </span><span class="cov8" title="1">{
                return e.ErrNoConsist
        }</span>
        <span class="cov8" title="1">return order.CanReturned()</span>
}

func SortOrders(o []*models.Order) error <span class="cov8" title="1">{
        sort.Slice(o, func(i, j int) bool </span><span class="cov0" title="0">{
                return o[i].AcceptTime.Before(o[j].AcceptTime)
        }</span>)
        <span class="cov8" title="1">return nil</span>
}

func FilterOrders(s storage.OrderStorageInterface, id uint, inPuP bool) []*models.Order <span class="cov8" title="1">{
        var filtered []*models.Order
        var ids []uint
        ids = s.GetOrderIDs()
        for _, o := range ids </span><span class="cov0" title="0">{
                order, exists := s.GetOrder(o)
                if exists &amp;&amp; order.UserID == id &amp;&amp; (!inPuP || order.State == models.AcceptState || order.State == models.ReturnedState) </span><span class="cov0" title="0">{
                        filtered = append(filtered, order)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

func CheckIDsOrders(s storage.OrderStorageInterface, ids []uint) error <span class="cov8" title="1">{
        order, _ := s.GetOrder(ids[0])
        temp := order.UserID
        for _, id := range ids </span><span class="cov8" title="1">{
                order, _ = s.GetOrder(id)
                if order.UserID != temp </span><span class="cov0" title="0">{
                        return e.ErrNotAllIDs
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controller

import (
        "errors"
        "fmt"
)

func AddWrap() (bool, error) <span class="cov0" title="0">{
        var answer string
        fmt.Println("whether you want to add a wrap to your package?['y' - yes, 'n' - no ]")
        fmt.Scan(&amp;answer)
        switch answer </span>{
        case "y":<span class="cov0" title="0">
                return true, nil</span>
        case "n":<span class="cov0" title="0">
                return false, nil</span>
        default:<span class="cov0" title="0">
                return false, errors.New("Invalid input")</span>

        }

}
</pre>
		
		<pre class="file" id="file9" style="display: none">package packing

import (
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/packing/controller"
)

// интерфейс упаковки
type Packager interface {
        Pack(o *models.Order) error
}

type BoxPackaging struct {
}

func (b *BoxPackaging) Pack(o *models.Order) error <span class="cov0" title="0">{
        if o.Weight &gt; 30 </span><span class="cov0" title="0">{
                return ErrWeightBox
        }</span>

        <span class="cov0" title="0">o.Price += 20

        ans, err := controller.AddWrap()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ans </span><span class="cov0" title="0">{
                Packing(o, "wrap")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BundlePackaging struct {
}

func (b *BundlePackaging) Pack(o *models.Order) error <span class="cov0" title="0">{
        if o.Weight &gt; 10 </span><span class="cov0" title="0">{
                return ErrWeightBundle
        }</span>

        <span class="cov0" title="0">o.Price += 5

        ans, err := controller.AddWrap()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ans </span><span class="cov0" title="0">{
                Packing(o, "wrap")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type WrapPackaging struct {
}

func (w *WrapPackaging) Pack(o *models.Order) error <span class="cov0" title="0">{
        o.Price += 1
        return nil
}</span>

// рациональное решение в случае если в дальнейшем понадобиться добавить еще одну упаковку
func GetPackager(pack string) (Packager, error) <span class="cov0" title="0">{
        switch pack </span>{
        case "box":<span class="cov0" title="0">
                return &amp;BoxPackaging{}, nil</span>
        case "bundle":<span class="cov0" title="0">
                return &amp;BundlePackaging{}, nil</span>
        case "wrap":<span class="cov0" title="0">
                return &amp;WrapPackaging{}, nil</span>
        default:<span class="cov0" title="0">
                return nil, ErrInvalidType</span>
        }
}

// упаковка
func Packing(o *models.Order, pack string) error <span class="cov0" title="0">{
        packager, err := GetPackager(pack)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return packager.Pack(o)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package pagination

import (
        "bufio"
        "fmt"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
        e "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/errors"
        "os"
        "strings"
)

// пагинация скроллом
func ScrollPagination(orders []*models.Order, limit int) error <span class="cov8" title="1">{
        total := len(orders)
        lastIndex := 0

        if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 1
        }</span>

        <span class="cov8" title="1">reader := bufio.NewReader(os.Stdin)
        fmt.Println("Press Enter to load next Order")
        for </span><span class="cov8" title="1">{
                start := lastIndex
                end := lastIndex + limit
                if end &gt; total </span><span class="cov8" title="1">{
                        end = total
                }</span>

                <span class="cov8" title="1">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                        fmt.Printf("OrderID: %v, Reciver: %v, State: %v, Price: %v₽, Date until which it will be stored: %v ",
                                orders[i].ID, orders[i].UserID, orders[i].State, orders[i].Price, orders[i].KeepUntilDate)
                }</span>
                <span class="cov8" title="1">lastIndex = end

                if lastIndex &gt;= total </span><span class="cov8" title="1">{
                        fmt.Println("")
                        fmt.Println("End.")
                        return nil
                }</span>

                <span class="cov0" title="0">input, _ := reader.ReadString('\n')
                _ = strings.TrimSpace(input)</span>

        }

}

// пагинация постраничная
func PagePagination(returns []*models.Return, page, limit int) error <span class="cov8" title="1">{
        if page &lt; 1 || limit &lt; 1 </span><span class="cov8" title="1">{
                return e.ErrLimitPage
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * limit

        if offset &gt;= len(returns) </span><span class="cov8" title="1">{
                return e.ErrNoMoreItems
        }</span>

        <span class="cov8" title="1">end := offset + limit
        if end &gt; len(returns) </span><span class="cov0" title="0">{
                end = len(returns)
        }</span>
        <span class="cov8" title="1">returns = returns[offset:end]
        for _, v := range returns </span><span class="cov8" title="1">{
                fmt.Printf("OrderID: %v, UserID: %v \n", v.ID, v.UserID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package returns

import (
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
        e "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/errors"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/service/pagination"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/storage"
        "time"
)

func RefundOrder(rs storage.ReturnStorageInterface, os storage.OrderStorageInterface, id uint, userId uint) error <span class="cov8" title="1">{
        order, exists := os.GetOrder(id)
        if !exists </span><span class="cov8" title="1">{
                return e.ErrCheckOrderID
        }</span>
        <span class="cov8" title="1">if order.State != models.PlaceState </span><span class="cov8" title="1">{
                return e.ErrNotPlace
        }</span>
        <span class="cov8" title="1">if time.Now().After(order.PlaceDate.AddDate(0, 0, 2)) </span><span class="cov8" title="1">{
                return e.ErrTimeExpired
        }</span>
        <span class="cov8" title="1">if order.UserID != userId </span><span class="cov8" title="1">{
                return e.ErrIncorrectUserId
        }</span>

        <span class="cov8" title="1">rs.AddReturnToStorage(&amp;models.Return{
                ID:     id,
                UserID: userId,
        })
        order.State = models.ReturnedState

        return nil</span>
}

func ListReturns(rs storage.ReturnStorageInterface, limit, page int) error <span class="cov8" title="1">{
        var list []*models.Return
        for _, v := range rs.GetReturnIDs() </span><span class="cov8" title="1">{
                r, _ := rs.GetReturn(v)
                list = append(list, r)
        }</span>
        <span class="cov8" title="1">return pagination.PagePagination(list, page, limit)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package storage

import (
        "encoding/json"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
        "io"
        "os"
)

type OrderStorageInterface interface {
        AddOrderToStorage(or *models.Order)
        IsConsist(id uint) bool
        DeleteOrderFromStorage(id uint)
        GetOrder(id uint) (*models.Order, bool)
        GetOrderIDs() []uint
        ReadFromJSON() error
        WriteToJSON() error
}

type OrderStorage struct {
        Data map[uint]*models.Order
        path string
}

func (o *OrderStorage) Create() error <span class="cov0" title="0">{
        _, err := os.Create(o.path)
        return err
}</span>

func NewOrderStorage() *OrderStorage <span class="cov0" title="0">{
        return &amp;OrderStorage{Data: make(map[uint]*models.Order), path: "api/orders.json"}
}</span>

func (os *OrderStorage) AddOrderToStorage(or *models.Order) <span class="cov0" title="0">{
        os.Data[or.ID] = or
}</span>

func (o *OrderStorage) IsConsist(id uint) bool <span class="cov0" title="0">{
        _, ok := o.Data[id]
        return ok
}</span>

func (o *OrderStorage) DeleteOrderFromStorage(id uint) <span class="cov0" title="0">{
        delete(o.Data, id)
}</span>

// считываем с JSON-a
func (o *OrderStorage) ReadFromJSON() error <span class="cov0" title="0">{
        file, err := os.OpenFile(o.path, os.O_RDONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return ErrOpenFile
        }</span>
        <span class="cov0" title="0">defer file.Close()

        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return ErrReadFile
        }</span>

        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                o.Data = make(map[uint]*models.Order)
                return nil
        }</span>

        <span class="cov0" title="0">var i struct {
                Data map[uint]models.Order `json:"Data"`
        }

        err = json.Unmarshal(data, &amp;i)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">o.Data = make(map[uint]*models.Order)
        for orderID, order := range i.Data </span><span class="cov0" title="0">{
                orderCopy := order
                o.Data[orderID] = &amp;orderCopy
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o *OrderStorage) WriteToJSON() error <span class="cov0" title="0">{
        file, err := os.OpenFile("api/orders.json", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return ErrOpenFile
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        encoder.SetIndent(" ", "  ")
        if err := encoder.Encode(o); err != nil </span><span class="cov0" title="0">{
                return ErrEnocde
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (os *OrderStorage) GetOrder(id uint) (*models.Order, bool) <span class="cov0" title="0">{
        order, ok := os.Data[id]
        return order, ok
}</span>

func (os *OrderStorage) GetOrderIDs() []uint <span class="cov0" title="0">{
        var ids []uint
        for id := range os.Data </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return ids</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package storage

import (
        "encoding/json"
        "gitlab.ozon.dev/akugnerevich/homework.git/internal/models"
        "io"
        "os"
)

type ReturnStorageInterface interface {
        AddReturnToStorage(r *models.Return) error
        DeleteReturnFromStorage(id uint)
        IsConsist(id uint) bool
        GetReturn(id uint) (*models.Return, bool)
        GetReturnIDs() []uint
        ReadFromJSON() error
        WriteToJSON() error
}

type ReturnStorage struct {
        Data map[uint]*models.Return
        path string
}

func (r *ReturnStorage) Create() error <span class="cov0" title="0">{
        _, err := os.Create(r.path)
        return err
}</span>

func NewReturnStorage() *ReturnStorage <span class="cov0" title="0">{
        return &amp;ReturnStorage{Data: make(map[uint]*models.Return), path: "api/returns.json"}
}</span>

func (rs *ReturnStorage) AddReturnToStorage(r *models.Return) error <span class="cov0" title="0">{
        _, ok := rs.Data[r.ID]
        if ok </span><span class="cov0" title="0">{
                return ErrAlrReturn
        }</span> else<span class="cov0" title="0"> {
                rs.Data[r.ID] = r
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (rs *ReturnStorage) DeleteReturnFromStorage(id uint) <span class="cov0" title="0">{
        delete(rs.Data, id)
}</span>

// проверка на наличие
func (rs *ReturnStorage) IsConsist(id uint) bool <span class="cov0" title="0">{
        _, ok := rs.Data[id]
        return ok
}</span>

// считываем с JSON-a
func (rs *ReturnStorage) ReadFromJSON() error <span class="cov0" title="0">{
        file, err := os.OpenFile(rs.path, os.O_RDONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return ErrOpenFile
        }</span>
        <span class="cov0" title="0">defer file.Close()

        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return ErrReadFile
        }</span>

        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                rs.Data = make(map[uint]*models.Return)
                return nil
        }</span>

        <span class="cov0" title="0">var i struct {
                Data map[uint]models.Return `json:"Data"`
        }

        err = json.Unmarshal(data, &amp;i)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rs.Data = make(map[uint]*models.Return)
        for returnid, r := range i.Data </span><span class="cov0" title="0">{
                returnCopy := r
                rs.Data[returnid] = &amp;returnCopy
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (rs *ReturnStorage) WriteToJSON() error <span class="cov0" title="0">{
        file, err := os.OpenFile("api/returns.json", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return ErrOpenFile
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        encoder.SetIndent(" ", "  ")
        if err := encoder.Encode(rs); err != nil </span><span class="cov0" title="0">{
                return ErrEnocde
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (rs *ReturnStorage) GetReturn(id uint) (*models.Return, bool) <span class="cov0" title="0">{
        r, ok := rs.Data[id]
        return r, ok
}</span>

func (rs *ReturnStorage) GetReturnIDs() []uint <span class="cov0" title="0">{
        var ids []uint
        for id := range rs.Data </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return ids</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
